diff --git a/source/.travis.yml b/source/.travis.yml
deleted file mode 100644
index fa66635..0000000
--- a/source/.travis.yml
+++ /dev/null
@@ -1,85 +0,0 @@
-# This file has been generated -- see https://github.com/hvr/multi-ghc-travis
-language: c
-sudo: false
-
-cache:
-  directories:
-    - $HOME/.cabsnap
-    - $HOME/.cabal/packages
-
-before_cache:
-  - rm -fv $HOME/.cabal/packages/hackage.haskell.org/build-reports.log
-  - rm -fv $HOME/.cabal/packages/hackage.haskell.org/00-index.tar
-
-matrix:
-  include:
-    - env: CABALVER=1.16 GHCVER=7.6.3
-      compiler: ": #GHC 7.6.3"
-      addons: {apt: {packages: [cabal-install-1.16,ghc-7.6.3], sources: [hvr-ghc]}}
-    - env: CABALVER=1.18 GHCVER=7.8.4
-      compiler: ": #GHC 7.8.4"
-      addons: {apt: {packages: [cabal-install-1.18,ghc-7.8.4], sources: [hvr-ghc]}}
-    - env: CABALVER=1.22 GHCVER=7.10.3
-      compiler: ": #GHC 7.10.3"
-      addons: {apt: {packages: [cabal-install-1.22,ghc-7.10.3], sources: [hvr-ghc]}}
-    - env: CABALVER=1.24 GHCVER=8.0.1
-      compiler: ": #GHC 8.0.1"
-      addons: {apt: {packages: [cabal-install-1.24,ghc-8.0.1], sources: [hvr-ghc]}}
-
-before_install:
- - unset CC
- - export PATH=/opt/ghc/$GHCVER/bin:/opt/cabal/$CABALVER/bin:$PATH
-
-install:
- - cabal --version
- - echo "$(ghc --version) [$(ghc --print-project-git-commit-id 2> /dev/null || echo '?')]"
- - if [ -f $HOME/.cabal/packages/hackage.haskell.org/00-index.tar.gz ];
-   then
-     zcat $HOME/.cabal/packages/hackage.haskell.org/00-index.tar.gz >
-          $HOME/.cabal/packages/hackage.haskell.org/00-index.tar;
-   fi
- - travis_retry cabal update -v
- - sed -i 's/^jobs:/-- jobs:/' ${HOME}/.cabal/config
- - cabal install --only-dependencies --enable-tests --enable-benchmarks --dry -v > installplan.txt
- - sed -i -e '1,/^Resolving /d' installplan.txt; cat installplan.txt
-
-# check whether current requested install-plan matches cached package-db snapshot
- - if diff -u $HOME/.cabsnap/installplan.txt installplan.txt;
-   then
-     echo "cabal build-cache HIT";
-     rm -rfv .ghc;
-     cp -a $HOME/.cabsnap/ghc $HOME/.ghc;
-     cp -a $HOME/.cabsnap/lib $HOME/.cabsnap/share $HOME/.cabsnap/bin $HOME/.cabal/;
-   else
-     echo "cabal build-cache MISS";
-     rm -rf $HOME/.cabsnap;
-     mkdir -p $HOME/.ghc $HOME/.cabal/lib $HOME/.cabal/share $HOME/.cabal/bin;
-     cabal install --only-dependencies --enable-tests --enable-benchmarks;
-   fi
-
-# snapshot package-db on cache miss
- - if [ ! -d $HOME/.cabsnap ];
-   then
-      echo "snapshotting package-db to build-cache";
-      mkdir $HOME/.cabsnap;
-      cp -a $HOME/.ghc $HOME/.cabsnap/ghc;
-      cp -a $HOME/.cabal/lib $HOME/.cabal/share $HOME/.cabal/bin installplan.txt $HOME/.cabsnap/;
-   fi
-
-# Here starts the actual work to be performed for the package under test;
-# any command which exits with a non-zero exit code causes the build to fail.
-script:
- - if [ -f configure.ac ]; then autoreconf -i; fi
- - cabal configure --enable-tests --enable-benchmarks -v2  # -v2 provides useful information for debugging
- - cabal build   # this builds all libraries and executables (including tests/benchmarks)
- - cabal test
- - cabal check
- - cabal sdist   # tests that a source-distribution can be generated
-
-# Check that the resulting source distribution can be built & installed.
-# If there are no other `.tar.gz` files in `dist`, this can be even simpler:
-# `cabal install --force-reinstalls dist/*-*.tar.gz`
- - SRC_TGZ=$(cabal info . | awk '{print $2;exit}').tar.gz &&
-   (cd dist && cabal install --force-reinstalls "$SRC_TGZ")
-
-# EOF
diff --git a/source/CHANGES.md b/source/CHANGES.md
deleted file mode 100644
index e3c9cf3..0000000
--- a/source/CHANGES.md
+++ /dev/null
@@ -1,29 +0,0 @@
-# Change Log / Release Notes
-
-## 0.13
-
-  * Re-builds using script `<xmonaddir>/build` if it exists and is executable
-
-## 0.12 (December 14, 2015)
-
-  * Compiles with GHC 7.10.2, 7.8.4, and 7.6.3
-
-  * Use of [data-default][] allows using `def` where previously you
-    had to write `defaultConfig`, `defaultXPConfig`, etc.
-
-  * The [setlocale][] package is now used instead of a binding shipped
-    with xmonad proper allowing the use of `Main.hs` instead of
-    `Main.hsc`
-
-  * No longer encodes paths for `spawnPID`
-
-  * The default `manageHook` no longer floats Gimp windows
-
-  * Doesn't crash when there are fewer workspaces than screens
-
-  * `Query` is now an instance of `Applicative`
-
-  * Various improvements to the example configuration file
-
-[data-default]: http://hackage.haskell.org/package/data-default
-[setlocale]: https://hackage.haskell.org/package/setlocale
diff --git a/source/CONFIG b/source/CONFIG
deleted file mode 100644
index f83292b..0000000
--- a/source/CONFIG
+++ /dev/null
@@ -1,82 +0,0 @@
-== Configuring xmonad ==
-
-xmonad is configured by creating and editing the file:
-
-    ~/.xmonad/xmonad.hs
-
-xmonad then uses settings from this file as arguments to the window manager,
-on startup. For a complete example of possible settings, see the file:
-
-    man/xmonad.hs
-
-Further examples are on the website, wiki and extension documentation.
-
-    http://haskell.org/haskellwiki/Xmonad
-
-== A simple example ==
-
-Here is a basic example, which overrides the default border width,
-default terminal, and some colours. This text goes in the file
-$HOME/.xmonad/xmonad.hs :
-
-    import XMonad
-
-    main = xmonad $ def
-        { borderWidth        = 2
-        , terminal           = "urxvt"
-        , normalBorderColor  = "#cccccc"
-        , focusedBorderColor = "#cd8b00" }
-
-You can find the defaults in the file:
-
-    XMonad/Config.hs
-
-== Checking your xmonad.hs is correct ==
-
-Place this text in ~/.xmonad/xmonad.hs, and then check that it is
-syntactically and type correct by loading it in the Haskell
-interpreter:
-
-    $ ghci ~/.xmonad/xmonad.hs
-    GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
-    Loading package base ... linking ... done.
-    Ok, modules loaded: Main.
-
-    Prelude Main> :t main
-    main :: IO ()
-
-Ok, looks good.
-
-== Loading your configuration ==
-
-To have xmonad start using your settings, type 'mod-q'.  xmonad will
-then load this new file, and run it.  If it is unable to, the defaults
-are used.
-
-To load successfully, both 'xmonad' and 'ghc' must be in your $PATH
-environment variable.  If GHC isn't in your path, for some reason, you
-can compile the xmonad.hs file yourself:
-
-    $ cd ~/.xmonad
-    $ ghc --make xmonad.hs
-    $ ls
-    xmonad    xmonad.hi xmonad.hs xmonad.o
-
-When you hit mod-q, this newly compiled xmonad will be used.
-
-== Where are the defaults? ==
-
-The default configuration values are defined in the source file:
-
-    XMonad/Config.hs
-
-the XConfig data structure itself is defined in:
-
-    XMonad/Core.hs
-
-== Extensions ==
-
-Since the xmonad.hs file is just another Haskell module, you may import
-and use any Haskell code or libraries you wish. For example, you can use
-things from the xmonad-contrib library, or other code you write
-yourself.
diff --git a/source/Main.hs b/source/Main.hs
deleted file mode 100644
index 28351d0..0000000
--- a/source/Main.hs
+++ /dev/null
@@ -1,20 +0,0 @@
-----------------------------------------------------------------------------
--- |
--- Module      :  Main
--- Copyright   :  (c) Spencer Janssen 2007
--- License     :  BSD3-style (see LICENSE)
---
--- Maintainer  :  sjanssen@cse.unl.edu
--- Stability   :  unstable
--- Portability :  not portable, uses mtl, X11, posix
---
--- xmonad, a minimalist, tiling window manager for X11
---
------------------------------------------------------------------------------
-
-module Main (main) where
-
-import XMonad
-
-main :: IO ()
-main = xmonad def
diff --git a/source/README.md b/source/README.md
deleted file mode 100644
index 0757fd5..0000000
--- a/source/README.md
+++ /dev/null
@@ -1,117 +0,0 @@
-# xmonad: A Tiling Window Manager
-
-[xmonad][] is a tiling window manager for X. Windows are arranged
-automatically to tile the screen without gaps or overlap, maximising
-screen use. Window manager features are accessible from the keyboard:
-a mouse is optional. xmonad is written, configured and extensible in
-Haskell. Custom layout algorithms, key bindings and other extensions
-may be written by the user in config files. Layouts are applied
-dynamically, and different layouts may be used on each
-workspace. Xinerama is fully supported, allowing windows to be tiled
-on several physical screens.
-
-## Quick Start
-
-  * From hackage:
-
-        cabal update
-        cabal install xmonad xmonad-contrib
-
-  * Alternatively, build from source using the following repositories:
-
-    - <https://github.com/xmonad/xmonad>
-
-    - <https://github.com/xmonad/xmonad-contrib>
-
-For the full story, read on.
-
-## Building
-
-Building is quite straightforward, and requires a basic Haskell toolchain.
-On many systems xmonad is available as a binary package in your
-package system (e.g. on Debian or Gentoo). If at all possible, use this
-in preference to a source build, as the dependency resolution will be
-simpler.
-
-We'll now walk through the complete list of toolchain dependencies.
-
-  * GHC: the Glasgow Haskell Compiler
-
-    You first need a Haskell compiler. Your distribution's package
-    system will have binaries of GHC (the Glasgow Haskell Compiler),
-    the compiler we use, so install that first. If your operating
-    system's package system doesn't provide a binary version of GHC
-    and the `cabal-install` tool, you can install both using the
-    [Haskell Platform][platform].
-
-    It shouldn't be necessary to compile GHC from source -- every common
-    system has a pre-build binary version.  However, if you want to
-    build from source, the following links will be helpful:
-
-      - GHC: <http://haskell.org/ghc/>
-
-      - Cabal: <http://haskell.org/cabal/download.html>
-
-  * X11 libraries:
-
-    Since you're building an X application, you'll need the C X11
-    library headers. On many platforms, these come pre-installed. For
-    others, such as Debian, you can get them from your package manager:
-
-        $ apt-get install libx11-dev libxinerama-dev libxext-dev
-
-## Running xmonad
-
-Add:
-
-    exec $HOME/.cabal/bin/xmonad
-
-to the last line of your `.xsession` or `.xinitrc` file.
-
-## Configuring
-
-See the `CONFIG` document.
-
-## XMonadContrib
-
-There are many extensions to xmonad available in the XMonadContrib
-(xmc) library. Examples include an ion3-like tabbed layout, a
-prompt/program launcher, and various other useful modules.
-XMonadContrib is available at:
-
-  * Latest release: <http://hackage.haskell.org/package/xmonad-contrib>
-
-  * Git version: <https://github.com/xmonad/xmonad-contrib>
-
-## Other Useful Programs
-
-A nicer xterm replacement, that supports resizing better:
-
-  * urxvt: <http://software.schmorp.de/pkg/rxvt-unicode.html>
-
-For custom status bars:
-
-  * xmobar: <http://hackage.haskell.org/package/xmobar>
-
-  * taffybar: <https://github.com/travitch/taffybar>
-
-  * dzen: <http://gotmor.googlepages.com/dzen>
-
-For a program dispatch menu:
-
-  * [XMonad.Prompt.Shell][xmc-prompt-shell]: (from [XMonadContrib][])
-
-  * dmenu: <http://www.suckless.org/download/>
-
-  * gmrun: (in your package system)
-
-## Authors
-
-  * Spencer Janssen
-  * Don Stewart
-  * Jason Creighton
-
-[xmonad]: http://xmonad.org
-[xmonadcontrib]: https://hackage.haskell.org/package/xmonad-contrib
-[xmc-prompt-shell]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Prompt-Shell.html
-[platform]: http://haskell.org/platform/
diff --git a/source/STYLE b/source/STYLE
deleted file mode 100644
index e55d75d..0000000
--- a/source/STYLE
+++ /dev/null
@@ -1,22 +0,0 @@
-
-== Coding guidelines for contributing to
-== xmonad and the xmonad contributed extensions
-
-* Comment every top level function (particularly exported functions), and
-  provide a type signature; use Haddock syntax in the comments.
-
-* Follow the coding style of the other modules.
-
-* Code should be compilable with -Wall -Werror -fno-warn-unused-do-bind -fwarn-tabs.
-  There should be no warnings.
-
-* Partial functions should be avoided: the window manager should not
-  crash, so do not call `error` or `undefined`
-
-* Use 4 spaces for indenting.
-
-* Any pure function added to the core should have QuickCheck properties
-  precisely defining its behavior.
-
-* New modules should identify the author, and be submitted under
-  the same license as xmonad (BSD3 license or freer).
diff --git a/source/TODO b/source/TODO
deleted file mode 100644
index 1b3f644..0000000
--- a/source/TODO
+++ /dev/null
@@ -1,14 +0,0 @@
-= Release management =
-
-* generate, and push website haddocks with xmonad-web/gen-docs.sh
-* generate manpage, generate html manpage
-* double check README build instructions
-* bump xmonad.cabal version and X11 version
-* update cabal "tested-with:" fields
-* upload X11 and xmonad to Hackage
-* update #xmonad topic
-* check examples/text in user-facing Config.hs
-* check tour.html and intro.html are up to date, and mention all core bindings
-* confirm template config is type correct
-* update haskellwiki notable changes since x.x
-* email announce
diff --git a/source/xmonad.cabal b/simplified/lowarn-version-xmonad-v1213.cabal
similarity index 64%
rename from source/xmonad.cabal
rename to simplified/lowarn-version-xmonad-v1213.cabal
index 0de4277..2ebc88f 100644
--- a/source/xmonad.cabal
+++ b/simplified/lowarn-version-xmonad-v1213.cabal
@@ -1,4 +1,4 @@
-name:               xmonad
+name:               lowarn-version-xmonad-v1213
 version:            0.12
 homepage:           http://xmonad.org
 synopsis:           A tiling window manager
@@ -17,14 +17,7 @@ license:            BSD3
 license-file:       LICENSE
 author:             Spencer Janssen
 maintainer:         xmonad@haskell.org
-extra-source-files: README.md CHANGES.md TODO CONFIG STYLE
-                    tests/*.hs
-                    tests/Properties/*.hs
-                    tests/Properties/Layout/*.hs
-                    man/xmonad.1.markdown man/xmonad.1 man/xmonad.1.html
-                    util/GenerateManpage.hs
-                    util/hpcReport.sh
-cabal-version:      >= 1.8
+cabal-version:      >= 1.10
 bug-reports:        https://github.com/xmonad/xmonad/issues
 build-type:         Simple
 
@@ -34,8 +27,6 @@ tested-with:
                     GHC==7.10.3,
                     GHC==8.0.1
 
-data-files:         man/xmonad.hs, man/xmonad.1, man/xmonad.1.html
-
 source-repository head
   type:     git
   location: https://github.com/xmonad/xmonad
@@ -65,7 +56,7 @@ library
                         XMonad.ManageHook
                         XMonad.Operations
                         XMonad.StackSet
-    other-modules:      Paths_xmonad
+    other-modules:      Paths_lowarn_version_xmonad_v1213
 
     build-depends: base < 5 && >=3,
                    containers,
@@ -78,11 +69,14 @@ library
                    process,
                    unix,
                    utf8-string >= 0.3 && < 1.1,
-                   X11>=1.5 && < 1.7
+                   X11>=1.5 && < 1.11,
+                   semigroups
 
     if true
         ghc-options:        -funbox-strict-fields -Wall
 
+    default-language: Haskell2010
+
     if impl(ghc >= 6.12.1)
         ghc-options:        -fno-warn-unused-do-bind
     if impl(ghc < 7.0.0)
@@ -95,39 +89,5 @@ library
 
     if flag(testing)
         buildable: False
-
-executable xmonad
-    main-is:        Main.hs
-    build-depends:  base,
-                    mtl,
-                    unix,
-                    X11,
-                    xmonad
-    ghc-options:    -Wall
-    if impl(ghc >= 6.12.1)
-        ghc-options:  -Wall -fno-warn-unused-do-bind
-
-executable generatemanpage
-    main-is: GenerateManpage.hs
-    hs-source-dirs: util
-    if flag(generatemanpage)
-        build-depends: base,
-                       Cabal,
-                       pandoc,
-                       pretty,
-                       regex-posix
-    else
-        buildable: False
-
-
--- note util/hpcReport.sh
-test-suite properties
-    type: exitcode-stdio-1.0
-    hs-source-dirs: tests
-    build-depends:  base,
-                    containers,
-                    extensible-exceptions,
-                    QuickCheck >= 2,
-                    X11,
-                    xmonad
-    main-is: Properties.hs
+    if !impl(ghc > 8)
+        build-depends: fail
diff --git a/source/man/HCAR.tex b/source/man/HCAR.tex
deleted file mode 100644
index 68d6e6a..0000000
--- a/source/man/HCAR.tex
+++ /dev/null
@@ -1,71 +0,0 @@
-% xmonad-Gx.tex
-\begin{hcarentry}{xmonad}
-\label{xmonad}
-\report{Gwern Branwen}%11/11
-\status{active development}
-\makeheader
-
-XMonad is a tiling window manager for X. Windows are arranged
-automatically to tile the screen without gaps or overlap, maximizing
-screen use. Window manager features are accessible from the keyboard; a
-mouse is optional. XMonad is written, configured, and extensible in
-Haskell. Custom layout algorithms, key bindings, and other extensions may
-be written by the user in config files. Layouts are applied
-dynamically, and different layouts may be used on each workspace.
-Xinerama is fully supported, allowing windows to be tiled on several
-physical screens.
-
-Development since the last report has continued; XMonad founder Don Stewart
-has stepped down and Adam Vogt is the new maintainer.
-After gestating for 2 years, version 0.10 has been released, with simultaneous
-releases of the XMonadContrib library of customizations (which has now grown to
-no less than 216 modules encompassing a dizzying array of features) and the
-xmonad-extras package of extensions,
-
-Details of changes between releases can be found in the release notes:
-\begin{compactitem}
-\item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.8}
-\item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.9}
-% \item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.10}
-\item the Darcs repositories have been upgraded to the hashed format
-\item XMonad.Config.PlainConfig allows writing configs in a more 'normal' style, and not raw Haskell
-\item Supports using local modules in xmonad.hs; for example: to use definitions from \~/.xmonad/lib/XMonad/Stack/MyAdditions.hs
-\item xmonad --restart CLI option
-\item xmonad --replace CLI option
-\item XMonad.Prompt now has customizable keymaps
-\item Actions.GridSelect - a GUI menu for selecting windows or workspaces \& substring search on window names
-\item Actions.OnScreen
-\item Extensions now can have state
-\item Actions.SpawnOn - uses state to spawn applications on the workspace the user was originally on,
-  and not where the user happens to be
-\item Markdown manpages and not man/troff
-\item  XMonad.Layout.ImageButtonDecoration \&\\ XMonad.Util.Image
-\item XMonad.Layout.Groups
-\item XMonad.Layout.ZoomRow
-\item XMonad.Layout.Renamed
-\item XMonad.Layout.Drawer
-\item XMonad.Layout.FullScreen
-\item XMonad.Hooks.ScreenCorners
-\item XMonad.Actions.DynamicWorkspaceOrder
-\item XMonad.Actions.WorkspaceNames
-\item XMonad.Actions.DynamicWorkspaceGroups
-\end{compactitem}
-
-Binary packages of XMonad and XMonadContrib are available for all major Linux distributions.
-
-\FurtherReading
-\begin{compactitem}
-\item Homepage:
- \url{http://xmonad.org/}
-
-\item Git source:
-
- \texttt{git clone} \url{https://github.com/xmonad/xmonad.git}
-
-\item IRC channel:
- \verb+#xmonad @@ irc.freenode.org+
-
-\item Mailing list:
- \email{xmonad@@haskell.org}
-\end{compactitem}
-\end{hcarentry}
diff --git a/source/man/xmonad.1 b/source/man/xmonad.1
deleted file mode 100644
index a932b65..0000000
--- a/source/man/xmonad.1
+++ /dev/null
@@ -1,282 +0,0 @@
-.TH xmonad 1 "31 December 2012" xmonad-0.12 "xmonad manual".\" Automatically generated by Pandoc 1.15.1
-.\"
-.hy
-.TH "" "" "" "" ""
-.SH Name
-.PP
-xmonad \- a tiling window manager
-.SH Description
-.PP
-\f[I]xmonad\f[] is a minimalist tiling window manager for X, written in
-Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured.
-At any time windows are arranged so as to maximize the use of screen
-real estate.
-All features of the window manager are accessible purely from the
-keyboard: a mouse is entirely optional.
-\f[I]xmonad\f[] is configured in Haskell, and custom layout algorithms
-may be implemented by the user in config files.
-A principle of \f[I]xmonad\f[] is predictability: the user should know
-in advance precisely the window arrangement that will result from any
-action.
-.PP
-By default, \f[I]xmonad\f[] provides three layout algorithms: tall, wide
-and fullscreen.
-In tall or wide mode, windows are tiled and arranged to prevent overlap
-and maximize screen use.
-Sets of windows are grouped together on virtual screens, and each screen
-retains its own layout, which may be reconfigured dynamically.
-Multiple physical monitors are supported via Xinerama, allowing
-simultaneous display of a number of screens.
-.PP
-By utilizing the expressivity of a modern functional language with a
-rich static type system, \f[I]xmonad\f[] provides a complete, featureful
-window manager in less than 1200 lines of code, with an emphasis on
-correctness and robustness.
-Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type\-based automated testing.
-A benefit of this is that the code is simple to understand, and easy to
-modify.
-.SH Usage
-.PP
-\f[I]xmonad\f[] places each window into a "workspace".
-Each workspace can have any number of windows, which you can cycle
-though with mod\-j and mod\-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically.
-You can toggle the layout mode with mod\-space, which will cycle through
-the available modes.
-.PP
-You can switch to workspace N with mod\-N.
-For example, to switch to workspace 5, you would press mod\-5.
-Similarly, you can move the current window to another workspace with
-mod\-shift\-N.
-.PP
-When running with multiple monitors (Xinerama), each screen has exactly
-1 workspace visible.
-mod\-{w,e,r} switch the focus between screens, while shift\-mod\-{w,e,r}
-move the current window to that screen.
-When \f[I]xmonad\f[] starts, workspace 1 is on screen 1, workspace 2 is
-on screen 2, etc.
-When switching workspaces to one that is already visible, the current
-and visible workspaces are swapped.
-.SS Flags
-.PP
-xmonad has several flags which you may pass to the executable.
-These flags are:
-.TP
-.B \-\-recompile
-Recompiles your configuration in \f[I]~/.xmonad/xmonad.hs\f[]
-.RS
-.RE
-.TP
-.B \-\-restart
-Causes the currently running \f[I]xmonad\f[] process to restart
-.RS
-.RE
-.TP
-.B \-\-replace
-Replace the current window manager with xmonad
-.RS
-.RE
-.TP
-.B \-\-version
-Display version of \f[I]xmonad\f[]
-.RS
-.RE
-.TP
-.B \-\-verbose\-version
-Display detailed version of \f[I]xmonad\f[]
-.RS
-.RE
-.SS Default keyboard bindings
-.TP
-.B mod\-shift\-return
-Launch terminal
-.RS
-.RE
-.TP
-.B mod\-p
-Launch dmenu
-.RS
-.RE
-.TP
-.B mod\-shift\-p
-Launch gmrun
-.RS
-.RE
-.TP
-.B mod\-shift\-c
-Close the focused window
-.RS
-.RE
-.TP
-.B mod\-space
-Rotate through the available layout algorithms
-.RS
-.RE
-.TP
-.B mod\-shift\-space
-Reset the layouts on the current workspace to default
-.RS
-.RE
-.TP
-.B mod\-n
-Resize viewed windows to the correct size
-.RS
-.RE
-.TP
-.B mod\-tab
-Move focus to the next window
-.RS
-.RE
-.TP
-.B mod\-shift\-tab
-Move focus to the previous window
-.RS
-.RE
-.TP
-.B mod\-j
-Move focus to the next window
-.RS
-.RE
-.TP
-.B mod\-k
-Move focus to the previous window
-.RS
-.RE
-.TP
-.B mod\-m
-Move focus to the master window
-.RS
-.RE
-.TP
-.B mod\-return
-Swap the focused window and the master window
-.RS
-.RE
-.TP
-.B mod\-shift\-j
-Swap the focused window with the next window
-.RS
-.RE
-.TP
-.B mod\-shift\-k
-Swap the focused window with the previous window
-.RS
-.RE
-.TP
-.B mod\-h
-Shrink the master area
-.RS
-.RE
-.TP
-.B mod\-l
-Expand the master area
-.RS
-.RE
-.TP
-.B mod\-t
-Push window back into tiling
-.RS
-.RE
-.TP
-.B mod\-comma
-Increment the number of windows in the master area
-.RS
-.RE
-.TP
-.B mod\-period
-Deincrement the number of windows in the master area
-.RS
-.RE
-.TP
-.B mod\-shift\-q
-Quit xmonad
-.RS
-.RE
-.TP
-.B mod\-q
-Restart xmonad
-.RS
-.RE
-.TP
-.B mod\-shift\-slash
-Run xmessage with a summary of the default keybindings (useful for
-beginners)
-.RS
-.RE
-.TP
-.B mod\-[1..9]
-Switch to workspace N
-.RS
-.RE
-.TP
-.B mod\-shift\-[1..9]
-Move client to workspace N
-.RS
-.RE
-.TP
-.B mod\-{w,e,r}
-Switch to physical/Xinerama screens 1, 2, or 3
-.RS
-.RE
-.TP
-.B mod\-shift\-{w,e,r}
-Move client to screen 1, 2, or 3
-.RS
-.RE
-.TP
-.B mod\-button1
-Set the window to floating mode and move by dragging
-.RS
-.RE
-.TP
-.B mod\-button2
-Raise the window to the top of the stack
-.RS
-.RE
-.TP
-.B mod\-button3
-Set the window to floating mode and resize by dragging
-.RS
-.RE
-.SH Examples
-.PP
-To use xmonad as your window manager add to your \f[I]~/.xinitrc\f[]
-file:
-.RS
-.PP
-exec xmonad
-.RE
-.SH Customization
-.PP
-xmonad is customized in ~/.xmonad/xmonad.hs, and then restarted with
-mod\-q.
-.PP
-You can find many extensions to the core feature set in the xmonad\-
-contrib package, available through your package manager or from
-xmonad.org (http://xmonad.org).
-.SS Modular Configuration
-.PP
-As of \f[I]xmonad\-0.9\f[], any additional Haskell modules may be placed
-in \f[I]~/.xmonad/lib/\f[] are available in GHC\[aq]s searchpath.
-Hierarchical modules are supported: for example, the file
-\f[I]~/.xmonad/lib/XMonad/Stack/MyAdditions.hs\f[] could contain:
-.IP
-.nf
-\f[C]
-module\ XMonad.Stack.MyAdditions\ (function1)\ where
-\ \ function1\ =\ error\ "function1:\ Not\ implemented\ yet!"
-\f[]
-.fi
-.PP
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad\-contrib.
-.SH Bugs
-.PP
-Probably.
-If you find any, please report them to the
-bugtracker (https://github.com/xmonad/xmonad/issues)
diff --git a/source/man/xmonad.1.html b/source/man/xmonad.1.html
deleted file mode 100644
index 2beffdb..0000000
--- a/source/man/xmonad.1.html
+++ /dev/null
@@ -1,165 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-<head>
-  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
-  <meta http-equiv="Content-Style-Type" content="text/css" />
-  <meta name="generator" content="pandoc" />
-  <title></title>
-  <style type="text/css">code{white-space: pre;}</style>
-</head>
-<body>
-<h1>xmonad-0.12</h1><p>Section: xmonad manual (1)<br/>Updated: 31 December 2012</p><hr/>
-<div id="TOC">
-<ul>
-<li><a href="#name">Name</a></li>
-<li><a href="#description">Description</a></li>
-<li><a href="#usage">Usage</a><ul>
-<li><a href="#flags">Flags</a></li>
-<li><a href="#default-keyboard-bindings">Default keyboard bindings</a></li>
-</ul></li>
-<li><a href="#examples">Examples</a></li>
-<li><a href="#customization">Customization</a><ul>
-<li><a href="#modular-configuration">Modular Configuration</a></li>
-</ul></li>
-<li><a href="#bugs">Bugs</a></li>
-</ul>
-</div>
-<h1 id="name">Name</h1>
-<p>xmonad - a tiling window manager</p>
-<h1 id="description">Description</h1>
-<p><em>xmonad</em> is a minimalist tiling window manager for X, written in Haskell. Windows are managed using automatic layout algorithms, which can be dynamically reconfigured. At any time windows are arranged so as to maximize the use of screen real estate. All features of the window manager are accessible purely from the keyboard: a mouse is entirely optional. <em>xmonad</em> is configured in Haskell, and custom layout algorithms may be implemented by the user in config files. A principle of <em>xmonad</em> is predictability: the user should know in advance precisely the window arrangement that will result from any action.</p>
-<p>By default, <em>xmonad</em> provides three layout algorithms: tall, wide and fullscreen. In tall or wide mode, windows are tiled and arranged to prevent overlap and maximize screen use. Sets of windows are grouped together on virtual screens, and each screen retains its own layout, which may be reconfigured dynamically. Multiple physical monitors are supported via Xinerama, allowing simultaneous display of a number of screens.</p>
-<p>By utilizing the expressivity of a modern functional language with a rich static type system, <em>xmonad</em> provides a complete, featureful window manager in less than 1200 lines of code, with an emphasis on correctness and robustness. Internal properties of the window manager are checked using a combination of static guarantees provided by the type system, and type-based automated testing. A benefit of this is that the code is simple to understand, and easy to modify.</p>
-<h1 id="usage">Usage</h1>
-<p><em>xmonad</em> places each window into a &quot;workspace&quot;. Each workspace can have any number of windows, which you can cycle though with mod-j and mod-k. Windows are either displayed full screen, tiled horizontally, or tiled vertically. You can toggle the layout mode with mod-space, which will cycle through the available modes.</p>
-<p>You can switch to workspace N with mod-N. For example, to switch to workspace 5, you would press mod-5. Similarly, you can move the current window to another workspace with mod-shift-N.</p>
-<p>When running with multiple monitors (Xinerama), each screen has exactly 1 workspace visible. mod-{w,e,r} switch the focus between screens, while shift-mod-{w,e,r} move the current window to that screen. When <em>xmonad</em> starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When switching workspaces to one that is already visible, the current and visible workspaces are swapped.</p>
-<h2 id="flags">Flags</h2>
-<p>xmonad has several flags which you may pass to the executable. These flags are:</p>
-<dl>
-<dt>--recompile</dt>
-<dd>Recompiles your configuration in <em>~/.xmonad/xmonad.hs</em>
-</dd>
-<dt>--restart</dt>
-<dd>Causes the currently running <em>xmonad</em> process to restart
-</dd>
-<dt>--replace</dt>
-<dd>Replace the current window manager with xmonad
-</dd>
-<dt>--version</dt>
-<dd>Display version of <em>xmonad</em>
-</dd>
-<dt>--verbose-version</dt>
-<dd>Display detailed version of <em>xmonad</em>
-</dd>
-</dl>
-<h2 id="default-keyboard-bindings">Default keyboard bindings</h2>
-<dl>
-<dt>mod-shift-return</dt>
-<dd>Launch terminal
-</dd>
-<dt>mod-p</dt>
-<dd>Launch dmenu
-</dd>
-<dt>mod-shift-p</dt>
-<dd>Launch gmrun
-</dd>
-<dt>mod-shift-c</dt>
-<dd>Close the focused window
-</dd>
-<dt>mod-space</dt>
-<dd>Rotate through the available layout algorithms
-</dd>
-<dt>mod-shift-space</dt>
-<dd>Reset the layouts on the current workspace to default
-</dd>
-<dt>mod-n</dt>
-<dd>Resize viewed windows to the correct size
-</dd>
-<dt>mod-tab</dt>
-<dd>Move focus to the next window
-</dd>
-<dt>mod-shift-tab</dt>
-<dd>Move focus to the previous window
-</dd>
-<dt>mod-j</dt>
-<dd>Move focus to the next window
-</dd>
-<dt>mod-k</dt>
-<dd>Move focus to the previous window
-</dd>
-<dt>mod-m</dt>
-<dd>Move focus to the master window
-</dd>
-<dt>mod-return</dt>
-<dd>Swap the focused window and the master window
-</dd>
-<dt>mod-shift-j</dt>
-<dd>Swap the focused window with the next window
-</dd>
-<dt>mod-shift-k</dt>
-<dd>Swap the focused window with the previous window
-</dd>
-<dt>mod-h</dt>
-<dd>Shrink the master area
-</dd>
-<dt>mod-l</dt>
-<dd>Expand the master area
-</dd>
-<dt>mod-t</dt>
-<dd>Push window back into tiling
-</dd>
-<dt>mod-comma</dt>
-<dd>Increment the number of windows in the master area
-</dd>
-<dt>mod-period</dt>
-<dd>Deincrement the number of windows in the master area
-</dd>
-<dt>mod-shift-q</dt>
-<dd>Quit xmonad
-</dd>
-<dt>mod-q</dt>
-<dd>Restart xmonad
-</dd>
-<dt>mod-shift-slash</dt>
-<dd>Run xmessage with a summary of the default keybindings (useful for beginners)
-</dd>
-<dt>mod-[1..9]</dt>
-<dd>Switch to workspace N
-</dd>
-<dt>mod-shift-[1..9]</dt>
-<dd>Move client to workspace N
-</dd>
-<dt>mod-{w,e,r}</dt>
-<dd>Switch to physical/Xinerama screens 1, 2, or 3
-</dd>
-<dt>mod-shift-{w,e,r}</dt>
-<dd>Move client to screen 1, 2, or 3
-</dd>
-<dt>mod-button1</dt>
-<dd>Set the window to floating mode and move by dragging
-</dd>
-<dt>mod-button2</dt>
-<dd>Raise the window to the top of the stack
-</dd>
-<dt>mod-button3</dt>
-<dd>Set the window to floating mode and resize by dragging
-</dd>
-</dl>
-<h1 id="examples">Examples</h1>
-<p>To use xmonad as your window manager add to your <em>~/.xinitrc</em> file:</p>
-<blockquote>
-<p>exec xmonad</p>
-</blockquote>
-<h1 id="customization">Customization</h1>
-<p>xmonad is customized in ~/.xmonad/xmonad.hs, and then restarted with mod-q.</p>
-<p>You can find many extensions to the core feature set in the xmonad- contrib package, available through your package manager or from <a href="http://xmonad.org">xmonad.org</a>.</p>
-<h2 id="modular-configuration">Modular Configuration</h2>
-<p>As of <em>xmonad-0.9</em>, any additional Haskell modules may be placed in <em>~/.xmonad/lib/</em> are available in GHC's searchpath. Hierarchical modules are supported: for example, the file <em>~/.xmonad/lib/XMonad/Stack/MyAdditions.hs</em> could contain:</p>
-<pre class="haskell"><code>module XMonad.Stack.MyAdditions (function1) where
-  function1 = error &quot;function1: Not implemented yet!&quot;</code></pre>
-<p>Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that module was contained within xmonad or xmonad-contrib.</p>
-<h1 id="bugs">Bugs</h1>
-<p>Probably. If you find any, please report them to the <a href="https://github.com/xmonad/xmonad/issues">bugtracker</a></p>
-</body>
-</html>
diff --git a/source/man/xmonad.1.markdown b/source/man/xmonad.1.markdown
deleted file mode 100644
index 22564ab..0000000
--- a/source/man/xmonad.1.markdown
+++ /dev/null
@@ -1,104 +0,0 @@
-#Name
-xmonad - a tiling window manager
-
-#Description
-
-_xmonad_ is a minimalist tiling window manager for X, written in Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured. At any time windows are arranged so as to
-maximize the use of screen real estate. All features of the window manager
-are accessible purely from the keyboard: a mouse is entirely optional.
-_xmonad_ is configured in Haskell, and custom layout algorithms may be
-implemented by the user in config files. A principle of _xmonad_ is
-predictability: the user should know in advance precisely the window
-arrangement that will result from any action.
-
-By default, _xmonad_ provides three layout algorithms: tall, wide and
-fullscreen. In tall or wide mode, windows are tiled and arranged to prevent
-overlap and maximize screen use. Sets of windows are grouped together on
-virtual screens, and each screen retains its own layout, which may be
-reconfigured dynamically. Multiple physical monitors are supported via
-Xinerama, allowing simultaneous display of a number of screens.
-
-By utilizing the expressivity of a modern functional language with a rich
-static type system, _xmonad_ provides a complete, featureful window manager
-in less than 1200 lines of code, with an emphasis on correctness and
-robustness. Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type-based automated testing. A benefit of this is that the code is simple
-to understand, and easy to modify.
-
-#Usage
-
-_xmonad_ places each window into a "workspace". Each workspace can have
-any number of windows, which you can cycle though with mod-j and mod-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically. You can toggle the layout mode with mod-space, which will cycle
-through the available modes.
-
-You can switch to workspace N with mod-N. For example, to switch to
-workspace 5, you would press mod-5. Similarly, you can move the current
-window to another workspace with mod-shift-N.
-
-When running with multiple monitors (Xinerama), each screen has exactly 1
-workspace visible. mod-{w,e,r} switch the focus between screens, while
-shift-mod-{w,e,r} move the current window to that screen. When _xmonad_
-starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When
-switching workspaces to one that is already visible, the current and
-visible workspaces are swapped.
-
-##Flags
-xmonad  has  several flags which  you may pass to the executable.
-These flags are:
-
---recompile
-:   Recompiles your configuration in _~/.xmonad/xmonad.hs_
-
---restart
-:   Causes the currently running _xmonad_ process to restart
-
---replace
-:   Replace the current window manager with xmonad
-
---version
-:   Display version of _xmonad_
-
---verbose-version
-:   Display detailed version of _xmonad_
-
-##Default keyboard bindings
-
-___KEYBINDINGS___
-
-#Examples
-To use xmonad as your window manager add to your _~/.xinitrc_ file:
-
-> exec xmonad
-
-#Customization
-xmonad is customized in ~/.xmonad/xmonad.hs, and then restarted
-with mod-q.
-
-You can find many extensions to the core feature set in the xmonad-
-contrib package, available through your  package  manager  or  from
-[xmonad.org].
-
-##Modular Configuration
-As of _xmonad-0.9_, any additional Haskell modules may be placed in
-_~/.xmonad/lib/_ are available in GHC's searchpath. Hierarchical modules
-are supported: for example, the file
-_~/.xmonad/lib/XMonad/Stack/MyAdditions.hs_ could contain:
-
-```haskell
-module XMonad.Stack.MyAdditions (function1) where
-  function1 = error "function1: Not implemented yet!"
-```
-
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad-contrib.
-
-#Bugs
-Probably. If you find any, please report them to the [bugtracker]
-
-[xmonad.org]: http://xmonad.org
-[bugtracker]: https://github.com/xmonad/xmonad/issues
diff --git a/source/man/xmonad.hs b/source/man/xmonad.hs
deleted file mode 100644
index baf5189..0000000
--- a/source/man/xmonad.hs
+++ /dev/null
@@ -1,333 +0,0 @@
---
--- xmonad example config file.
---
--- A template showing all available configuration hooks,
--- and how to override the defaults in your own xmonad.hs conf file.
---
--- Normally, you'd only override those defaults you care about.
---
-
-import XMonad
-import Data.Monoid
-import System.Exit
-
-import qualified XMonad.StackSet as W
-import qualified Data.Map        as M
-
--- The preferred terminal program, which is used in a binding below and by
--- certain contrib modules.
---
-myTerminal      = "xterm"
-
--- Whether focus follows the mouse pointer.
-myFocusFollowsMouse :: Bool
-myFocusFollowsMouse = True
-
--- Whether clicking on a window to focus also passes the click to the window
-myClickJustFocuses :: Bool
-myClickJustFocuses = False
-
--- Width of the window border in pixels.
---
-myBorderWidth   = 1
-
--- modMask lets you specify which modkey you want to use. The default
--- is mod1Mask ("left alt").  You may also consider using mod3Mask
--- ("right alt"), which does not conflict with emacs keybindings. The
--- "windows key" is usually mod4Mask.
---
-myModMask       = mod1Mask
-
--- The default number of workspaces (virtual screens) and their names.
--- By default we use numeric strings, but any string may be used as a
--- workspace name. The number of workspaces is determined by the length
--- of this list.
---
--- A tagging example:
---
--- > workspaces = ["web", "irc", "code" ] ++ map show [4..9]
---
-myWorkspaces    = ["1","2","3","4","5","6","7","8","9"]
-
--- Border colors for unfocused and focused windows, respectively.
---
-myNormalBorderColor  = "#dddddd"
-myFocusedBorderColor = "#ff0000"
-
-------------------------------------------------------------------------
--- Key bindings. Add, modify or remove key bindings here.
---
-myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $
-
-    -- launch a terminal
-    [ ((modm .|. shiftMask, xK_Return), spawn $ XMonad.terminal conf)
-
-    -- launch dmenu
-    , ((modm,               xK_p     ), spawn "dmenu_run")
-
-    -- launch gmrun
-    , ((modm .|. shiftMask, xK_p     ), spawn "gmrun")
-
-    -- close focused window
-    , ((modm .|. shiftMask, xK_c     ), kill)
-
-     -- Rotate through the available layout algorithms
-    , ((modm,               xK_space ), sendMessage NextLayout)
-
-    --  Reset the layouts on the current workspace to default
-    , ((modm .|. shiftMask, xK_space ), setLayout $ XMonad.layoutHook conf)
-
-    -- Resize viewed windows to the correct size
-    , ((modm,               xK_n     ), refresh)
-
-    -- Move focus to the next window
-    , ((modm,               xK_Tab   ), windows W.focusDown)
-
-    -- Move focus to the next window
-    , ((modm,               xK_j     ), windows W.focusDown)
-
-    -- Move focus to the previous window
-    , ((modm,               xK_k     ), windows W.focusUp  )
-
-    -- Move focus to the master window
-    , ((modm,               xK_m     ), windows W.focusMaster  )
-
-    -- Swap the focused window and the master window
-    , ((modm,               xK_Return), windows W.swapMaster)
-
-    -- Swap the focused window with the next window
-    , ((modm .|. shiftMask, xK_j     ), windows W.swapDown  )
-
-    -- Swap the focused window with the previous window
-    , ((modm .|. shiftMask, xK_k     ), windows W.swapUp    )
-
-    -- Shrink the master area
-    , ((modm,               xK_h     ), sendMessage Shrink)
-
-    -- Expand the master area
-    , ((modm,               xK_l     ), sendMessage Expand)
-
-    -- Push window back into tiling
-    , ((modm,               xK_t     ), withFocused $ windows . W.sink)
-
-    -- Increment the number of windows in the master area
-    , ((modm              , xK_comma ), sendMessage (IncMasterN 1))
-
-    -- Deincrement the number of windows in the master area
-    , ((modm              , xK_period), sendMessage (IncMasterN (-1)))
-
-    -- Toggle the status bar gap
-    -- Use this binding with avoidStruts from Hooks.ManageDocks.
-    -- See also the statusBar function from Hooks.DynamicLog.
-    --
-    -- , ((modm              , xK_b     ), sendMessage ToggleStruts)
-
-    -- Quit xmonad
-    , ((modm .|. shiftMask, xK_q     ), io (exitWith ExitSuccess))
-
-    -- Restart xmonad
-    , ((modm              , xK_q     ), spawn "xmonad --recompile; xmonad --restart")
-
-    -- Run xmessage with a summary of the default keybindings (useful for beginners)
-    , ((modm .|. shiftMask, xK_slash ), spawn ("echo \"" ++ help ++ "\" | xmessage -file -"))
-    ]
-    ++
-
-    --
-    -- mod-[1..9], Switch to workspace N
-    -- mod-shift-[1..9], Move client to workspace N
-    --
-    [((m .|. modm, k), windows $ f i)
-        | (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9]
-        , (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]]
-    ++
-
-    --
-    -- mod-{w,e,r}, Switch to physical/Xinerama screens 1, 2, or 3
-    -- mod-shift-{w,e,r}, Move client to screen 1, 2, or 3
-    --
-    [((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
-        | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
-        , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
-
-
-------------------------------------------------------------------------
--- Mouse bindings: default actions bound to mouse events
---
-myMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $
-
-    -- mod-button1, Set the window to floating mode and move by dragging
-    [ ((modm, button1), (\w -> focus w >> mouseMoveWindow w
-                                       >> windows W.shiftMaster))
-
-    -- mod-button2, Raise the window to the top of the stack
-    , ((modm, button2), (\w -> focus w >> windows W.shiftMaster))
-
-    -- mod-button3, Set the window to floating mode and resize by dragging
-    , ((modm, button3), (\w -> focus w >> mouseResizeWindow w
-                                       >> windows W.shiftMaster))
-
-    -- you may also bind events to the mouse scroll wheel (button4 and button5)
-    ]
-
-------------------------------------------------------------------------
--- Layouts:
-
--- You can specify and transform your layouts by modifying these values.
--- If you change layout bindings be sure to use 'mod-shift-space' after
--- restarting (with 'mod-q') to reset your layout state to the new
--- defaults, as xmonad preserves your old layout settings by default.
---
--- The available layouts.  Note that each layout is separated by |||,
--- which denotes layout choice.
---
-myLayout = tiled ||| Mirror tiled ||| Full
-  where
-     -- default tiling algorithm partitions the screen into two panes
-     tiled   = Tall nmaster delta ratio
-
-     -- The default number of windows in the master pane
-     nmaster = 1
-
-     -- Default proportion of screen occupied by master pane
-     ratio   = 1/2
-
-     -- Percent of screen to increment by when resizing panes
-     delta   = 3/100
-
-------------------------------------------------------------------------
--- Window rules:
-
--- Execute arbitrary actions and WindowSet manipulations when managing
--- a new window. You can use this to, for example, always float a
--- particular program, or have a client always appear on a particular
--- workspace.
---
--- To find the property name associated with a program, use
--- > xprop | grep WM_CLASS
--- and click on the client you're interested in.
---
--- To match on the WM_NAME, you can use 'title' in the same way that
--- 'className' and 'resource' are used below.
---
-myManageHook = composeAll
-    [ className =? "MPlayer"        --> doFloat
-    , className =? "Gimp"           --> doFloat
-    , resource  =? "desktop_window" --> doIgnore
-    , resource  =? "kdesktop"       --> doIgnore ]
-
-------------------------------------------------------------------------
--- Event handling
-
--- * EwmhDesktops users should change this to ewmhDesktopsEventHook
---
--- Defines a custom handler function for X Events. The function should
--- return (All True) if the default handler is to be run afterwards. To
--- combine event hooks use mappend or mconcat from Data.Monoid.
---
-myEventHook = mempty
-
-------------------------------------------------------------------------
--- Status bars and logging
-
--- Perform an arbitrary action on each internal state change or X event.
--- See the 'XMonad.Hooks.DynamicLog' extension for examples.
---
-myLogHook = return ()
-
-------------------------------------------------------------------------
--- Startup hook
-
--- Perform an arbitrary action each time xmonad starts or is restarted
--- with mod-q.  Used by, e.g., XMonad.Layout.PerWorkspace to initialize
--- per-workspace layout choices.
---
--- By default, do nothing.
-myStartupHook = return ()
-
-------------------------------------------------------------------------
--- Now run xmonad with all the defaults we set up.
-
--- Run xmonad with the settings you specify. No need to modify this.
---
-main = xmonad defaults
-
--- A structure containing your configuration settings, overriding
--- fields in the default config. Any you don't override, will
--- use the defaults defined in xmonad/XMonad/Config.hs
---
--- No need to modify this.
---
-defaults = def {
-      -- simple stuff
-        terminal           = myTerminal,
-        focusFollowsMouse  = myFocusFollowsMouse,
-        clickJustFocuses   = myClickJustFocuses,
-        borderWidth        = myBorderWidth,
-        modMask            = myModMask,
-        workspaces         = myWorkspaces,
-        normalBorderColor  = myNormalBorderColor,
-        focusedBorderColor = myFocusedBorderColor,
-
-      -- key bindings
-        keys               = myKeys,
-        mouseBindings      = myMouseBindings,
-
-      -- hooks, layouts
-        layoutHook         = myLayout,
-        manageHook         = myManageHook,
-        handleEventHook    = myEventHook,
-        logHook            = myLogHook,
-        startupHook        = myStartupHook
-    }
-
--- | Finally, a copy of the default bindings in simple textual tabular format.
-help :: String
-help = unlines ["The default modifier key is 'alt'. Default keybindings:",
-    "",
-    "-- launching and killing programs",
-    "mod-Shift-Enter  Launch xterminal",
-    "mod-p            Launch dmenu",
-    "mod-Shift-p      Launch gmrun",
-    "mod-Shift-c      Close/kill the focused window",
-    "mod-Space        Rotate through the available layout algorithms",
-    "mod-Shift-Space  Reset the layouts on the current workSpace to default",
-    "mod-n            Resize/refresh viewed windows to the correct size",
-    "",
-    "-- move focus up or down the window stack",
-    "mod-Tab        Move focus to the next window",
-    "mod-Shift-Tab  Move focus to the previous window",
-    "mod-j          Move focus to the next window",
-    "mod-k          Move focus to the previous window",
-    "mod-m          Move focus to the master window",
-    "",
-    "-- modifying the window order",
-    "mod-Return   Swap the focused window and the master window",
-    "mod-Shift-j  Swap the focused window with the next window",
-    "mod-Shift-k  Swap the focused window with the previous window",
-    "",
-    "-- resizing the master/slave ratio",
-    "mod-h  Shrink the master area",
-    "mod-l  Expand the master area",
-    "",
-    "-- floating layer support",
-    "mod-t  Push window back into tiling; unfloat and re-tile it",
-    "",
-    "-- increase or decrease number of windows in the master area",
-    "mod-comma  (mod-,)   Increment the number of windows in the master area",
-    "mod-period (mod-.)   Deincrement the number of windows in the master area",
-    "",
-    "-- quit, or restart",
-    "mod-Shift-q  Quit xmonad",
-    "mod-q        Restart xmonad",
-    "mod-[1..9]   Switch to workSpace N",
-    "",
-    "-- Workspaces & screens",
-    "mod-Shift-[1..9]   Move client to workspace N",
-    "mod-{w,e,r}        Switch to physical/Xinerama screens 1, 2, or 3",
-    "mod-Shift-{w,e,r}  Move client to screen 1, 2, or 3",
-    "",
-    "-- Mouse bindings: default actions bound to mouse events",
-    "mod-button1  Set the window to floating mode and move by dragging",
-    "mod-button2  Raise the window to the top of the stack",
-    "mod-button3  Set the window to floating mode and resize by dragging"]
diff --git a/source/src/XMonad/Core.hs b/simplified/src/XMonad/Core.hs
index a6387fd..400248c 100644
--- a/source/src/XMonad/Core.hs
+++ b/simplified/src/XMonad/Core.hs
@@ -35,8 +35,10 @@ import Prelude
 import Control.Exception.Extensible (fromException, try, bracket, throw, finally, SomeException(..))
 import qualified Control.Exception.Extensible as E
 import Control.Applicative
+import Control.Monad.Fail
 import Control.Monad.State
 import Control.Monad.Reader
+import Data.Semigroup
 import Data.Default
 import System.FilePath
 import System.IO
@@ -53,7 +55,7 @@ import Graphics.X11.Xlib.Extras (Event)
 import Data.Typeable
 import Data.List ((\\))
 import Data.Maybe (isJust,fromMaybe)
-import Data.Monoid
+import Data.Monoid hiding ((<>))
 
 import qualified Data.Map as M
 import qualified Data.Set as S
@@ -142,12 +144,15 @@ data ScreenDetail   = SD { screenRect :: !Rectangle } deriving (Eq,Show, Read)
 -- instantiated on 'XConf' and 'XState' automatically.
 --
 newtype X a = X (ReaderT XConf (StateT XState IO) a)
-    deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf, Typeable)
+    deriving (Functor, Monad, MonadFail, MonadIO, MonadState XState, MonadReader XConf, Typeable)
 
 instance Applicative X where
   pure = return
   (<*>) = ap
 
+instance Semigroup a => Semigroup (X a) where
+    (<>) = liftM2 (<>)
+
 instance (Monoid a) => Monoid (X a) where
     mempty  = return mempty
     mappend = liftM2 mappend
@@ -162,6 +167,9 @@ newtype Query a = Query (ReaderT Window X a)
 runQuery :: Query a -> Window -> X a
 runQuery (Query m) w = runReaderT m w
 
+instance Semigroup a => Semigroup (Query a) where
+    (<>) = liftM2 (<>)
+
 instance Monoid a => Monoid (Query a) where
     mempty  = return mempty
     mappend = liftM2 mappend
diff --git a/source/src/XMonad/Main.hs b/simplified/src/XMonad/Main.hs
index 3da7bb4..d079b27 100644
--- a/source/src/XMonad/Main.hs
+++ b/simplified/src/XMonad/Main.hs
@@ -44,7 +44,7 @@ import System.Posix.Process (executeFile)
 import System.Exit (exitFailure)
 import System.FilePath
 
-import Paths_xmonad (version)
+import Paths_lowarn_version_xmonad_v1213 (version)
 import Data.Version (showVersion)
 
 import Graphics.X11.Xinerama (compiledWithXinerama)
@@ -61,7 +61,7 @@ xmonad conf = do
 
     let launch serializedWinset serializedExtState args = do
               catchIO buildLaunch
-              conf' @ XConfig { layoutHook = Layout l }
+              conf'@XConfig { layoutHook = Layout l }
                   <- handleExtraArgs conf args conf{ layoutHook = Layout (layoutHook conf) }
               withArgs [] $
                 xmonadNoargs (conf' { layoutHook = l })
diff --git a/source/tests/Instances.hs b/source/tests/Instances.hs
deleted file mode 100644
index e52c5ec..0000000
--- a/source/tests/Instances.hs
+++ /dev/null
@@ -1,140 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Instances where
-
-import Test.QuickCheck
-
-import Utils
-
-import XMonad.StackSet
-import Control.Monad
-import Data.List (nub, genericLength)
-
-import Debug.Trace
-
-import Graphics.X11 (Rectangle(Rectangle))
-import Control.Applicative
-
---
--- The all important Arbitrary instance for StackSet.
---
-instance (Integral i, Integral s, Eq a, Arbitrary a, Arbitrary l, Arbitrary sd)
-         => Arbitrary (StackSet i l a s sd) where
-  arbitrary = do
-      -- TODO: Fix this to be a reasonable higher number, Possibly use PositiveSized
-      numWs        <- choose (1, 20)    -- number of workspaces, there must be at least 1.
-      numScreens   <- choose (1, numWs) -- number of physical screens, there must be at least 1
-      lay <- arbitrary                  -- pick any layout
-
-      wsIdxInFocus <- choose (1, numWs) -- pick index of WS to be in focus
-
-      -- The same screen id's will be present in the list, with high possibility.
-      screens  <- replicateM numScreens arbitrary
-
-      -- Generate a list of "windows" for each workspace.
-      wsWindows  <- vector numWs :: Gen [[a]]
-
-      -- Pick a random window "number" in each workspace, to give focus.
-      focus <- sequence [ if null windows
-                          then return Nothing
-                          else liftM Just $ choose (0, length windows - 1)
-                        | windows <- wsWindows ]
-
-      let tags = [1 .. fromIntegral numWs]
-          focusWsWindows = zip focus wsWindows
-          wss = zip tags focusWsWindows -- tmp representation of a workspace (tag, windows)
-          initSs = new lay tags screens
-      return $
-        view (fromIntegral wsIdxInFocus) $
-        foldr (\(tag, (focus, windows)) ss -> -- Fold through all generated (tags,windows).
-                -- set workspace active by tag and fold through all
-                -- windows while inserting them.  Apply the given number
-                -- of `focusUp` on the resulting StackSet.
-                applyN focus focusUp $ foldr insertUp (view tag ss) windows
-              ) initSs wss
-
-
---
--- Just generate StackSets with Char elements.
---
-type Tag = Int
-type Window = Char
-type T = StackSet Tag Int Window Int Int
-
-
-
-newtype EmptyStackSet = EmptyStackSet T
-    deriving Show
-
-instance Arbitrary EmptyStackSet where
-    arbitrary = do
-        (NonEmptyNubList ns)  <- arbitrary
-        (NonEmptyNubList sds) <- arbitrary
-        l <- arbitrary
-        -- there cannot be more screens than workspaces:
-        return . EmptyStackSet . new l ns $ take (min (length ns) (length sds)) sds
-
-
-
-newtype NonEmptyWindowsStackSet = NonEmptyWindowsStackSet T
-    deriving Show
-
-instance Arbitrary NonEmptyWindowsStackSet where
-  arbitrary =
-    NonEmptyWindowsStackSet `fmap` (arbitrary `suchThat` (not . null . allWindows))
-
-instance Arbitrary Rectangle where
-    arbitrary = Rectangle <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary
-
-
-newtype SizedPositive = SizedPositive Int
-    deriving (Eq, Ord, Show, Read)
-
-instance Arbitrary SizedPositive where
-  arbitrary = sized $ \s -> do x <- choose (1, max 1 s)
-                               return $ SizedPositive x
-
-
-
-newtype NonEmptyNubList a = NonEmptyNubList [a]
-    deriving ( Eq, Ord, Show, Read )
-
-instance (Eq a, Arbitrary a) => Arbitrary (NonEmptyNubList a) where
-  arbitrary   = NonEmptyNubList `fmap` ((liftM nub arbitrary) `suchThat` (not . null))
-
-
-
--- | Pull out an arbitrary tag from the StackSet. This removes the need for the
--- precondition "n `tagMember x` in many properties and thus reduces the number
--- of discarded tests.
---
---  n <- arbitraryTag x
---
--- We can do the reverse with a simple `suchThat`:
---
--- n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-arbitraryTag :: T -> Gen Tag
-arbitraryTag x = do
-  let ts = tags x
-  -- There must be at least 1 workspace, thus at least 1 tag.
-  idx <- choose (0, (length ts) - 1)
-  return $ ts!!idx
-
--- | Pull out an arbitrary window from a StackSet that is guaranteed to have a
--- non empty set of windows. This eliminates the precondition "i `member` x" in
--- a few properties.
---
---
--- foo (nex :: NonEmptyWindowsStackSet) = do
---   let NonEmptyWindowsStackSet x = nex
---   w <- arbitraryWindow nex
---   return $ .......
---
--- We can do the reverse with a simple `suchThat`:
---
---   n <- arbitrary `suchThat` \n' -> not $ n `member` x
-arbitraryWindow :: NonEmptyWindowsStackSet -> Gen Window
-arbitraryWindow (NonEmptyWindowsStackSet x) = do
-  let ws = allWindows x
-  -- We know that there are at least 1 window in a NonEmptyWindowsStackSet.
-  idx <- choose(0, (length ws) - 1)
-  return $ ws!!idx
diff --git a/source/tests/Properties/Delete.hs b/source/tests/Properties/Delete.hs
deleted file mode 100644
index 6fb7566..0000000
--- a/source/tests/Properties/Delete.hs
+++ /dev/null
@@ -1,70 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Delete where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
--- ---------------------------------------------------------------------
--- 'delete'
-
--- deleting the current item removes it.
-prop_delete x =
-    case peek x of
-        Nothing -> True
-        Just i  -> not (member i (delete i x))
-    where _ = x :: T
-
--- delete is reversible with 'insert'.
--- It is the identiy, except for the 'master', which is reset on insert and delete.
---
-prop_delete_insert (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just n  -> insertUp n (delete n y) == y
-    where
-        y = swapMaster x
-
--- delete should be local
-prop_delete_local (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just i  -> hidden_spaces x == hidden_spaces (delete i x)
-
--- delete should not affect focus unless the focused element is what is being deleted
-prop_delete_focus = do
-  -- There should be at least two windows. One in focus, and some to try and
-  -- delete (doesn't have to be windows on the current workspace).  We generate
-  -- our own, since we can't rely on NonEmptyWindowsStackSet returning one in
-  -- the argument with at least two windows.
-  x <- arbitrary `suchThat` \x' -> length (allWindows x') >= 2
-  w <- arbitraryWindow (NonEmptyWindowsStackSet x)
-       -- Make sure we pick a window that is NOT the currently focused
-       `suchThat` \w' -> Just w' /= peek x
-  return $ peek (delete w x) == peek x
-
--- focus movement in the presence of delete:
--- when the last window in the stack set is focused, focus moves `up'.
--- usual case is that it moves 'down'.
-prop_delete_focus_end = do
-    -- Generate a StackSet with at least two windows on the current workspace.
-    x <- arbitrary `suchThat` \(x' :: T) -> length (index x') >= 2
-    let w = last (index x)
-        y = focusWindow w x -- focus last window in stack
-    return $ peek (delete w y) == peek (focusUp y)
-
-
--- focus movement in the presence of delete:
--- when not in the last item in the stack, focus moves down
-prop_delete_focus_not_end = do
-  x <- arbitrary
-       -- There must be at least two windows and the current focused is not the
-       -- last one in the stack.
-       `suchThat` \(x' :: T) ->
-         let currWins = index x'
-         in length (currWins) >= 2 && peek x' /= Just (last currWins)
-  -- This is safe, as we know there are >= 2 windows
-  let Just n = peek x
-  return $ peek (delete n x) == peek (focusDown x)
diff --git a/source/tests/Properties/Failure.hs b/source/tests/Properties/Failure.hs
deleted file mode 100644
index a46d723..0000000
--- a/source/tests/Properties/Failure.hs
+++ /dev/null
@@ -1,30 +0,0 @@
-module Properties.Failure where
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Control.Exception.Extensible as C
-import System.IO.Unsafe
-import Data.List (isPrefixOf)
-
--- ---------------------------------------------------------------------
--- testing for failure and help out hpc
---
--- Since base 4.9.0.0 `error` appends a stack trace. The tests below
--- use `isPrefixOf` to only test equality on the error message.
---
-prop_abort :: Int -> Bool
-prop_abort _ = unsafePerformIO $ C.catch (abort "fail") check
-   where
-     check (C.SomeException e) =
-       return $ "xmonad: StackSet: fail" `isPrefixOf` show e
-
--- new should fail with an abort
-prop_new_abort :: Int -> Bool
-prop_new_abort _ = unsafePerformIO $ C.catch f check
-   where
-     f = new undefined{-layout-} [] [] `seq` return False
-     check (C.SomeException e) =
-       return $ "xmonad: StackSet: non-positive argument to StackSet.new" `isPrefixOf` show e
-
--- TODO: Fix this?
--- prop_view_should_fail = view {- with some bogus data -}
diff --git a/source/tests/Properties/Floating.hs b/source/tests/Properties/Floating.hs
deleted file mode 100644
index a9afad7..0000000
--- a/source/tests/Properties/Floating.hs
+++ /dev/null
@@ -1,36 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Floating where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Data.Map as M
-
-------------------------------------------------------------------------
--- properties for the floating layer:
-
-prop_float_reversible (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  return $ sink w (float w geom x) == x
-        where
-            geom = RationalRect 100 100 100 100
-
-prop_float_geometry (nex :: NonEmptyWindowsStackSet) = do
-    let NonEmptyWindowsStackSet x = nex
-    w <- arbitraryWindow nex
-    let s = float w geom x
-    return $ M.lookup w (floating s) == Just geom
-  where
-    geom = RationalRect 100 100 100 100
-
-prop_float_delete (nex :: NonEmptyWindowsStackSet) = do
-    let NonEmptyWindowsStackSet x = nex
-    w <- arbitraryWindow nex
-    let s = float w geom x
-        t = delete w s
-    return $ not (w `member` t)
-  where
-    geom = RationalRect 100 100 100 100
diff --git a/source/tests/Properties/Focus.hs b/source/tests/Properties/Focus.hs
deleted file mode 100644
index 6bc0055..0000000
--- a/source/tests/Properties/Focus.hs
+++ /dev/null
@@ -1,74 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Focus where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe (fromJust)
-
--- ---------------------------------------------------------------------
--- rotating focus
---
-
--- master/focus
---
--- The tiling order, and master window, of a stack is unaffected by focus changes.
---
-prop_focus_left_master (SizedPositive n) (x::T) =
-    index (applyN (Just n) focusUp x) == index x
-prop_focus_right_master (SizedPositive  n) (x::T) =
-    index (applyN (Just n) focusDown x) == index x
-prop_focus_master_master (SizedPositive n) (x::T) =
-    index (applyN (Just n) focusMaster x) == index x
-
-prop_focusWindow_master (NonNegative n) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = n `mod` length s
-                   in index (focusWindow (s !! i) x) == index x
-
--- shifting focus is trivially reversible
-prop_focus_left  (x :: T) = (focusUp  (focusDown x)) == x
-prop_focus_right (x :: T) = (focusDown (focusUp  x)) ==  x
-
--- focus master is idempotent
-prop_focusMaster_idem (x :: T) = focusMaster x == focusMaster (focusMaster x)
-
--- focusWindow actually leaves the window focused...
-prop_focusWindow_works (NonNegative (n :: Int)) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = fromIntegral n `mod` length s
-                   in (focus . fromJust . stack . workspace . current) (focusWindow (s !! i) x) == (s !! i)
-
--- rotation through the height of a stack gets us back to the start
-prop_focus_all_l (x :: T) = (foldr (const focusUp) x [1..n]) == x
-  where n = length (index x)
-prop_focus_all_r (x :: T) = (foldr (const focusDown) x [1..n]) == x
-  where n = length (index x)
-
--- prop_rotate_all (x :: T) = f (f x) == f x
---     f x' = foldr (\_ y -> rotate GT y) x' [1..n]
-
--- focus is local to the current workspace
-prop_focus_down_local (x :: T) = hidden_spaces (focusDown x) == hidden_spaces x
-prop_focus_up_local (x :: T) = hidden_spaces (focusUp x) == hidden_spaces x
-
-prop_focus_master_local (x :: T) = hidden_spaces (focusMaster x) == hidden_spaces x
-
-prop_focusWindow_local (NonNegative (n :: Int)) (x::T ) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = fromIntegral n `mod` length s
-                   in hidden_spaces (focusWindow (s !! i) x) == hidden_spaces x
-
--- On an invalid window, the stackset is unmodified
-prop_focusWindow_identity (x::T ) = do
-    n <- arbitrary `suchThat` \n' -> not $ n' `member` x
-    return $ focusWindow n x == x
diff --git a/source/tests/Properties/GreedyView.hs b/source/tests/Properties/GreedyView.hs
deleted file mode 100644
index 3f2eb9b..0000000
--- a/source/tests/Properties/GreedyView.hs
+++ /dev/null
@@ -1,44 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.GreedyView where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (sortBy)
-
--- ---------------------------------------------------------------------
--- greedyViewing workspaces
-
--- greedyView sets the current workspace to 'n'
-prop_greedyView_current (x :: T)  = do
-    n <- arbitraryTag x
-    return $ currentTag (greedyView n x) == n
-
--- greedyView leaves things unchanged for invalid workspaces
-prop_greedyView_current_id (x :: T) = do
-  n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-  return $ currentTag (greedyView n x) == currentTag x
-
--- greedyView *only* sets the current workspace, and touches Xinerama.
--- no workspace contents will be changed.
-prop_greedyView_local  (x :: T) = do
-    n <- arbitraryTag x
-    return $ workspaces x == workspaces (greedyView n x)
-  where
-    workspaces a = sortBy (\s t -> tag s `compare` tag t) $
-                                    workspace (current a)
-                                    : map workspace (visible a) ++ hidden a
-
--- greedyView is idempotent
-prop_greedyView_idem (x :: T) = do
-  n <- arbitraryTag x
-  return $ greedyView n (greedyView n x) == (greedyView n x)
-
--- greedyView is reversible, though shuffles the order of hidden/visible
-prop_greedyView_reversible (x :: T) = do
-    n <- arbitraryTag x
-    return $ normal (greedyView n' (greedyView n x)) == normal x
-    where n'  = currentTag x
diff --git a/source/tests/Properties/Insert.hs b/source/tests/Properties/Insert.hs
deleted file mode 100644
index c277795..0000000
--- a/source/tests/Properties/Insert.hs
+++ /dev/null
@@ -1,52 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Insert where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (nub)
-
--- ---------------------------------------------------------------------
--- 'insert'
-
--- inserting a item into an empty stackset means that item is now a member
-prop_insert_empty i (EmptyStackSet x)= member i (insertUp i x)
-
--- insert should be idempotent
-prop_insert_idem i (x :: T) = insertUp i x == insertUp i (insertUp i x)
-
--- insert when an item is a member should leave the stackset unchanged
-prop_insert_duplicate (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  return $ insertUp w x == x
-
--- push shouldn't change anything but the current workspace
-prop_insert_local (x :: T) = do
-  i <- arbitrary `suchThat` \i' -> not $ i' `member` x
-  return $ hidden_spaces x == hidden_spaces (insertUp i x)
-
--- Inserting a (unique) list of items into an empty stackset should
--- result in the last inserted element having focus.
-prop_insert_peek (EmptyStackSet x) (NonEmptyNubList is) =
-    peek (foldr insertUp x is) == Just (head is)
-
--- insert >> delete is the identity, when i `notElem` .
--- Except for the 'master', which is reset on insert and delete.
---
-prop_insert_delete x = do
-  n <- arbitrary `suchThat` \n -> not $ n `member` x
-  return $ delete n (insertUp n y) == (y :: T)
-    where
-        y = swapMaster x -- sets the master window to the current focus.
-                         -- otherwise, we don't have a rule for where master goes.
-
--- inserting n elements increases current stack size by n
-prop_size_insert is (EmptyStackSet x) =
-        size (foldr insertUp x ws ) ==  (length ws)
-  where
-    ws   = nub is
-    size = length . index
diff --git a/source/tests/Properties/Layout/Full.hs b/source/tests/Properties/Layout/Full.hs
deleted file mode 100644
index eca6ec3..0000000
--- a/source/tests/Properties/Layout/Full.hs
+++ /dev/null
@@ -1,34 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Layout.Full where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-import XMonad.Core
-import XMonad.Layout
-
-import Data.Maybe
-
-------------------------------------------------------------------------
--- Full layout
-
--- pureLayout works for Full
-prop_purelayout_full rect = do
-  x <- (arbitrary :: Gen T) `suchThat` (isJust . peek)
-  let layout = Full
-      st = fromJust . stack . workspace . current $ x
-      ts = pureLayout layout rect st
-  return $
-        length ts == 1        -- only one window to view
-      &&
-        snd (head ts) == rect -- and sets fullscreen
-      &&
-        fst (head ts) == fromJust (peek x) -- and the focused window is shown
-
-
--- what happens when we send an IncMaster message to Full --- Nothing
-prop_sendmsg_full (NonNegative k) =
-         isNothing (Full `pureMessage` (SomeMessage (IncMasterN k)))
-
-prop_desc_full = description Full == show Full
diff --git a/source/tests/Properties/Layout/Tall.hs b/source/tests/Properties/Layout/Tall.hs
deleted file mode 100644
index 5353e62..0000000
--- a/source/tests/Properties/Layout/Tall.hs
+++ /dev/null
@@ -1,116 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Layout.Tall where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-import XMonad.Core
-import XMonad.Layout
-
-import Graphics.X11.Xlib.Types (Rectangle(..))
-
-import Data.Maybe
-import Data.List (sort)
-import Data.Ratio
-
-------------------------------------------------------------------------
--- The Tall layout
-
--- 1 window should always be tiled fullscreen
-prop_tile_fullscreen rect = tile pct rect 1 1 == [rect]
-    where pct = 1/2
-
--- multiple windows
-prop_tile_non_overlap rect windows nmaster = noOverlaps (tile pct rect nmaster windows)
-  where _ = rect :: Rectangle
-        pct = 3 % 100
-
--- splitting horizontally yields sensible results
-prop_split_horizontal (NonNegative n) x =
-      (noOverflows (+) (rect_x x) (rect_width x)) ==>
-        sum (map rect_width xs) == rect_width x
-     &&
-        all (== rect_height x) (map rect_height xs)
-     &&
-        (map rect_x xs) == (sort $ map rect_x xs)
-
-    where
-        xs = splitHorizontally n x
-
--- splitting vertically yields sensible results
-prop_split_vertical (r :: Rational) x =
-        rect_x x == rect_x a && rect_x x == rect_x b
-      &&
-        rect_width x == rect_width a && rect_width x == rect_width b
-    where
-        (a,b) = splitVerticallyBy r x
-
-
--- pureLayout works.
-prop_purelayout_tall n r1 r2 rect = do
-  x <- (arbitrary :: Gen T) `suchThat` (isJust . peek)
-  let layout = Tall n r1 r2
-      st = fromJust . stack . workspace . current $ x
-      ts = pureLayout layout rect st
-  return $
-        length ts == length (index x)
-      &&
-        noOverlaps (map snd ts)
-      &&
-        description layout == "Tall"
-
-
--- Test message handling of Tall
-
--- what happens when we send a Shrink message to Tall
-prop_shrink_tall (NonNegative n) (Positive delta) (NonNegative frac) =
-        n == n' && delta == delta' -- these state components are unchanged
-    && frac' <= frac  && (if frac' < frac then frac' == 0 || frac' == frac - delta
-                                          else frac == 0 )
-        -- remaining fraction should shrink
-    where
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage Shrink)
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
-
--- what happens when we send a Shrink message to Tall
-prop_expand_tall (NonNegative n)
-                 (Positive delta)
-                 (NonNegative n1)
-                 (Positive d1) =
-
-       n == n'
-    && delta == delta' -- these state components are unchanged
-    && frac' >= frac
-    && (if frac' > frac
-           then frac' == 1 || frac' == frac + delta
-           else frac == 1 )
-
-        -- remaining fraction should shrink
-    where
-         frac                 = min 1 (n1 % d1)
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage Expand)
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
--- what happens when we send an IncMaster message to Tall
-prop_incmaster_tall (NonNegative n) (Positive delta) (NonNegative frac)
-                    (NonNegative k) =
-       delta == delta'  && frac == frac' && n' == n + k
-    where
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage (IncMasterN k))
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
-
-
-     --   toMessage LT = SomeMessage Shrink
-     --   toMessage EQ = SomeMessage Expand
-     --   toMessage GT = SomeMessage (IncMasterN 1)
-
-
-prop_desc_mirror n r1 r2 = description (Mirror $! t) == "Mirror Tall"
-    where t = Tall n r1 r2
diff --git a/source/tests/Properties/Screen.hs b/source/tests/Properties/Screen.hs
deleted file mode 100644
index d12f954..0000000
--- a/source/tests/Properties/Screen.hs
+++ /dev/null
@@ -1,73 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Screen where
-
-import Utils
-import Test.QuickCheck
-import Instances
-
-import Control.Applicative
-import XMonad.StackSet hiding (filter)
-import XMonad.Operations
-import Graphics.X11.Xlib.Types (Dimension)
-
-import Graphics.X11 (Rectangle(Rectangle))
-import XMonad.Layout
-
-prop_screens (x :: T) = n `elem` screens x
- where
-    n = current x
-
--- screens makes sense
-prop_screens_works (x :: T) = screens x == current x : visible x
-
-
-------------------------------------------------------------------------
--- Hints
-
-prop_resize_inc (Positive inc_w,Positive inc_h)  b@(w,h) =
-    w' `mod` inc_w == 0 && h' `mod` inc_h == 0
-   where (w',h') = applyResizeIncHint a b
-         a = (inc_w,inc_h)
-
-prop_resize_inc_extra ((NonNegative inc_w))  b@(w,h) =
-     (w,h) == (w',h')
-   where (w',h') = applyResizeIncHint a b
-         a = (-inc_w,0::Dimension)-- inc_h)
-
-prop_resize_max (Positive inc_w,Positive inc_h)  b@(w,h) =
-    w' <= inc_w && h' <= inc_h
-   where (w',h') = applyMaxSizeHint a b
-         a = (inc_w,inc_h)
-
-prop_resize_max_extra ((NonNegative inc_w))  b@(w,h) =
-     (w,h) == (w',h')
-   where (w',h') = applyMaxSizeHint a b
-         a = (-inc_w,0::Dimension)-- inc_h)
-
-
-prop_aspect_hint_shrink hint (w,h) = case applyAspectHint hint (w,h) of
-  (w',h') -> w' <= w && h' <= h
-
-
--- applyAspectHint does nothing when the supplied (x,y) fits
--- the desired range
-prop_aspect_fits =
-    forAll ((,,,) <$> pos <*> pos <*> pos <*> pos) $ \ (x,y,a,b) -> 
-    let f v = applyAspectHint ((x, y+a), (x+b, y)) v
-    in  and [ noOverflows (*) x (y+a), noOverflows (*) (x+b) y ]
-            ==> f (x,y) == (x,y)
-
-  where pos = choose (0, 65535)
-        mul a b = toInteger (a*b) /= toInteger a * toInteger b
-
-prop_point_within r @ (Rectangle x y w h) =
-    forAll ((,) <$>
-              choose (0, fromIntegral w - 1) <*>
-              choose (0, fromIntegral h - 1)) $
-        \(dx,dy) ->
-    and [ dx > 0, dy > 0,
-         noOverflows (\ a b -> a + abs b) x w,
-         noOverflows (\ a b -> a + abs b) y h ]
-      ==> pointWithin (x+dx) (y+dy) r
-
-prop_point_within_mirror r (x,y) = pointWithin x y r == pointWithin y x (mirrorRect r)
diff --git a/source/tests/Properties/Shift.hs b/source/tests/Properties/Shift.hs
deleted file mode 100644
index 2150cbf..0000000
--- a/source/tests/Properties/Shift.hs
+++ /dev/null
@@ -1,70 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Shift where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Data.List as L
-
--- ---------------------------------------------------------------------
--- shift
-
--- shift is fully reversible on current window, when focus and master
--- are the same. otherwise, master may move.
-prop_shift_reversible (x :: T) = do
-    i <- arbitraryTag x
-    case peek y of
-      Nothing -> return True
-      Just _  -> return $ normal ((view n . shift n . view i . shift i) y) == normal y
-    where
-        y = swapMaster x
-        n = currentTag y
-
-------------------------------------------------------------------------
--- shiftMaster
-
--- focus/local/idempotent same as swapMaster:
-prop_shift_master_focus (x :: T) = peek x == (peek $ shiftMaster x)
-prop_shift_master_local (x :: T) = hidden_spaces x == hidden_spaces (shiftMaster x)
-prop_shift_master_idempotent (x :: T) = shiftMaster (shiftMaster x) == shiftMaster x
--- ordering is constant modulo the focused window:
-prop_shift_master_ordering (x :: T) = case peek x of
-    Nothing -> True
-    Just m  -> L.delete m (index x) == L.delete m (index $ shiftMaster x)
-
--- ---------------------------------------------------------------------
--- shiftWin
-
--- shiftWin on current window is the same as shift
-prop_shift_win_focus (x :: T) = do
-    n <- arbitraryTag x
-    case peek x of
-      Nothing -> return True
-      Just w  -> return $ shiftWin n w x == shift n x
-
--- shiftWin on a non-existant window is identity
-prop_shift_win_indentity (x :: T) = do
-    n <- arbitraryTag x
-    w <- arbitrary `suchThat` \w' -> not (w' `member` x)
-    return $ shiftWin n w x == x
-
--- shiftWin leaves the current screen as it is, if neither n is the tag
--- of the current workspace nor w on the current workspace
-prop_shift_win_fix_current = do
-  x <- arbitrary `suchThat` \(x' :: T) ->
-         -- Invariant, otherWindows are NOT in the current workspace.
-         let otherWindows = allWindows x' L.\\ index x'
-         in  length(tags x') >= 2 && length(otherWindows) >= 1
-  -- Sadly we have to construct `otherWindows` again, for the actual StackSet
-  -- that got chosen.
-  let otherWindows = allWindows x L.\\ index x
-  -- We know such tag must exists, due to the precondition
-  n <- arbitraryTag x `suchThat` (/= currentTag x)
-  -- we know length is >= 1, from above precondition
-  idx <- choose(0, length(otherWindows) - 1)
-  let w = otherWindows !! idx
-  return $ (current $ x) == (current $ shiftWin n w x)
-
diff --git a/source/tests/Properties/Stack.hs b/source/tests/Properties/Stack.hs
deleted file mode 100644
index 586df1d..0000000
--- a/source/tests/Properties/Stack.hs
+++ /dev/null
@@ -1,51 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Stack where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-import qualified XMonad.StackSet as S (filter)
-
-import Data.Maybe
-
-
--- The list returned by index should be the same length as the actual
--- windows kept in the zipper
-prop_index_length (x :: T) =
-    case stack . workspace . current $ x of
-        Nothing   -> length (index x) == 0
-        Just it -> length (index x) == length (focus it : up it ++ down it)
-
-
--- For all windows in the stackSet, findTag should identify the
--- correct workspace
-prop_findIndex (x :: T) =
-    and [ tag w == fromJust (findTag i x)
-        | w <- workspace (current x) : map workspace (visible x)  ++ hidden x
-        , t <- maybeToList (stack w)
-        , i <- focus t : up t ++ down t
-        ]
-
-prop_allWindowsMember (NonEmptyWindowsStackSet x) = do
-      -- Reimplementation of arbitraryWindow, but to make sure that
-      -- implementation doesn't change in the future, and stop using allWindows,
-      -- which is a key component in this test (together with member).
-  let ws = allWindows x
-  -- We know that there are at least 1 window in a NonEmptyWindowsStackSet.
-  idx <- choose(0, (length ws) - 1)
-  return $ member (ws!!idx) x
-
-
--- preserve order
-prop_filter_order (x :: T) =
-    case stack $ workspace $ current x of
-        Nothing -> True
-        Just s@(Stack i _ _) -> integrate' (S.filter (/= i) s) == filter (/= i) (integrate' (Just s))
-
--- differentiate should return Nothing if the list is empty or Just stack, with
--- the first element of the list is current, and the rest of the list is down.
-prop_differentiate xs =
-        if null xs then differentiate xs == Nothing
-                   else (differentiate xs) == Just (Stack (head xs) [] (tail xs))
-    where _ = xs :: [Int]
diff --git a/source/tests/Properties/StackSet.hs b/source/tests/Properties/StackSet.hs
deleted file mode 100644
index 7fc5192..0000000
--- a/source/tests/Properties/StackSet.hs
+++ /dev/null
@@ -1,135 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.StackSet where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe
-
-import Data.List (nub)
--- ---------------------------------------------------------------------
--- QuickCheck properties for the StackSet
-
--- Some general hints for creating StackSet properties:
---
--- *  ops that mutate the StackSet are usually local
--- *  most ops on StackSet should either be trivially reversible, or
---    idempotent, or both.
-------------------------------------------------------------------------
-
--- Basic data invariants of the StackSet
---
--- With the new zipper-based StackSet, tracking focus is no longer an
--- issue: the data structure enforces focus by construction.
---
--- But we still need to ensure there are no duplicates, and master/and
--- the xinerama mapping aren't checked by the data structure at all.
---
--- * no element should ever appear more than once in a StackSet
--- * the xinerama screen map should be:
---          -- keys should always index valid workspaces
---          -- monotonically ascending in the elements
--- * the current workspace should be a member of the xinerama screens
---
-invariant (s :: T) = and
-    -- no duplicates
-    [ noDuplicates
-
-    -- TODO: Fix this.
-    -- all this xinerama stuff says we don't have the right structure
---  , validScreens
---  , validWorkspaces
---  , inBounds
-    ]
-  where
-    ws = concat [ focus t : up t ++ down t
-                  | w <- workspace (current s) : map workspace (visible s) ++ hidden s
-                  , t <- maybeToList (stack w)] :: [Char]
-    noDuplicates = nub ws == ws
-
---  validScreens = monotonic . sort . M. . (W.current s : W.visible : W$ s
-
---  validWorkspaces = and [ w `elem` allworkspaces | w <- (M.keys . screens) s ]
---          where allworkspaces = map tag $ current s : prev s ++ next s
-
---  inBounds  = and [ w >=0 && w < size s | (w,sc) <- M.assocs (screens s) ]
-
-monotonic []       = True
-monotonic (x:[])   = True
-monotonic (x:y:zs) | x == y-1  = monotonic (y:zs)
-                   | otherwise = False
-
-prop_invariant = invariant
-
--- and check other ops preserve invariants
-prop_empty_I  (SizedPositive n) l = forAll (choose (1, fromIntegral n)) $  \m ->
-                                      forAll (vector m) $ \ms ->
-        invariant $ new l [0..fromIntegral n-1] ms
-
-prop_view_I n (x :: T) =
-    invariant $ view n x
-
-prop_greedyView_I n (x :: T) =
-    invariant $ greedyView n x
-
-prop_focusUp_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusUp x
-prop_focusMaster_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusMaster x
-prop_focusDown_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusDown x
-
-prop_focus_I (SizedPositive n) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let w = focus . fromJust . stack . workspace . current $
-                           applyN (Just n) focusUp x
-                   in invariant $ focusWindow w x
-
-prop_insertUp_I n (x :: T) = invariant $ insertUp n x
-
-prop_delete_I (x :: T) = invariant $
-    case peek x of
-        Nothing -> x
-        Just i  -> delete i x
-
-prop_swap_master_I (x :: T) = invariant $ swapMaster x
-
-prop_swap_left_I  (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) swapUp x
-prop_swap_right_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) swapDown x
-
-prop_shift_I (x :: T) = do
-  n <- arbitraryTag x
-  return $ invariant $ shift (fromIntegral n) x
-
-prop_shift_win_I (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  n <- arbitraryTag x
-  return $ invariant $ shiftWin n w x
-
-
--- ---------------------------------------------------------------------
-
-
--- empty StackSets have no windows in them
-prop_empty (EmptyStackSet x) =
-        all (== Nothing) [ stack w | w <- workspace (current x)
-                                        : map workspace (visible x) ++ hidden x ]
-
--- empty StackSets always have focus on first workspace
-prop_empty_current (EmptyStackSet x) = currentTag x == head (tags x)
-
--- no windows will be a member of an empty workspace
-prop_member_empty i (EmptyStackSet x) = member i x == False
-
--- peek either yields nothing on the Empty workspace, or Just a valid window
-prop_member_peek (x :: T) =
-    case peek x of
-        Nothing -> True {- then we don't know anything -}
-        Just i  -> member i x
diff --git a/source/tests/Properties/Swap.hs b/source/tests/Properties/Swap.hs
deleted file mode 100644
index a516f2c..0000000
--- a/source/tests/Properties/Swap.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Swap where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
--- ---------------------------------------------------------------------
--- swapUp, swapDown, swapMaster: reordiring windows
-
--- swap is trivially reversible
-prop_swap_left  (x :: T) = (swapUp  (swapDown x)) == x
-prop_swap_right (x :: T) = (swapDown (swapUp  x)) ==  x
--- TODO swap is reversible
--- swap is reversible, but involves moving focus back the window with
--- master on it. easy to do with a mouse...
-{-
-prop_promote_reversible x b = (not . null . fromMaybe [] . flip index x . current $ x) ==>
-                            (raiseFocus y . promote . raiseFocus z . promote) x == x
-  where _            = x :: T
-        dir          = if b then LT else GT
-        (Just y)     = peek x
-        (Just (z:_)) = flip index x . current $ x
--}
-
--- swap doesn't change focus
-prop_swap_master_focus (x :: T) = peek x == (peek $ swapMaster x)
---    = case peek x of
---        Nothing -> True
---        Just f  -> focus (stack (workspace $ current (swap x))) == f
-prop_swap_left_focus   (x :: T) = peek x == (peek $ swapUp   x)
-prop_swap_right_focus  (x :: T) = peek x == (peek $ swapDown  x)
-
--- swap is local
-prop_swap_master_local (x :: T) = hidden_spaces x == hidden_spaces (swapMaster x)
-prop_swap_left_local   (x :: T) = hidden_spaces x == hidden_spaces (swapUp   x)
-prop_swap_right_local  (x :: T) = hidden_spaces x == hidden_spaces (swapDown  x)
-
--- rotation through the height of a stack gets us back to the start
-prop_swap_all_l (x :: T) = (foldr (const swapUp)  x [1..n]) == x
-  where n = length (index x)
-prop_swap_all_r (x :: T) = (foldr (const swapDown) x [1..n]) == x
-  where n = length (index x)
-
-prop_swap_master_idempotent (x :: T) = swapMaster (swapMaster x) == swapMaster x
diff --git a/source/tests/Properties/View.hs b/source/tests/Properties/View.hs
deleted file mode 100644
index ef9b58d..0000000
--- a/source/tests/Properties/View.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.View where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (sortBy)
-
--- ---------------------------------------------------------------------
--- viewing workspaces
-
--- view sets the current workspace to 'n'
-prop_view_current (x :: T) = do
-    n <- arbitraryTag x
-    return $ (tag . workspace . current . view n) x == n
-
--- view *only* sets the current workspace, and touches Xinerama.
--- no workspace contents will be changed.
-prop_view_local  (x :: T) = do
-    n <- arbitraryTag x
-    return $ workspaces x == workspaces (view n x)
-  where
-    workspaces a = sortBy (\s t -> tag s `compare` tag t) $
-                                    workspace (current a)
-                                    : map workspace (visible a) ++ hidden a
-
--- TODO: Fix this
--- view should result in a visible xinerama screen
--- prop_view_xinerama (x :: T) (n :: NonNegative Int) = i `tagMember` x ==>
---     M.member i (screens (view i x))
---   where
---     i = fromIntegral n
-
--- view is idempotent
-prop_view_idem (x :: T) = do
-    n <- arbitraryTag x
-    return $ view n (view n x) == (view n x)
-
--- view is reversible, though shuffles the order of hidden/visible
-prop_view_reversible (x :: T) = do
-    n <- arbitraryTag x
-    return $ normal (view n' (view n x)) == normal x
-  where
-    n' = currentTag x
diff --git a/source/tests/Properties/Workspace.hs b/source/tests/Properties/Workspace.hs
deleted file mode 100644
index 612cba9..0000000
--- a/source/tests/Properties/Workspace.hs
+++ /dev/null
@@ -1,65 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Workspace where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe
-
--- looking up the tag of the current workspace should always produce a tag.
-prop_lookup_current (x :: T) = lookupWorkspace scr x == Just tg
-    where
-        (Screen (Workspace tg  _ _) scr _) = current x
-
--- looking at a visible tag
-prop_lookup_visible = do
-  -- make sure we have some xinerama screens.
-  x <- arbitrary `suchThat` \(x' :: T) -> visible x' /= []
-  let tags = [ tag (workspace y) | y <- visible x ]
-      scr = last [ screen y | y <- visible x ]
-  return $ fromJust (lookupWorkspace scr x) `elem` tags
-
-
-prop_currentTag (x :: T) =
-    currentTag x == tag (workspace (current x))
-
--- Rename a given tag if present in the StackSet.
-prop_rename1 (x::T) = do
-  o <- arbitraryTag x
-  n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-  -- Rename o to n
-  let y = renameTag o n x
-  return $ n `tagMember` y
-
--- Ensure that a given set of workspace tags is present by renaming
--- existing workspaces and\/or creating new hidden workspaces as
--- necessary.
---
-prop_ensure (x :: T) l xs = let y = ensureTags l xs x
-                                in and [ n `tagMember` y | n <- xs ]
-
--- adding a tag should create a new hidden workspace
-prop_ensure_append (x :: T) l = do
-    n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-    let ts = tags x
-        y  = ensureTags l (n:ts) x
-    return $ hidden y /= hidden x     -- doesn't append, renames
-             && and [ isNothing (stack z) && layout z == l | z <- hidden y, tag z == n ]
-
-
-
-
-prop_mapWorkspaceId (x::T) = x == mapWorkspace id x
-
-prop_mapWorkspaceInverse (x::T) = x == mapWorkspace predTag (mapWorkspace succTag x)
-  where predTag w = w { tag = pred $ tag w }
-        succTag w = w { tag = succ $ tag w }
-
-prop_mapLayoutId (x::T) = x == mapLayout id x
-
-prop_mapLayoutInverse (x::T) = x == mapLayout pred (mapLayout succ x)
-
-
diff --git a/source/tests/Properties.hs b/source/tests/Properties.hs
deleted file mode 100644
index e8c4e5a..0000000
--- a/source/tests/Properties.hs
+++ /dev/null
@@ -1,201 +0,0 @@
-import Test.QuickCheck
-
--- Our QC instances and properties.
-import Instances
-import Properties.Delete
-import Properties.Failure
-import Properties.Floating
-import Properties.Focus
-import Properties.GreedyView
-import Properties.Insert
-import Properties.Screen
-import Properties.Shift
-import Properties.Stack
-import Properties.StackSet
-import Properties.Swap
-import Properties.View
-import Properties.Workspace
-import Properties.Layout.Full
-import Properties.Layout.Tall
-
-import System.Environment
-import Text.Printf
-
-import Control.Monad
-import Control.Applicative
-
-main :: IO ()
-main = do
-  arg <- fmap (drop 1) getArgs
-  let n = if null arg then 100 else read $ head arg
-      args = stdArgs { maxSuccess = n, maxSize = 100 }
-      qc t = do
-          c <- quickCheckWithResult args t
-          case c of
-            Success {} -> return True
-            _ -> return False
-      perform (s, t) = printf "%-35s: " s >> qc t
-  n <- length . filter not <$> mapM perform tests
-  unless (n == 0) (error (show n ++ " test(s) failed"))
-
-
-
-tests =
-  [("StackSet invariants", property prop_invariant)
-  ,("empty: invariant",    property prop_empty_I)
-  ,("empty is empty",      property prop_empty)
-  ,("empty / current",     property prop_empty_current)
-  ,("empty / member",      property prop_member_empty)
-
-
-  ,("view : invariant",  property prop_view_I)
-  ,("view sets current", property prop_view_current)
-  ,("view idempotent",   property prop_view_idem)
-  ,("view reversible",   property prop_view_reversible)
-
-  ,("view is local",  property prop_view_local)
-
-  ,("greedyView : invariant",  property prop_greedyView_I)
-  ,("greedyView sets current", property prop_greedyView_current)
-  ,("greedyView is safe",      property prop_greedyView_current_id)
-  ,("greedyView idempotent",   property prop_greedyView_idem)
-  ,("greedyView reversible",   property prop_greedyView_reversible)
-  ,("greedyView is local",     property prop_greedyView_local)
-
-  ,("peek/member",  property prop_member_peek)
-
-  ,("index/length", property prop_index_length)
-
-  ,("focus left : invariant",    property prop_focusUp_I)
-  ,("focus master : invariant",  property prop_focusMaster_I)
-  ,("focus right: invariant",    property prop_focusDown_I)
-  ,("focusWindow: invariant",    property prop_focus_I)
-  ,("focus left/master",         property prop_focus_left_master)
-  ,("focus right/master",        property prop_focus_right_master)
-  ,("focus master/master",       property prop_focus_master_master)
-  ,("focusWindow master",        property prop_focusWindow_master)
-  ,("focus left/right",          property prop_focus_left)
-  ,("focus right/left",          property prop_focus_right)
-  ,("focus all left",            property prop_focus_all_l)
-  ,("focus all right",           property prop_focus_all_r)
-  ,("focus down is local",       property prop_focus_down_local)
-  ,("focus up is local",         property prop_focus_up_local)
-  ,("focus master is local",     property prop_focus_master_local)
-  ,("focus master idemp",        property prop_focusMaster_idem)
-
-  ,("focusWindow is local", property prop_focusWindow_local)
-  ,("focusWindow works"   , property prop_focusWindow_works)
-  ,("focusWindow identity", property prop_focusWindow_identity)
-
-  ,("findTag",           property prop_findIndex)
-  ,("allWindows/member", property prop_allWindowsMember)
-  ,("currentTag",        property prop_currentTag)
-
-  ,("insert: invariant",    property prop_insertUp_I)
-  ,("insert/new",           property prop_insert_empty)
-  ,("insert is idempotent", property prop_insert_idem)
-  ,("insert is reversible", property prop_insert_delete)
-  ,("insert is local",      property prop_insert_local)
-  ,("insert duplicates",    property prop_insert_duplicate)
-  ,("insert/peek",          property prop_insert_peek)
-  ,("insert/size",          property prop_size_insert)
-
-  ,("delete: invariant",       property prop_delete_I)
-  ,("delete/empty",            property prop_empty)
-  ,("delete/member",           property prop_delete)
-  ,("delete is reversible",    property prop_delete_insert)
-  ,("delete is local",         property prop_delete_local)
-  ,("delete/focus",            property prop_delete_focus)
-  ,("delete  last/focus up",   property prop_delete_focus_end)
-  ,("delete ~last/focus down", property prop_delete_focus_not_end)
-
-  ,("filter preserves order", property prop_filter_order)
-
-  ,("swapLeft",  property prop_swap_left)
-  ,("swapRight", property prop_swap_right)
-
-  ,("swapMaster: invariant",    property prop_swap_master_I)
-  ,("swapUp: invariant" ,       property prop_swap_left_I)
-  ,("swapDown: invariant",      property prop_swap_right_I)
-  ,("swapMaster id on focus",   property prop_swap_master_focus)
-  ,("swapUp id on focus",       property prop_swap_left_focus)
-  ,("swapDown id on focus",     property prop_swap_right_focus)
-  ,("swapMaster is idempotent", property prop_swap_master_idempotent)
-  ,("swap all left",            property prop_swap_all_l)
-  ,("swap all right",           property prop_swap_all_r)
-  ,("swapMaster is local",      property prop_swap_master_local)
-  ,("swapUp is local",          property prop_swap_left_local)
-  ,("swapDown is local",        property prop_swap_right_local)
-
-  ,("shiftMaster id on focus",        property prop_shift_master_focus)
-  ,("shiftMaster is local",           property prop_shift_master_local)
-  ,("shiftMaster is idempotent",      property prop_shift_master_idempotent)
-  ,("shiftMaster preserves ordering", property prop_shift_master_ordering)
-
-  ,("shift: invariant"    ,       property prop_shift_I)
-  ,("shift is reversible" ,       property prop_shift_reversible)
-  ,("shiftWin: invariant" ,       property prop_shift_win_I)
-  ,("shiftWin is shift on focus", property prop_shift_win_focus)
-  ,("shiftWin fix current" ,      property prop_shift_win_fix_current)
-  ,("shiftWin identity",          property prop_shift_win_indentity)
-
-  ,("floating is reversible" ,  property prop_float_reversible)
-  ,("floating sets geometry" ,  property prop_float_geometry)
-  ,("floats can be deleted",    property prop_float_delete)
-  ,("screens includes current", property prop_screens)
-
-  ,("differentiate works",     property prop_differentiate)
-  ,("lookupTagOnScreen",       property prop_lookup_current)
-  ,("lookupTagOnVisbleScreen", property prop_lookup_visible)
-  ,("screens works",           property prop_screens_works)
-  ,("renaming works",          property prop_rename1)
-  ,("ensure works",            property prop_ensure)
-  ,("ensure hidden semantics", property prop_ensure_append)
-
-  ,("mapWorkspace id",      property prop_mapWorkspaceId)
-  ,("mapWorkspace inverse", property prop_mapWorkspaceInverse)
-
-  ,("mapLayout id",      property prop_mapLayoutId)
-  ,("mapLayout inverse", property prop_mapLayoutInverse)
-
-  ,("abort fails",            property prop_abort)
-  ,("new fails with abort",   property prop_new_abort)
-
-  ,("point within",           property prop_point_within)
-
-  -- tall layout
-
-  ,("tile 1 window fullsize", property prop_tile_fullscreen)
-  ,("tiles never overlap",    property prop_tile_non_overlap)
-  ,("split horizontal",       property prop_split_horizontal)
-  ,("split vertical",         property prop_split_vertical)
-
-  ,("pure layout tall",       property prop_purelayout_tall)
-  ,("send shrink    tall",    property prop_shrink_tall)
-  ,("send expand    tall",    property prop_expand_tall)
-  ,("send incmaster tall",    property prop_incmaster_tall)
-
-  -- full layout
-
-  ,("pure layout full",       property prop_purelayout_full)
-  ,("send message full",      property prop_sendmsg_full)
-  ,("describe full",          property prop_desc_full)
-
-  ,("describe mirror",        property prop_desc_mirror)
-
-  -- resize hints
-  ,("window resize hints: inc",      property prop_resize_inc)
-  ,("window resize hints: inc all",  property prop_resize_inc_extra)
-  ,("window resize hints: max",      property prop_resize_max)
-  ,("window resize hints: max all ", property prop_resize_max_extra)
-
-  ,("window aspect hints: fits", property prop_aspect_fits)
-  ,("window aspect hints: shrinks ", property prop_aspect_hint_shrink)
-
-
-  ,("pointWithin",        property prop_point_within)
-  ,("pointWithin mirror", property prop_point_within_mirror)
-
-  ]
-
-
diff --git a/source/tests/Utils.hs b/source/tests/Utils.hs
deleted file mode 100644
index e3eef0f..0000000
--- a/source/tests/Utils.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE RankNTypes #-}
-module Utils where
-
-import XMonad.StackSet hiding (filter)
-import Graphics.X11.Xlib.Types (Rectangle(..))
-import Data.List (sortBy)
-
--- Useful operation, the non-local workspaces
-hidden_spaces x = map workspace (visible x) ++ hidden x
-
-
--- normalise workspace list
-normal s = s { hidden = sortBy g (hidden s), visible = sortBy f (visible s) }
-    where
-        f = \a b -> tag (workspace a) `compare` tag (workspace b)
-        g = \a b -> tag a `compare` tag b
-
-
-noOverlaps []  = True
-noOverlaps [_] = True
-noOverlaps xs  = and [ verts a `notOverlap` verts b
-                     | a <- xs
-                     , b <- filter (a /=) xs
-                     ]
-    where
-      verts (Rectangle a b w h) = (a,b,a + fromIntegral w - 1, b + fromIntegral h - 1)
-
-      notOverlap (left1,bottom1,right1,top1)
-                 (left2,bottom2,right2,top2)
-        =  (top1 < bottom2 || top2 < bottom1)
-        || (right1 < left2 || right2 < left1)
-
-
-applyN :: (Integral n) => Maybe n -> (a -> a) -> a -> a
-applyN Nothing f v = v
-applyN (Just 0) f v = v
-applyN (Just n) f v = applyN (Just $ n-1) f (f v)
-
-tags x = map tag $ workspaces x
-
-
--- | noOverflows op a b is True if @a `op` fromIntegral b@ overflows (or
--- otherwise gives the same answer when done using Integer
-noOverflows :: (Integral b, Integral c) =>
-  (forall a. Integral a => a -> a -> a) -> b -> c -> Bool
-noOverflows op a b = toInteger (a `op` fromIntegral b) == toInteger a `op` toInteger b
-
diff --git a/source/tests/loc.hs b/source/tests/loc.hs
deleted file mode 100644
index 238204a..0000000
--- a/source/tests/loc.hs
+++ /dev/null
@@ -1,14 +0,0 @@
-import Control.Monad
-import System.Exit
-
-main = do foo <- getContents
-          let actual_loc = filter (not.null) $ filter isntcomment $
-                           map (dropWhile (==' ')) $ lines foo
-              loc = length actual_loc
-          print loc
-          -- uncomment the following to check for mistakes in isntcomment
-          -- print actual_loc
-
-isntcomment ('-':'-':_) = False
-isntcomment ('{':'-':_) = False -- pragmas
-isntcomment _ = True
diff --git a/source/util/GenerateManpage.hs b/source/util/GenerateManpage.hs
deleted file mode 100644
index d220780..0000000
--- a/source/util/GenerateManpage.hs
+++ /dev/null
@@ -1,99 +0,0 @@
-{-# LANGUAGE FlexibleContexts #-}
--- Unlike the rest of xmonad, this file is released under the GNU General
--- Public License version 2 or later.
-
---
--- Generates man/xmonad.1 from man/xmonad.1.in by filling the list of
--- keybindings with values scraped from Config.hs
---
--- Uses cabal to grab the xmonad version from xmonad.cabal
---
--- Uses pandoc to convert the "xmonad.1.markdown" to "xmonad.1"
---
--- Format for the docstrings in Config.hs takes the following form:
---
--- -- mod-x %! Frob the whatsit
---
--- "Frob the whatsit" will be used as the description for keybinding "mod-x"
---
--- If the keybinding name is omitted, it will try to guess from the rest of the
--- line. For example:
---
--- [ ((modMask .|. shiftMask, xK_Return), spawn "xterm") -- %! Launch an xterm
---
--- Here, mod-shift-return will be used as the keybinding name.
-import Control.Monad
-import Control.Applicative
-import Text.Regex.Posix
-import Data.Char
-import Data.List
-
-import Distribution.PackageDescription.Parse
-import Distribution.Verbosity
-import Distribution.Package
-import Distribution.PackageDescription
-import Text.PrettyPrint.HughesPJ
-import Distribution.Text
-
-import Text.Pandoc -- works with 1.15.x
-
-releaseDate = "31 December 2012"
-
-trim :: String -> String
-trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace
-
-guessKeys line = concat $ intersperse "-" (modifiers ++ [map toLower key])
-    where modifiers = map (!!1) (line =~ "(mod|shift|control)Mask")
-          (_, _, _, [key]) = line =~ "xK_([_[:alnum:]]+)" :: (String, String, String, [String])
-
-binding :: [String] -> (String, String)
-binding [ _, bindingLine, "", desc ] = (guessKeys bindingLine, desc)
-binding [ _, _, keyCombo, desc ] = (keyCombo, desc)
-
-allBindings :: String -> [(String, String)]
-allBindings xs = map (binding . map trim) (xs =~ "(.*)--(.*)%!(.*)")
-
--- FIXME: What escaping should we be doing on these strings?
-markdownDefn :: (String, String) -> String
-markdownDefn (key, desc) = key ++ "\n:     " ++ desc
-
-replace :: Eq a => a -> a -> [a] -> [a]
-replace x y = map (\a -> if a == x then y else a)
-
--- rawSystem "pandoc" ["--read=markdown","--write=man","man/xmonad.1.markdown"]
-
-main = do
-    releaseName <- (show . disp . package . packageDescription)
-                    `liftM`readPackageDescription normal "xmonad.cabal"
-    keybindings <- (intercalate "\n\n" . map markdownDefn . allBindings)
-                    `liftM` readFile "./src/XMonad/Config.hs"
-
-    let manHeader = unwords [".TH xmonad 1","\""++releaseDate++"\"",releaseName,"\"xmonad manual\""]
-
-    Right parsed <- readMarkdown def
-        . unlines
-        . replace "___KEYBINDINGS___" keybindings
-        . lines
-        <$> readFile "./man/xmonad.1.markdown"
-
-    Right template <- getDefaultTemplate Nothing "man"
-    writeFile "./man/xmonad.1"
-        . (manHeader ++)
-        . writeMan def{ writerStandalone = True, writerTemplate = template }
-        $ parsed
-    putStrLn "Documentation created: man/xmonad.1"
-
-    Right template <- getDefaultTemplate Nothing "html"
-    writeFile "./man/xmonad.1.html"
-        . writeHtmlString def
-            { writerVariables =
-                        [("include-before"
-                            ,"<h1>"++releaseName++"</h1>"++
-                             "<p>Section: xmonad manual (1)<br/>"++
-                             "Updated: "++releaseDate++"</p>"++
-                             "<hr/>")]
-            , writerStandalone = True
-            , writerTemplate = template
-            , writerTableOfContents = True }
-        $ parsed
-    putStrLn "Documentation created: man/xmonad.1.html"
diff --git a/source/util/hpcReport.sh b/source/util/hpcReport.sh
deleted file mode 100644
index ab934b3..0000000
--- a/source/util/hpcReport.sh
+++ /dev/null
@@ -1,33 +0,0 @@
-#!/bin/bash
-
-set -e
-
-if [[ ! ( -e xmonad.cabal && -e dist/hpc/tix/properties/properties.tix ) ]]; then
-  echo "run in the same dir as xmonad.cabal after having run
-
-      cabal configure --enable-tests --enable-library-coverage; cabal test
-
-        "
-  exit 1
-fi
-
-
-propsExclude=$(find tests/Properties -name '*.hs' \
-        | sed -e 's_/_._g' -e 's_.hs$__' -e 's_^tests._--exclude=_' )
-
-hpcFlags="
-  --hpcdir=dist/hpc/mix/
-  dist/hpc/tix/properties/properties.tix
-  "
-
-
-if [[ ! (-e dist/hpc/mix/Main.mix) ]]; then
-  mv dist/hpc/mix/properties/* dist/hpc/mix/
-  mv dist/hpc/mix/xmonad-*/xmonad-*/* dist/hpc/mix/xmonad-*/
-fi
-
-
-hpc markup --destdir=dist/hpc $hpcFlags > /dev/null
-echo "see dist/hpc/hpc_index.html
-"
-hpc report $hpcFlags
