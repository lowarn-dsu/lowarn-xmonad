diff --git a/source/.github/FUNDING.yml b/source/.github/FUNDING.yml
deleted file mode 100644
index fa76634..0000000
--- a/source/.github/FUNDING.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-github:
-  - liskin
diff --git a/source/.github/ISSUE_TEMPLATE.md b/source/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index d837a67..0000000
--- a/source/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,24 +0,0 @@
-### Problem Description
-
-Describe the problem you are having, what you expect to happen
-instead, and how to reproduce the problem.
-
-### Configuration File
-
-Please include the smallest configuration file that reproduces the
-problem you are experiencing:
-
-```haskell
-module Main (main) where
-
-import XMonad
-
-main :: IO ()
-main = xmonad def
-```
-
-### Checklist
-
-  - [ ] I've read [CONTRIBUTING.md](https://github.com/xmonad/xmonad/blob/master/CONTRIBUTING.md)
-
-  - [ ] I tested my configuration with [xmonad-testing](https://github.com/xmonad/xmonad-testing)
diff --git a/source/.github/PULL_REQUEST_TEMPLATE.md b/source/.github/PULL_REQUEST_TEMPLATE.md
deleted file mode 100644
index 92edcea..0000000
--- a/source/.github/PULL_REQUEST_TEMPLATE.md
+++ /dev/null
@@ -1,14 +0,0 @@
-### Description
-
-Include a description for your changes, including the motivation
-behind them.
-
-### Checklist
-
-  - [ ] I've read [CONTRIBUTING.md](https://github.com/xmonad/xmonad/blob/master/CONTRIBUTING.md)
-
-  - [ ] I've confirmed these changes don't belong in xmonad-contrib instead
-
-  - [ ] I tested my changes with [xmonad-testing](https://github.com/xmonad/xmonad-testing)
-
-  - [ ] I updated the `CHANGES.md` file
diff --git a/source/.github/workflows/generatemanpage.yml b/source/.github/workflows/generatemanpage.yml
deleted file mode 100644
index 40b6f4c..0000000
--- a/source/.github/workflows/generatemanpage.yml
+++ /dev/null
@@ -1,33 +0,0 @@
-name: Generate manpage
-
-on:
-  push:
-    branches:
-      - master
-
-jobs:
-  build:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Clone project
-        uses: actions/checkout@v2
-
-      - name: Install dependencies
-        run: |
-          set -ex
-          sudo apt install -y pandoc
-
-      - name: Generate manpage
-        run: |
-          set -ex
-          for d in /opt/ghc/*/bin; do PATH="$d:$PATH"; break; done
-          make -B -C man
-
-      - name: Commit/push if changed
-        run: |
-          set -ex
-          git config user.name github-actions
-          git config user.email github-actions@github.com
-          git diff --quiet --exit-code && exit
-          git commit -a -m 'man: Update'
-          git push
diff --git a/source/.github/workflows/haskell-ci.yml b/source/.github/workflows/haskell-ci.yml
deleted file mode 100644
index 4b470f0..0000000
--- a/source/.github/workflows/haskell-ci.yml
+++ /dev/null
@@ -1,178 +0,0 @@
-# This GitHub workflow config has been generated by a script via
-#
-#   haskell-ci 'github' 'cabal.project'
-#
-# To regenerate the script (for example after adjusting tested-with) run
-#
-#   haskell-ci regenerate
-#
-# For more information, see https://github.com/haskell-CI/haskell-ci
-#
-# version: 0.12
-#
-# REGENDATA ("0.12",["github","cabal.project"])
-#
-name: Haskell-CI
-on:
-  - push
-  - pull_request
-jobs:
-  linux:
-    name: Haskell-CI - Linux - ${{ matrix.compiler }}
-    runs-on: ubuntu-18.04
-    container:
-      image: buildpack-deps:bionic
-    continue-on-error: ${{ matrix.allow-failure }}
-    strategy:
-      matrix:
-        include:
-          - compiler: ghc-9.0.1
-            allow-failure: false
-          - compiler: ghc-8.10.4
-            allow-failure: false
-          - compiler: ghc-8.8.4
-            allow-failure: false
-          - compiler: ghc-8.6.5
-            allow-failure: false
-          - compiler: ghc-8.4.4
-            allow-failure: false
-      fail-fast: false
-    steps:
-      - name: apt
-        run: |
-          apt-get update
-          apt-get install -y --no-install-recommends gnupg ca-certificates dirmngr curl git software-properties-common
-          apt-add-repository -y 'ppa:hvr/ghc'
-          apt-get update
-          apt-get install -y $CC cabal-install-3.4 libx11-dev libxext-dev libxinerama-dev libxrandr-dev libxss-dev
-        env:
-          CC: ${{ matrix.compiler }}
-      - name: Set PATH and environment variables
-        run: |
-          echo "$HOME/.cabal/bin" >> $GITHUB_PATH
-          echo "LANG=C.UTF-8" >> $GITHUB_ENV
-          echo "CABAL_DIR=$HOME/.cabal" >> $GITHUB_ENV
-          echo "CABAL_CONFIG=$HOME/.cabal/config" >> $GITHUB_ENV
-          HCDIR=$(echo "/opt/$CC" | sed 's/-/\//')
-          HCNAME=ghc
-          HC=$HCDIR/bin/$HCNAME
-          echo "HC=$HC" >> $GITHUB_ENV
-          echo "HCPKG=$HCDIR/bin/$HCNAME-pkg" >> $GITHUB_ENV
-          echo "HADDOCK=$HCDIR/bin/haddock" >> $GITHUB_ENV
-          echo "CABAL=/opt/cabal/3.4/bin/cabal -vnormal+nowrap" >> $GITHUB_ENV
-          HCNUMVER=$(${HC} --numeric-version|perl -ne '/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?$/; print(10000 * $1 + 100 * $2 + ($3 == 0 ? $5 != 1 : $3))')
-          echo "HCNUMVER=$HCNUMVER" >> $GITHUB_ENV
-          echo "ARG_TESTS=--enable-tests" >> $GITHUB_ENV
-          echo "ARG_BENCH=--enable-benchmarks" >> $GITHUB_ENV
-          echo "HEADHACKAGE=false" >> $GITHUB_ENV
-          echo "ARG_COMPILER=--$HCNAME --with-compiler=$HC" >> $GITHUB_ENV
-          echo "GHCJSARITH=0" >> $GITHUB_ENV
-        env:
-          CC: ${{ matrix.compiler }}
-      - name: env
-        run: |
-          env
-      - name: write cabal config
-        run: |
-          mkdir -p $CABAL_DIR
-          cat >> $CABAL_CONFIG <<EOF
-          remote-build-reporting: anonymous
-          write-ghc-environment-files: never
-          remote-repo-cache: $CABAL_DIR/packages
-          logs-dir:          $CABAL_DIR/logs
-          world-file:        $CABAL_DIR/world
-          extra-prog-path:   $CABAL_DIR/bin
-          symlink-bindir:    $CABAL_DIR/bin
-          installdir:        $CABAL_DIR/bin
-          build-summary:     $CABAL_DIR/logs/build.log
-          store-dir:         $CABAL_DIR/store
-          install-dirs user
-            prefix: $CABAL_DIR
-          repository hackage.haskell.org
-            url: http://hackage.haskell.org/
-          EOF
-          cat $CABAL_CONFIG
-      - name: versions
-        run: |
-          $HC --version || true
-          $HC --print-project-git-commit-id || true
-          $CABAL --version || true
-      - name: update cabal index
-        run: |
-          $CABAL v2-update -v
-      - name: install cabal-plan
-        run: |
-          mkdir -p $HOME/.cabal/bin
-          curl -sL https://github.com/haskell-hvr/cabal-plan/releases/download/v0.6.2.0/cabal-plan-0.6.2.0-x86_64-linux.xz > cabal-plan.xz
-          echo 'de73600b1836d3f55e32d80385acc055fd97f60eaa0ab68a755302685f5d81bc  cabal-plan.xz' | sha256sum -c -
-          xz -d < cabal-plan.xz > $HOME/.cabal/bin/cabal-plan
-          rm -f cabal-plan.xz
-          chmod a+x $HOME/.cabal/bin/cabal-plan
-          cabal-plan --version
-      - name: checkout
-        uses: actions/checkout@v2
-        with:
-          path: source
-      - name: initial cabal.project for sdist
-        run: |
-          touch cabal.project
-          echo "packages: $GITHUB_WORKSPACE/source/." >> cabal.project
-          cat cabal.project
-      - name: sdist
-        run: |
-          mkdir -p sdist
-          $CABAL sdist all --output-dir $GITHUB_WORKSPACE/sdist
-      - name: unpack
-        run: |
-          mkdir -p unpacked
-          find sdist -maxdepth 1 -type f -name '*.tar.gz' -exec tar -C $GITHUB_WORKSPACE/unpacked -xzvf {} \;
-      - name: generate cabal.project
-        run: |
-          PKGDIR_xmonad="$(find "$GITHUB_WORKSPACE/unpacked" -maxdepth 1 -type d -regex '.*/xmonad-[0-9.]*')"
-          echo "PKGDIR_xmonad=${PKGDIR_xmonad}" >> $GITHUB_ENV
-          touch cabal.project
-          touch cabal.project.local
-          echo "packages: ${PKGDIR_xmonad}" >> cabal.project
-          echo "package xmonad" >> cabal.project
-          echo "    ghc-options: -Werror=missing-methods" >> cabal.project
-          cat >> cabal.project <<EOF
-          package xmonad
-            flags: +pedantic
-          EOF
-          $HCPKG list --simple-output --names-only | perl -ne 'for (split /\s+/) { print "constraints: $_ installed\n" unless /^(xmonad)$/; }' >> cabal.project.local
-          cat cabal.project
-          cat cabal.project.local
-      - name: dump install plan
-        run: |
-          $CABAL v2-build $ARG_COMPILER $ARG_TESTS $ARG_BENCH --dry-run all
-          cabal-plan
-      - name: cache
-        uses: actions/cache@v2
-        with:
-          key: ${{ runner.os }}-${{ matrix.compiler }}-${{ github.sha }}
-          path: ~/.cabal/store
-          restore-keys: ${{ runner.os }}-${{ matrix.compiler }}-
-      - name: install dependencies
-        run: |
-          $CABAL v2-build $ARG_COMPILER --disable-tests --disable-benchmarks --dependencies-only -j2 all
-          $CABAL v2-build $ARG_COMPILER $ARG_TESTS $ARG_BENCH --dependencies-only -j2 all
-      - name: build w/o tests
-        run: |
-          $CABAL v2-build $ARG_COMPILER --disable-tests --disable-benchmarks all
-      - name: build
-        run: |
-          $CABAL v2-build $ARG_COMPILER $ARG_TESTS $ARG_BENCH all --write-ghc-environment-files=always
-      - name: tests
-        run: |
-          $CABAL v2-test $ARG_COMPILER $ARG_TESTS $ARG_BENCH all --test-show-details=direct
-      - name: cabal check
-        run: |
-          cd ${PKGDIR_xmonad} || false
-          ${CABAL} -vnormal check
-      - name: haddock
-        run: |
-          $CABAL v2-haddock $ARG_COMPILER --with-haddock $HADDOCK $ARG_TESTS $ARG_BENCH all
-      - name: unconstrained build
-        run: |
-          rm -f cabal.project.local
-          $CABAL v2-build $ARG_COMPILER --disable-tests --disable-benchmarks all
diff --git a/source/.github/workflows/stack.yml b/source/.github/workflows/stack.yml
deleted file mode 100644
index 02a2fbe..0000000
--- a/source/.github/workflows/stack.yml
+++ /dev/null
@@ -1,91 +0,0 @@
-name: Stack
-
-on:
-  push:
-  pull_request:
-
-jobs:
-  build:
-    name: Stack CI - Linux - ${{ matrix.resolver }}
-    runs-on: ubuntu-latest
-    strategy:
-      fail-fast: false
-      matrix:
-        include:
-          - resolver: lts-12
-            ghc: 8.4.4
-          - resolver: lts-14
-            ghc: 8.6.5
-          - resolver: lts-16
-            ghc: 8.8.4
-          - resolver: lts-17
-            ghc: 8.10.4
-
-    steps:
-      - name: Clone project
-        uses: actions/checkout@v2
-
-      - name: Prepare apt sources
-        run: |
-          set -ex
-          sudo add-apt-repository -y ppa:hvr/ghc
-          sudo apt update -y
-
-      - name: Install C dependencies
-        run: |
-          set -ex
-          sudo apt install -y \
-            libx11-dev \
-            libxext-dev \
-            libxinerama-dev \
-            libxrandr-dev \
-            libxss-dev \
-            #
-
-      - name: Install GHC
-        # use system ghc in stack, don't waste GH Actions cache space
-        run: |
-          set -ex
-          sudo apt install -y ghc-${{ matrix.ghc }}
-          echo /opt/ghc/${{ matrix.ghc }}/bin >> $GITHUB_PATH
-
-      - name: Refresh caches once a month
-        id: cache-date
-        # GHA writes caches on the first miss and then never updates them again;
-        # force updating the cache at least once a month
-        run: |
-          echo "::set-output name=date::$(date +%Y-%m)"
-
-      - name: Cache Haskell package metadata
-        uses: actions/cache@v2
-        with:
-          path: ~/.stack/pantry
-          key: stack-pantry-${{ runner.os }}-${{ steps.cache-date.outputs.date }}
-          restore-keys: |
-            stack-pantry-${{ runner.os }}-
-
-      - name: Cache Haskell dependencies
-        uses: actions/cache@v2
-        with:
-          path: |
-            ~/.stack/*
-            !~/.stack/pantry
-          key: stack-${{ runner.os }}-${{ matrix.resolver }}-${{ steps.cache-date.outputs.date }}-${{ hashFiles('stack.yaml') }}-${{ hashFiles('*.cabal') }}
-          restore-keys: |
-            stack-${{ runner.os }}-${{ matrix.resolver }}-${{ steps.cache-date.outputs.date }}-${{ hashFiles('stack.yaml') }}-
-            stack-${{ runner.os }}-${{ matrix.resolver }}-${{ steps.cache-date.outputs.date }}-
-            stack-${{ runner.os }}-${{ matrix.resolver }}-
-
-      - name: Update hackage index
-        # always update index to prevent the shared ~/.stack/pantry cache from being empty
-        run: |
-          set -ex
-          stack update
-
-      - name: Build and test
-        run: |
-          set -ex
-          stack test \
-            --fast --no-terminal \
-            --resolver=${{ matrix.resolver }} --system-ghc \
-            --flag=xmonad:pedantic
diff --git a/source/CHANGES.md b/source/CHANGES.md
deleted file mode 100644
index 4c6346a..0000000
--- a/source/CHANGES.md
+++ /dev/null
@@ -1,213 +0,0 @@
-# Change Log / Release Notes
-
-## unknown (unknown)
-
-  * Fixed a bug when using multiple screens with different dimensions,
-    causing some floating windows to be smaller/larger than the size they
-    requested.
-
-  * Added `Typeable layout` constraint to `LayoutClass`, making it possible to
-    cast `Layout` back into a concrete type and extract current layout state
-    from it.
-
-  * Export constructor for `Choose` and `CLR` from `Module.Layout` to allow
-    pattern-matching on the left and right sub-layouts of `Choose l r a`.
-
-  * Compatibility with GHC 9.0
-
-  * Improve handling of XDG directories.
-
-      1. If all three of xmonad's environment variables (`XMONAD_DATA_DIR,`
-         `XMONAD_CONFIG_DIR`, and `XMONAD_CACHE_DIR`) are set, use them.
-      2. If there is a build script called `build` (see [here](https://github.com/xmonad/xmonad-testing/tree/master/build-scripts) for usage
-         examples) or configuration `xmonad.hs` in `~/.xmonad`, set all three
-         directories to `~/.xmonad`.
-      3. Otherwise, use the `xmonad` directory in `XDG_DATA_HOME`,
-         `XDG_CONFIG_HOME`, and `XDG_CACHE_HOME` (or their respective
-         fallbacks). These directories are created if necessary.
-
-    In the cases of 1. and 3., the build script or executable is
-    expected to be in the config dir.
-
-  * Change `ScreenDetail` to a newtype and make `RationalRect` strict in
-    its contents.
-
-  * Fixed dunst notifications being obscured when moving floats.
-    https://github.com/xmonad/xmonad/issues/208
-
-  * Added `Foldable`, `Functor`, and `Traversable` instances for `Stack`.
-
-  * `util/GenerateManpage.hs` is no longer distributed in the tarball.
-    Instead, the manpage source is regenerated and manpage rebuilt
-    automatically in CI.
-
-  * Added the `extensibleConf` field to `XConfig` which makes it easier for
-    contrib modules to have composable configuration (custom hooks, …).
-
-  * Migrated `X.L.LayoutCombinators.(|||)` into `XMonad.Layout`,
-    providing the ability to directly jump to a layout with the
-    `JumpToLayout` message.
-
-## 0.15 (September 30, 2018)
-
-  * Reimplement `sendMessage` to deal properly with windowset changes made
-    during handling.
-
-  * Add new library functions `windowBracket` and `modifyWindowSet` to
-    `XMonad.Operations`.
-
-## 0.14.2 (August 21, 2018)
-
-### Bug Fixes
-
-  * Add the sample configuration file xmonad.hs again to the release tarball.
-    [https://github.com/xmonad/xmonad/issues/181]
-
-## 0.14.1 (August 20, 2018)
-
-### Breaking Changes
-
-  * The cabal build no longer installs xmonad.hs, xmonad.1, and xmonad.1.html
-    as data files. The location cabal picks for chose files isn't useful as
-    standard tools like man(1) won't find them there. Instead, we rely on
-    distributors to pick up the files from the source tarball during the build
-    and to install them into proper locations where their users expect them.
-    [https://github.com/xmonad/xmonad/pull/127]
-
-### Bug Fixes
-
-  * Add support for GHC 8.6.x by providing an instance for 'MonadFail X'. A
-    side effect of that change is that our code no longer compiles with GHC
-    versions prior to 8.0.x. We could work around that, no doubt, but the
-    resulting code would require CPP and Cabal flags and whatnot. It feels more
-    reasonable to just require a moderately recent compiler instead of going
-    through all that trouble.
-
-  * xmonad no longer always recompile on startup. Now it only does so if the
-    executable does not have the name that would be used for the compilation
-    output. The purpose of recompiling and executing the results in this case is
-    so that the `xmonad` executable in the package can be used with custom
-    configurations.
-
-### Enhancements
-
-  * Whenever xmonad recompiles, it now explains how it is attempting to
-    recompile, by outputting logs to stderr. If you are using xmonad as a custom
-    X session, then this will end up in a `.xsession-errors` file.
-
-## 0.14 (July 30, 2018)
-
-### Bug Fixes
-
-  * The state file that xmonad uses while restarting itself is now
-    removed after it is processed.  This fixes a bug that manifested
-    in several different ways:
-
-    - Names of old workspaces would be resurrected after a restart
-    - Screen sizes would be wrong after changing monitor configuration (#90)
-    - `spawnOnce` stopped working (xmonad/xmonad-contrib#155)
-    - Focus did not follow when moving between workspaces (#87)
-    - etc.
-
-  * Recover old behavior (in 0.12) when `focusFollowsMouse == True`:
-    the focus follows when the mouse enters another workspace
-    but not moving into any window.
-
-  * Compiles with GHC 8.4.1
-
-  * Restored compatability with GHC version prior to 8.0.1 by removing the
-    dependency on directory version 1.2.3.
-
-
-## 0.13 (February 10, 2017)
-
-### Breaking Changes
-
-  * When restarting xmonad, resume state is no longer passed to the
-    next process via the command line.  Instead, a temporary state
-    file is created and xmonad's state is serialized to that file.
-
-    When upgrading to 0.13 from a previous version, the `--resume`
-    command line option will automatically migrate to a state file.
-
-    This fixes issue #12.
-
-### Enhancements
-
-  * You can now control which directory xmonad uses for finding your
-    configuration file and which one is used for storing the compiled
-    version of your configuration.  In order of preference:
-
-      1. New environment variables.  If you want to use these ensure
-         you set the correct environment variable and also create the
-         directory it references:
-
-         - `XMONAD_CONFIG_DIR`
-         - `XMONAD_CACHE_DIR`
-         - `XMONAD_DATA_DIR`
-
-      2. The `~/.xmonad` directory.
-
-      3. XDG Base Directory Specification directories, if they exist:
-
-         - `XDG_CONFIG_HOME/xmonad`
-         - `XDG_CACHE_HOME/xmonad`
-         - `XDG_DATA_HOME/xmonad`
-
-    If none of these directories exist then one will be created using
-    the following logic: If the relevant environment variable
-    mentioned in step (1) above is set, the referent directory will be
-    created and used.  Otherwise `~/.xmonad` will be created and used.
-
-    This fixes a few issues, notably #7 and #56.
-
-  * A custom build script can be used when xmonad is given the
-    `--recompile` command line option.  If an executable named `build`
-    exists in the xmonad configuration directory it will be called
-    instead of `ghc`.  It takes one argument, the name of the
-    executable binary it must produce.
-
-    This fixes #8.  (One of two possible custom build solutions.  See
-    the next entry for another solution.)
-
-  * For users who build their xmonad configuration using tools such as
-    cabal or stack, there is another option for executing xmonad.
-
-    Instead of running the `xmonad` executable directly, arrange to
-    have your login manager run your configuration binary instead.
-    Then, in your binary, use the new `launch` command instead of
-    `xmonad`.
-
-    This will keep xmonad from using its configuration file
-    checking/compiling code and directly start the window manager
-    without `exec`ing any other binary.
-
-    See the documentation for the `launch` function in `XMonad.Main`
-    for more details.
-
-    Fixes #8.  (Second way to have a custom build environment for
-    XMonad.  See previous entry for another solution.)
-
-## 0.12 (December 14, 2015)
-
-  * Compiles with GHC 7.10.2, 7.8.4, and 7.6.3
-
-  * Use of [data-default][] allows using `def` where previously you
-    had to write `defaultConfig`, `defaultXPConfig`, etc.
-
-  * The [setlocale][] package is now used instead of a binding shipped
-    with xmonad proper allowing the use of `Main.hs` instead of
-    `Main.hsc`
-
-  * No longer encodes paths for `spawnPID`
-
-  * The default `manageHook` no longer floats Gimp windows
-
-  * Doesn't crash when there are fewer workspaces than screens
-
-  * `Query` is now an instance of `Applicative`
-
-  * Various improvements to the example configuration file
-
-[data-default]: http://hackage.haskell.org/package/data-default
-[setlocale]: https://hackage.haskell.org/package/setlocale
diff --git a/source/CONFIG b/source/CONFIG
deleted file mode 100644
index 8dce8e7..0000000
--- a/source/CONFIG
+++ /dev/null
@@ -1,87 +0,0 @@
-== Configuring xmonad ==
-
-xmonad is configured by creating and editing the file:
-
-    ~/.xmonad/xmonad.hs
-
-xmonad then uses settings from this file as arguments to the window
-manager, on startup. It is also possible to use alternative paths for
-your configuration file; for that, consult
-
-    man xmonad
-
-For a complete example of possible settings see the file:
-
-    man/xmonad.hs
-
-Further examples are on the website, wiki and extension documentation.
-
-    http://haskell.org/haskellwiki/Xmonad
-
-== A simple example ==
-
-Here is a basic example, which overrides the default border width,
-default terminal, and some colours. This text goes in the file
-$HOME/.xmonad/xmonad.hs :
-
-    import XMonad
-
-    main = xmonad $ def
-        { borderWidth        = 2
-        , terminal           = "urxvt"
-        , normalBorderColor  = "#cccccc"
-        , focusedBorderColor = "#cd8b00" }
-
-You can find the defaults in the file:
-
-    XMonad/Config.hs
-
-== Checking your xmonad.hs is correct ==
-
-Place this text in ~/.xmonad/xmonad.hs, and then check that it is
-syntactically and type correct by loading it in the Haskell
-interpreter:
-
-    $ ghci ~/.xmonad/xmonad.hs
-    GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
-    Loading package base ... linking ... done.
-    Ok, modules loaded: Main.
-
-    Prelude Main> :t main
-    main :: IO ()
-
-Ok, looks good.
-
-== Loading your configuration ==
-
-To have xmonad start using your settings, type 'mod-q'.  xmonad will
-then load this new file, and run it.  If it is unable to, the defaults
-are used.
-
-To load successfully, both 'xmonad' and 'ghc' must be in your $PATH
-environment variable.  If GHC isn't in your path, for some reason, you
-can compile the xmonad.hs file yourself:
-
-    $ cd ~/.xmonad
-    $ ghc --make xmonad.hs
-    $ ls
-    xmonad    xmonad.hi xmonad.hs xmonad.o
-
-When you hit mod-q, this newly compiled xmonad will be used.
-
-== Where are the defaults? ==
-
-The default configuration values are defined in the source file:
-
-    XMonad/Config.hs
-
-the XConfig data structure itself is defined in:
-
-    XMonad/Core.hs
-
-== Extensions ==
-
-Since the xmonad.hs file is just another Haskell module, you may import
-and use any Haskell code or libraries you wish. For example, you can use
-things from the xmonad-contrib library, or other code you write
-yourself.
diff --git a/source/CONTRIBUTING.md b/source/CONTRIBUTING.md
deleted file mode 100644
index a082e60..0000000
--- a/source/CONTRIBUTING.md
+++ /dev/null
@@ -1,157 +0,0 @@
-# Contributing to xmonad and xmonad-contrib
-
-## Before Creating a GitHub Issue
-
-New issue submissions should adhere to the following guidelines:
-
-  * Does your issue have to do with [xmonad][], [xmonad-contrib][], or
-    maybe even with the [X11][] library?
-
-    Please submit your issue to the **correct** GitHub repository.
-
-  * To help you figure out which repository to submit your issue to,
-    and to help us resolve the problem you are having, create the
-    smallest configuration file you can that reproduces the problem.
-
-    You may find that the [xmonad-testing][] repository is helpful in
-    reproducing the problem with a smaller configuration file.
-
-    Once you've done that please include the configuration file with
-    your GitHub issue.
-
-  * If possible, use the [xmonad-testing][] repository to test your
-    configuration with the bleeding-edge development version of xmonad
-    and xmonad-contrib.  We might have already fixed your problem.
-
-## Contributing Changes/Patches
-
-Have a change to xmonad that you want included in the next release?
-Awesome!  Here are a few things to keep in mind:
-
-  * Review the above section about creating GitHub issues.
-
-  * It's always best to talk with the community before making any
-    nontrivial changes to xmonad.  There are a couple of ways you can
-    chat with us:
-
-    - Post a message to the [mailing list][ml].
-
-    - Join the `#xmonad` IRC channel on `irc.libera.chat`.
-
-  * [XMonad.Doc.Developing][xmonad-doc-developing] is a great
-    resource to get an overview of xmonad.  Make sure to also check
-    it if you want more details on the coding style.
-
-  * Continue reading this document!
-
-## Expediting Reviews and Merges
-
-Here are some tips for getting your changes merged into xmonad:
-
-  * If your changes can go into [xmonad-contrib][] instead
-    of [xmonad][], please do so.  We rarely accept new features to
-    xmonad.  (Not that we don't accept changes to xmonad, just that we
-    prefer changes to xmonad-contrib instead.)
-
-  * Change the fewest files as possible.  If it makes sense, submit a
-    completely new module to xmonad-contrib.
-
-  * Your changes should include relevant entries in the `CHANGES.md`
-    file.  Help us communicate changes to the community.
-
-  * Make sure you test your changes using the [xmonad-testing][]
-    repository.  Include a new configuration file that shows off your
-    changes if possible by creating a PR on that repository as well.
-
-  * Make sure you run the automated tests.  Both [xmonad-contrib][]
-    and [xmonad][] have test-suites that you could run with
-    `stack test` for example.
-
-  * Make sure you read the section on rebasing and squashing commits
-    below.
-
-## Rebasing and Squashing Commits
-
-Under no circumstances should you ever merge the master branch into
-your feature branch.  This makes it nearly impossible to review your
-changes and we *will not accept your PR* if you do this.
-
-Instead of merging you should rebase your changes on top of the master
-branch.  If a core team member asks you to "rebase your changes" this
-is what they are talking about.
-
-It's also helpful to squash all of your commits so that your pull
-request only contains a single commit.  Again, this makes it easier to
-review your changes and identify the changes later on in the Git
-history.
-
-### How to Rebase Your Changes
-
-The goal of rebasing is to bring recent changes from the master branch
-into your feature branch.  This often helps resolve conflicts where
-you have changed a file that also changed in a recently merged pull
-request (i.e. the `CHANGES.md` file).  Here is how you do that.
-
-  1. Make sure that you have a `git remote` configured for the main
-     repository.  I like to call this remote `upstream`:
-     ```shell
-     $ git remote add upstream https://github.com/xmonad/xmonad-contrib.git
-     ```
-
-  2. Pull from upstream and rewrite your changes on top of master.  For
-     this to work you should not have any modified files in your
-     working directory.  Run these commands from within your feature
-     branch (the branch you are asking to be merged):
-
-     ```shell
-     $ git fetch --all
-     $ git pull --rebase upstream master
-     ```
-
-  3. If the rebase was successful you can now push your feature branch
-     back to GitHub.  You need to force the push since your commits
-     have been rewritten and have new IDs:
-
-     ```shell
-     $ git push --force-with-lease
-     ```
-
-  4. Your pull request should now be conflict-free and only contain the
-     changes that you actually made.
-
-### How to Squash Commits
-
-The goal of squashing commits is to produce a clean Git history where
-each pull request contains just one commit.
-
-  1. Use `git log` to see how many commits you are including in your
-     pull request.  (If you've already submitted your pull request you
-     can see this in the GitHub interface.)
-
-  2. Rebase all of those commits into a single commit.  Assuming you
-     want to squash the last four (4) commits into a single commit:
-     ```shell
-     $ git rebase -i HEAD~4
-     ```
-
-  3. Git will open your editor and display the commits you are
-     rebasing with the word "pick" in front of them.
-
-  4. Leave the first listed commit as "pick" and change the remaining
-     commits from "pick" to "squash".
-
-  5. Save the file and exit your editor.  Git will create a new commit
-     and open your editor so you can modify the commit message.
-
-  6. If everything was successful you can push your changed history
-     back up to GitHub:
-     ```shell
-     $ git push --force-with-lease
-     ```
-
-[xmonad]: https://github.com/xmonad/xmonad
-[xmonad-contrib]: https://github.com/xmonad/xmonad-contrib
-[xmonad-testing]: https://github.com/xmonad/xmonad-testing
-[x11]: https://github.com/xmonad/X11
-[ml]: https://mail.haskell.org/cgi-bin/mailman/listinfo/xmonad
-[xmonad-doc-developing]: http://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Doc-Developing.html
diff --git a/source/INSTALL.md b/source/INSTALL.md
deleted file mode 100644
index 9f2606e..0000000
--- a/source/INSTALL.md
+++ /dev/null
@@ -1,180 +0,0 @@
-# Install XMonad
-
-## Stack
-
-### Preparation
-
-We'll use the [XDG] directory specifications here, meaning our
-configuration will reside within `$XDG_CONFIG_HOME`, which is
-`~/.config` on most systems.  Let's create this directory and move to
-it:
-
-``` shell
-  $ mkdir -p ~/.config/xmonad && cd ~/.config/xmonad
-```
-
-If you already have an `xmonad.hs` configuration, you can copy it over
-now.  If not, you can use the defaults: create a file called `xmonad.hs`
-with the following content:
-
-``` haskell
-  import XMonad
-
-  main :: IO ()
-  main = xmonad def
-```
-
-### Install Stack
-
-The easiest way to get [stack] is probably via your system's package
-manager.  For example, on Debian:
-
-``` shell
-  $ apt install haskell-stack
-```
-
-If your distribution does not package stack, you can also easily install
-it via the following command (this is the recommended way to install
-stack via its [documentation][stack]):
-
-``` shell
-  $ curl -sSL https://get.haskellstack.org/ | sh
-```
-
-Yet another way would be via [ghcup]; this is similar to installers like
-`rustup`, in case you prefer that.
-
-### Create a New Project
-
-Let's create a stack project.  Since we're already in the correct
-directory (`~/.config/xmonad`), we can start by cloning the `xmonad` and
-the `xmonad-contrib` repositories:
-
-``` shell
-  $ git clone https://github.com/xmonad/xmonad
-  $ git clone https://github.com/xmonad/xmonad-contrib
-```
-
-This will give you the latest `$HEAD`; if you want you can also check
-out a tagged release, e.g.:
-
-``` shell
-  $ git clone --branch v0.16 https://github.com/xmonad/xmonad
-  $ git clone --branch v0.17 https://github.com/xmonad/xmonad-contrib
-```
-
-Starting a new stack project is as simple as running `stack init`.
-Stack should now inform you that it will use the relevant `stack` and
-`cabal` files from `xmonad` and `xmonad-contrib` to generate its
-`stack.yaml` file.  At the time of writing, this looks a little bit like
-this:
-
-```
-  $ stack init
-  Looking for .cabal or package.yaml files to use to init the project.
-  Using cabal packages:
-  - xmonad-contrib/
-  - xmonad/
-
-  Selecting the best among 19 snapshots...
-
-  * Matches https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/17/9.yaml
-
-  Selected resolver: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/17/9.yaml
-  Initialising configuration using resolver: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/17/9.yaml
-  Total number of user packages considered: 2
-  Writing configuration to file: stack.yaml
-  All done.
-```
-
-If you look into your current directory now, you should see a freshly
-generated `stack.yaml` file:
-
-```
-  $ ls
-  xmonad  xmonad-contrib  stack.yaml  xmonad.hs
-```
-
-The meat of that file (comments start with `#`, we've omitted them here)
-will look a little bit like
-
-``` yaml
-  resolver:
-    url: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/17/9.yaml
-
-  packages:
-  - xmonad
-  - xmonad-contrib
-```
-
-### Install Everything
-
-Installing things is as easy as typing `stack install`.  This will
-install the correct version of GHC, as well as build all of the required
-packages (`stack build`) and then copy the relevant executables
-(`xmonad`, in our case) to `~/.local/bin`.  Make sure to add that
-directory to your `$PATH`!
-
-If you're getting build failures while building the `X11` package it may
-be that you don't have the required C libraries installed.  Depending on
-your system, this may be `libX11-devel`, or `libxss`.
-
-### Tell XMonad How to Recompile Itself
-
-In order to tell xmonad to invoke `stack build` when we issue `xmonad
---recompile` (bound to `M-q` by default), we need to create a so-called
-`build` file.  This is quite literally just a shell script called
-`build` in your xmonad directory (which is `~/.config/xmonad` for us)
-that tells xmonad how it should build its executable.
-
-A good starting point (this is essentially [what xmonad would do]
-without a build file, with the exception that we are invoking `stack
-ghc` instead of plain `ghc`) would be
-
-``` shell
-  #!/bin/sh
-
-  exec stack ghc --  \
-    --make xmonad.hs \
-    -i               \
-    -ilib            \
-    -fforce-recomp   \
-    -main-is main    \
-    -v0              \
-    -o "$1"
-```
-
-Don't forget to mark the file as `+x`: `chmod +x build`!
-
-And that's it!  Recompilation should work normally now, though you will
-potentially need to restart your computer, or at least the running X
-session, first.
-
-### Don't Recompile on Every Startup
-
-By default, xmonad always recompiles itself when a build script is used
-(because the build script could contain arbitrary code, so a simple
-check whether the `xmonad.hs` file changed is not enough).  If you find
-that too annoying, then you can use the `xmonad-ARCH` executable that
-`xmonad --recompile` generates instead of `xmonad` in your startup.  For
-example, instead of writing
-
-``` shell
-  exec xmonad
-```
-
-in your `~/.xinitrc`, you would write
-
-``` shell
-  exec $HOME/.local/share/xmonad/xmonad-x86_64-linux
-```
-
-The `~/.local/share` prefix is the `$XDG_DATA_DIR` directory.  Note that
-if your xmonad configuration resides within `~/.xmonad`, then the
-executable will also be within that directory and not in
-`$XDG_DATA_DIR`.
-
-[XDG]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
-[stack]: https://docs.haskellstack.org/en/stable/README/
-[ghcup]: https://www.haskell.org/ghcup/
-[what xmonad would do]: https://github.com/xmonad/xmonad/blob/master/src/XMonad/Core.hs#L657-L665
diff --git a/source/MAINTAINERS.md b/source/MAINTAINERS.md
deleted file mode 100644
index efc45de..0000000
--- a/source/MAINTAINERS.md
+++ /dev/null
@@ -1,98 +0,0 @@
-# XMonad Maintainers
-
-## The XMonad Core Team
-
-  * Adam Vogt [GitHub][aavogt]
-
-  * Brandon S Allbery [GitHub][geekosaur], IRC: `geekosaur`
-
-  * Brent Yorgey [GitHub][byorgey], IRC: `byorgey`
-
-  * Daniel Wagner [GitHub][dmwit], [Twitter][twitter:dmwit], IRC: `dmwit`
-
-  * Peter Simons [GitHub][peti], [Twitter][twitter:peti]
-
-  * Sibi Prabakaran [GitHub][psibi], [Twitter][twitter:psibi], IRC: `psibi[m]`
-
-  * Tomáš Janoušek [GitHub][liskin], [Twitter][twitter:liskin], IRC: `Liskni_si`
-
-[aavogt]: https://github.com/aavogt
-[geekosaur]: https://github.com/geekosaur
-[byorgey]: https://github.com/byorgey
-[dmwit]: https://github.com/dmwit
-[peti]: https://github.com/peti
-[psibi]: https://github.com/psibi
-[liskin]: https://github.com/liskin
-
-[twitter:dmwit]: https://twitter.com/dmwit13
-[twitter:peti]: https://twitter.com/OriginalPeti
-[twitter:psibi]: https://twitter.com/psibi
-[twitter:liskin]: https://twitter.com/Liskni_si
-
-## Release Procedures
-
-When the time comes to release another version of XMonad and Contrib...
-
-  1. Create a release branch (e.g., `release-0.XX`).
-
-     This will allow you to separate the release process from main
-     development.  Changes you make on this branch will be merged back
-     into `master` as one of the last steps.
-
-  2. Update the version number in the `*.cabal` files and verify
-     dependencies and documentation.  This includes the `tested-with:`
-     field.
-
-  3. Use the [packdeps][] tool to ensure you have the dependency
-     versions correct.  If you need to update the version of a
-     dependency then you should rebuild and retest.
-
-  4. Review documentation files and make sure they are accurate:
-
-     - `README.md`
-     - `CHANGES.md`
-     - and the `example-config.hs` in the `xmonad-testing` repo
-
-  5. Generate the manpage:
-
-     * `cabal configure` with the `-fgeneratemanpage` flag
-     * Build the project
-     * Run the `generatemanpage` tool from the top level of this repo
-     * Review the man page: `man -l man/xmonad.1`
-
-  6. Tag the repository with the release version (e.g., `v0.13`)
-
-  7. Build the project tarballs (`cabal sdist`)
-
-  8. Upload the packages to Hackage (`cabal upload`)
-
-  9. Merge the release branches into `master`
-
-  10. Update the website:
-
-      * Generate and push haddocks with `xmonad-web/gen-docs.sh`
-
-      * Check that `tour.html` and `intro.html` are up to date, and
-        mention all core bindings
-
-  11. Update the topic for the IRC channel (`#xmonad`)
-
-  12. Send the `announce-0.XX.txt` file to:
-
-      - XMonad mailing list
-      - Haskell Cafe
-
-[packdeps]: http://hackage.haskell.org/package/packdeps
-
-## Website and Other Accounts
-
-* The [xmonad twitter] is tended to by [liskin].
-
-* The [xmonad.org] domain is owned by [eyenx] and the website itself is
-  deployed via GitHub Pages.  It can be updated by making a pull request
-  against the [xmonad-web] repository.
-
-[eyenx]: https://github.com/eyenx
-[xmonad-web]: https://github.com/xmonad/xmonad-web/
-[xmonad.org]: https://xmonad.org/
-[xmonad twitter]: https://twitter.com/xmonad
diff --git a/source/Main.hs b/source/Main.hs
deleted file mode 100644
index 28351d0..0000000
--- a/source/Main.hs
+++ /dev/null
@@ -1,20 +0,0 @@
-----------------------------------------------------------------------------
--- |
--- Module      :  Main
--- Copyright   :  (c) Spencer Janssen 2007
--- License     :  BSD3-style (see LICENSE)
---
--- Maintainer  :  sjanssen@cse.unl.edu
--- Stability   :  unstable
--- Portability :  not portable, uses mtl, X11, posix
---
--- xmonad, a minimalist, tiling window manager for X11
---
------------------------------------------------------------------------------
-
-module Main (main) where
-
-import XMonad
-
-main :: IO ()
-main = xmonad def
diff --git a/source/README.md b/source/README.md
deleted file mode 100644
index 6230963..0000000
--- a/source/README.md
+++ /dev/null
@@ -1,132 +0,0 @@
-# xmonad: A Tiling Window Manager
-
-![Stack Tests](https://github.com/xmonad/xmonad/workflows/Stack%20Tests/badge.svg)
-
-[xmonad][] is a tiling window manager for X. Windows are arranged
-automatically to tile the screen without gaps or overlap, maximising
-screen use. Window manager features are accessible from the keyboard:
-a mouse is optional. xmonad is written, configured and extensible in
-Haskell. Custom layout algorithms, key bindings and other extensions
-may be written by the user in config files. Layouts are applied
-dynamically, and different layouts may be used on each
-workspace. Xinerama is fully supported, allowing windows to be tiled
-on several physical screens.
-
-## Quick Start
-
-  * From hackage:
-
-        cabal update
-        cabal install xmonad xmonad-contrib
-
-  * Alternatively, build from source using the following repositories:
-
-    - <https://github.com/xmonad/xmonad>
-
-    - <https://github.com/xmonad/xmonad-contrib>
-
-For the full story, read on.
-
-## Building
-
-Building is quite straightforward, and requires a basic Haskell toolchain.
-On many systems xmonad is available as a binary package in your
-package system (e.g. on Debian or Gentoo). If at all possible, use this
-in preference to a source build, as the dependency resolution will be
-simpler.
-
-For tool-specific guides see [INSTALL.md](./INSTALL.md).
-
-We'll now walk through the complete list of toolchain dependencies.
-
-  * GHC: the Glasgow Haskell Compiler
-
-    You first need a Haskell compiler. Your distribution's package
-    system will have binaries of GHC (the Glasgow Haskell Compiler),
-    the compiler we use, so install that first. If your operating
-    system's package system doesn't provide a binary version of GHC
-    and the `cabal-install` tool, you can install both using the
-    [Haskell Platform][platform].
-
-    It shouldn't be necessary to compile GHC from source -- every common
-    system has a pre-build binary version.  However, if you want to
-    build from source, the following links will be helpful:
-
-      - GHC: <http://haskell.org/ghc/>
-
-      - Cabal: <http://haskell.org/cabal/download.html>
-
-  * X11 libraries:
-
-    Since you're building an X application, you'll need the C X11
-    library headers. On many platforms, these come pre-installed. For
-    others, such as Debian, you can get them from your package manager:
-
-        # for xmonad
-        $ apt-get install libx11-dev libxinerama-dev libxext-dev libxrandr-dev libxss-dev
-
-        # for xmonad-contrib
-        $ apt-get install libxft-dev
-
-Then build and install with:
-
-    $ cabal install
-
-## Running xmonad
-
-If you built XMonad using `cabal` then add:
-
-    exec $HOME/.cabal/bin/xmonad
-
-to the last line of your `.xsession` or `.xinitrc` file.
-
-## Configuring
-
-There is a full tutorial available in [TUTORIAL.md](./TUTORIAL.md).
-Additionally, see the [CONFIG](./CONFIG) document, as well as the
-[example configuration file][example-config].
-
-## XMonadContrib
-
-There are many extensions to xmonad available in the XMonadContrib
-(xmc) library. Examples include an ion3-like tabbed layout, a
-prompt/program launcher, and various other useful modules.
-XMonadContrib is available at:
-
-  * Latest release: <http://hackage.haskell.org/package/xmonad-contrib>
-
-  * Git version: <https://github.com/xmonad/xmonad-contrib>
-
-## Other Useful Programs
-
-A nicer xterm replacement, that supports resizing better:
-
-  * urxvt: <http://software.schmorp.de/pkg/rxvt-unicode.html>
-
-For custom status bars:
-
-  * xmobar: <http://hackage.haskell.org/package/xmobar>
-
-  * taffybar: <https://github.com/travitch/taffybar>
-
-  * dzen: <https://github.com/robm/dzen>
-
-For a program dispatch menu:
-
-  * [XMonad.Prompt.Shell][xmc-prompt-shell]: (from [XMonadContrib][])
-
-  * dmenu: <https://tools.suckless.org/dmenu/>
-
-  * gmrun: (in your package system)
-
-## Authors
-
-  * Spencer Janssen
-  * Don Stewart
-  * Jason Creighton
-
-[xmonad]: http://xmonad.org
-[xmonadcontrib]: https://hackage.haskell.org/package/xmonad-contrib
-[xmc-prompt-shell]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Prompt-Shell.html
-[platform]: http://haskell.org/platform/
-[example-config]: https://github.com/xmonad/xmonad-contrib/blob/master/XMonad/Config/Example.hs
diff --git a/source/STYLE b/source/STYLE
deleted file mode 100644
index e55d75d..0000000
--- a/source/STYLE
+++ /dev/null
@@ -1,22 +0,0 @@
-
-== Coding guidelines for contributing to
-== xmonad and the xmonad contributed extensions
-
-* Comment every top level function (particularly exported functions), and
-  provide a type signature; use Haddock syntax in the comments.
-
-* Follow the coding style of the other modules.
-
-* Code should be compilable with -Wall -Werror -fno-warn-unused-do-bind -fwarn-tabs.
-  There should be no warnings.
-
-* Partial functions should be avoided: the window manager should not
-  crash, so do not call `error` or `undefined`
-
-* Use 4 spaces for indenting.
-
-* Any pure function added to the core should have QuickCheck properties
-  precisely defining its behavior.
-
-* New modules should identify the author, and be submitted under
-  the same license as xmonad (BSD3 license or freer).
diff --git a/source/TUTORIAL.md b/source/TUTORIAL.md
deleted file mode 100644
index f2eef58..0000000
--- a/source/TUTORIAL.md
+++ /dev/null
@@ -1,1276 +0,0 @@
-NOTE: `xmonad 0.16` and `xmonad-contrib 0.17` are obviously not released
-yet.  But don't worry, if you're reading this then you're already a beta
-tester :) Since this guide is supposed to work on older versions of
-xmonad as well this is no problem however; please report any
-incompatibilities you notice and state the version of xmonad and
-xmonad-contrib that you tried to use.  If you use the git versions of
-xmonad and xmonad-contrib, you should be able to follow everything just
-fine.
-
-# XMonad Configuration Tutorial
-
-We're going to take you, step-by-step, through the process of
-configuring xmonad, setting up [xmobar] as a status bar, configuring
-[trayer-srg] as a tray, and making it all play nicely together.
-
-We assume that you have read the [xmonad guided tour] already.  It is a
-bit dated at this point but, because xmonad is stable, the guide should
-still give you a good overview of the most basic functionality.
-
-Before we begin, here are two screenshots of the kind of desktop we will
-be creating together.  In particular, a useful layout we'll conjure into
-being—the three columns layout from [XMonad.Layout.ThreeColumns] with
-the ability to magnify stack windows via [XMonad.Layout.Magnifier]:
-
-<p>
-<img alt="blank desktop" src="https://user-images.githubusercontent.com/50166980/111586872-c0eb0e00-87c1-11eb-9129-c2781bbbf227.png" width="550">
-<img alt="blank desktop" src="https://user-images.githubusercontent.com/50166980/111586885-c47e9500-87c1-11eb-8e8e-83d4d33c4c8d.png" width="550">
-</p>
-
-So let's get started!
-
-## Preliminaries
-
-First you'll want to install xmonad.  You can either do this with your
-system's package manager or via `stack`/`cabal`.  The latter may be
-necessary if your distribution does not package `xmonad` and
-`xmonad-contrib` (or packages a version that's very old) or you want to
-use the git versions instead of a tagged release.  You can find
-instructions for how to do this in [INSTALL.md].
-
-One more word of warning: if you are on a distribution that installs
-every Haskell package dynamically linked—thus essentially breaking
-Haskell—(Arch Linux being a prominent example) then we would highly
-recommend installing via `stack` or `cabal` as instructed in
-[INSTALL.md].  If you still want to install xmonad via your system's
-package manager, you will need to `xmonad --recompile` _every time_ a
-Haskell dependency is updated—else xmonad may fail to start when you
-want to log in!
-
-We're going to assume xmonad version `0.16` and xmonad-contrib version
-`0.17` here, though most of these steps should work with older versions
-as well.  When we get to the relevant parts, will point you to
-alternatives that work with at least xmonad version `0.15` and
-xmonad-contrib version `0.16`.  This will usually be accompanied by a
-big "_IF YOU ARE ON A VERSION `< 0.17`_", so don't worry about missing
-it!
-
-Throughout the tutorial we will use, for keybindings, a syntax very akin
-to the [GNU Emacs conventions] for the same thing—so `C-x` means "hold
-down the control key and then press the `x` key".  One exception is that
-in our case `M` will not necessarily mean Alt (also called `Meta`), but
-"your modifier key"; this is Alt by default, although many people map it
-to Super instead (I will show you how to do this below).
-
-This guide should work for any GNU/Linux distribution and even for BSD
-folks.  Because debian-based distributions are still rather popular, we
-will give you the `apt` commands when it comes to installing software.
-If you use another distribution, just substitute the appropriate
-commands for your system.
-
-To install xmonad, as well as some utilities, via `apt` you can just run
-
-``` shell
-  apt-get install xmonad libghc-xmonad-contrib-dev libghc-xmonad-dev suckless-tools
-```
-
-This installs xmonad itself, everything you need to configure it, and
-`suckless-tools`, which provides the application launcher `dmenu`.  This
-program is used as the default application launcher on `M-p`.
-
-If you are installing xmonad with `stack` or `cabal`, remember to _not_
-install `xmonad` and its libraries here!
-
-For the remainder of this document, we will assume that you are running
-a live xmonad session in some capacity.  If you have set up your
-`~/.xinitrc` as directed in the xmonad guided tour, you should be good
-to go!  If not, just smack an `exec xmonad` at the bottom of that file.
-
-## Installing Xmobar
-
-What we need to do now—provided we want to use a bar at all—is to
-install [xmobar].  If you visit [xmobar's `Installation` section] you
-will find everything from how to install it with your system's package
-manager all the way to how to compile it yourself.
-
-We will show you how we make these programs talk to each other a bit
-later on.  For now, let's start to explore how we can customize this
-window manager of ours!
-
-## Customizing XMonad
-
-Xmonad's configuration file is written in [Haskell]—but don't worry, we
-won't assume that you know the language for the purposes of this
-tutorial.  The configuration file can either reside within
-`$XDG_CONFIG_HOME/xmonad`, `~/.xmonad`, or `$XMONAD_CONFIG_DIR`; see
-`man 1 xmonad` for further details (the likes of `$XDG_CONFIG_HOME` is
-called a [shell variable]).  Let's use `$XDG_CONFIG_HOME/xmonad` for the
-purposes of this tutorial, which resolves to `~/.config/xmonad` on most
-systems—the `~/.config` directory is also the place where things will
-default to should `$XDG_CONFIG_HOME` not be set.
-
-First, we need to create `~/.config/xmonad` and, in this directory, a
-file called `xmonad.hs`.  We'll start off with importing some of the
-utility modules we will use.  At the very top of the file, write
-
-``` haskell
-  import XMonad
-
-  import XMonad.Util.EZConfig
-  import XMonad.Util.Ungrab
-```
-
-All of these imports are _unqualified_, meaning we are importing all of
-the functions in the respective modules.  For configuration files this
-is what most people want.  If you prefer to import things explicitly
-you can do so by adding the necessary function to the `import` statement
-in parentheses.  For example
-
-``` haskell
-  import XMonad.Util.EZConfig (additionalKeysP)
-```
-
-For the purposes of this tutorial, we will be importing everything
-coming from xmonad directly unqualified.
-
-Next, a basic configuration—which is the same as the default config—is
-this:
-
-``` haskell
-  main :: IO ()
-  main = xmonad def
-```
-
-In case you're interested in what this default configuration actually
-looks like, you can find it under [XMonad.Config].  Do note that it is
-_not_ advised to copy that file and use it as the basis of your
-configuration, as you won't notice when a default changes!
-
-You should be able to save the above file, with the import lines plus
-the other two and then press `M-q` to load it up.  Another way to
-validate your `xmonad.hs` is to simply run `xmonad --recompile` in a
-terminal.  You'll see errors (in an `xmessage` popup, so make sure that
-is installed on your system) if it's bad, and nothing if it's good.
-It's not the end of the world if you restart xmonad and get errors, as
-you will still be on your old, working, configuration and have all the
-time in the world to fix your errors before trying again!
-
-Let's add a few additional things.  The default modifier key is Alt,
-which is also used in Emacs.  Sometimes Emacs and xmonad want to use the
-same key for different actions.  Rather than remap every common key,
-many people just change Mod to be the Super key—the one between Ctrl and
-Alt on most keyboards.  We can do this by changing the above `main`
-function in the following way:
-
-``` haskell
-  main :: IO ()
-  main = xmonad $ def
-      { modMask = mod4Mask  -- Rebind Mod to the Super key
-      }
-```
-
-The two dashes signify a comment to the end of the line.  Notice the
-curly braces; these stand for a [record update] in Haskell (records are
-sometimes called "structs" in C-like languages).  What it means is "take
-`def` and change its `modMask` field to the thing **I** want".  Taking a
-record that already has some defaults set and modifying only the fields
-one cares about is a pattern that is often used within xmonad, so it's
-worth pausing for a bit here to really take this new syntax in.
-
-Don't mind the dollar sign too much; it essentially serves to split
-apart the `xmonad` function and the `def { .. }` record update visually.
-Haskell people really don't like writing parentheses, so they sometimes
-use a dollar sign instead.  For us this is particularly nice, because
-now we don't have to awkwardly write
-
-``` haskell
-  main :: IO ()
-  main = xmonad (def
-      { modMask = mod4Mask  -- Rebind Mod to the Super key
-      })
-```
-
-This will be especially handy when adding more combinators; something we
-will talk about later on.  The dollar sign is superfluous in this
-example, but that will change soon enough so it's worth introducing it
-here as well.
-
-What if we wanted to add other keybindings?  Say you also want to bind
-`M-S-z` to lock your screen with the screensaver, `M-S-=` to take a
-snapshot of one window, and `M-]` to spawn Firefox.  This can be
-achieved with the `additionalKeysP` function from the
-[XMonad.Util.EZConfig] module—luckily we already have it imported!  Our
-config file, starting with `main`, now looks like:
-
-``` haskell
-  main :: IO ()
-  main = xmonad $ def
-      { modMask = mod4Mask  -- Rebind Mod to the Super key
-      }
-    `additionalKeysP`
-      [ ("M-S-z", spawn "xscreensaver-command -lock")
-      , ("M-S-=", unGrab *> spawn "scrot -s"        )
-      , ("M-]"  , spawn "firefox"                   )
-      ]
-```
-
-That syntax look familiar?
-
-You can find the names for special keys, like `Print` or the `F`-keys,
-in the [XMonad.Util.EZConfig] documentation.
-
-We will cover setting up the screensaver later in this tutorial.
-
-The `unGrab` before running the `scrot -s` command tells xmonad to
-release its keyboard grab before `scrot -s` tries to grab the keyboard
-itself.  The little `*>` operator essentially just sequences two
-functions, i.e. `f *> g` says
-
-  > first do `f` and then, discarding any result that `f` may have given
-  > me, do `g`.
-
-Do note that you may need to install `scrot` if you don't have it on
-your system already.
-
-What if we wanted to augment our xmonad experience just a little more?
-We already have `xmonad-contrib`, which means endless possibilities!
-Say we want to add a three column layout to our layouts and also magnify
-focused stack windows, making it more useful on smaller screens.
-
-We start by visiting the documentation for [XMonad.Layout.ThreeColumns].
-The very first sentence of the `Usage` section tells us exactly what we
-want to start with:
-
-  > You can use this module with the following in your `~/.xmonad/xmonad.hs`:
-  >
-  > `import XMonad.Layout.ThreeColumns`
-
-Ignoring the part about where exactly our `xmonad.hs` is (we have opted
-to put it into `~/.config/xmonad/xmonad.hs`, remember?) we can follow
-that documentation word for word.  Let's add
-
-``` haskell
-  import XMonad.Layout.ThreeColumns
-```
-
-to the top of our configuration file.  Most modules have a lot of
-accompanying text and usage examples in them—so while the type
-signatures may seem scary, don't be afraid to look up the
-[xmonad-contrib documentation] on hackage!
-
-Next we just need to tell xmonad that we want to use that particular
-layout.  To do this, there is the `layoutHook`.  Let's use the default
-layout as a base:
-
-``` haskell
-  myLayout = tiled ||| Mirror tiled ||| Full
-    where
-      tiled   = Tall nmaster delta ratio
-      nmaster = 1      -- Default number of windows in the master pane
-      ratio   = 1/2    -- Default proportion of screen occupied by master pane
-      delta   = 3/100  -- Percent of screen to increment by when resizing panes
-```
-
-The so-called `where`-clause above simply consists of local declarations
-that might clutter things up where they all declared at the top-level
-like this
-
-``` haskell
-  myLayout = Tall 1 (3/100) (1/2) ||| Mirror (Tall 1 (3/100) (1/2)) ||| Full
-```
-
-It also gives us the chance of documenting what the individual numbers
-mean!
-
-Now we can add the layout according to the [XMonad.Layout.ThreeColumns]
-documentation.  At this point, we would encourage you to try this
-yourself with just the docs guiding you.  If you can't do it, don't
-worry; it'll come with time!
-
-We can, for example, add the additional layout like this:
-
-``` haskell
-  myLayout = tiled ||| Mirror tiled ||| Full ||| ThreeColMid 1 (3/100) (1/2)
-    where
-      tiled   = Tall nmaster delta ratio
-      nmaster = 1      -- Default number of windows in the master pane
-      ratio   = 1/2    -- Default proportion of screen occupied by master pane
-      delta   = 3/100  -- Percent of screen to increment by when resizing panes
-```
-
-or even, because the numbers happen to line up, like this:
-
-``` haskell
-  myLayout = tiled ||| Mirror tiled ||| Full ||| threeCol
-    where
-      threeCol = ThreeColMid nmaster delta ratio
-      tiled    = Tall nmaster delta ratio
-      nmaster  = 1      -- Default number of windows in the master pane
-      ratio    = 1/2    -- Default proportion of screen occupied by master pane
-      delta    = 3/100  -- Percent of screen to increment by when resizing panes
-```
-
-Now we just need to tell xmonad that we want to use this modified
-`layoutHook` instead of the default.  Again, try to reason this out for
-yourself by just looking at the documentation.  Ready?  Here we go:
-
-``` haskell
-  main :: IO ()
-  main = xmonad $ def
-      { modMask    = mod4Mask  -- Rebind Mod to the Super key
-      , layoutHook = myLayout  -- Use custom layouts
-      }
-    `additionalKeysP`
-      [ ("M-S-z", spawn "xscreensaver-command -lock")
-      , ("M-S-=", unGrab *> spawn "scrot -s"        )
-      , ("M-]"  , spawn "firefox"                   )
-      ]
-```
-
-But we also wanted to add magnification, right?  Luckily for us, there's
-a module for that as well!  It's called [XMonad.Layout.Magnifier].
-Again, take a look at the documentation before reading on—see if you can
-reason out what to do by yourself.  Let's pick the `magnifiercz'`
-modifier from the library; it magnifies a window by a given amount, but
-only if it's a stack window.  Add it to your three column layout thusly:
-
-``` haskell
-  myLayout = tiled ||| Mirror tiled ||| Full ||| threeCol
-    where
-      threeCol = magnifiercz' 1.3 $ ThreeColMid nmaster delta ratio
-      tiled    = Tall nmaster delta ratio
-      nmaster  = 1      -- Default number of windows in the master pane
-      ratio    = 1/2    -- Default proportion of screen occupied by master pane
-      delta    = 3/100  -- Percent of screen to increment by when resizing panes
-```
-
-Don't forget to import the module!
-
-You can think of the `$` here as putting everything into parentheses
-from the dollar to the end of the line.  If you don't like that you can
-also write
-
-``` haskell
-  threeCol = magnifiercz' 1.3 (ThreeColMid nmaster delta ratio)
-```
-
-instead.
-
-That's it!  Now we have a perfectly functioning three column layout with
-a magnified stack.  If you compare this with the starting screenshots,
-you will see that that's exactly the behaviour we wanted to achieve!
-
-A last thing that's worth knowing about are so-called "combinators"—at
-least we call them that, we can't tell you what to do.  These are
-functions that compose with the `xmonad` function and add a lot of hooks
-and other things for you (trying to achieve a specific goal), so you
-don't have to do all the manual work yourself.  For example, xmonad—by
-default—is only [ICCCM] compliant.  Nowadays, however, a lot of programs
-(including many compositors) expect the window manager to _also_ be
-[EWMH] compliant.  So let's save ourselves a lot of future trouble and
-add that to xmonad straight away!
-
-This functionality is to be found in the [XMonad.Hooks.EwmhDesktops]
-module, so let's import it:
-
-``` haskell
-  import XMonad.Hooks.EwmhDesktops
-```
-
-We might also consider using the `ewmhFullscreen` combinator.  By
-default, a "fullscreened" application is still bound by its window
-dimensions; this means that if the window occupies half of the screen
-before it was fullscreened, it will also do so afterwards.  Some people
-really like this behaviour, as applications thinking they're in
-fullscreen mode tend to remove a lot of clutter (looking at you,
-Firefox).  However, because a lot of people explicitly do not want this
-effect (and some applications, like chromium, will misbehave and need
-some [Hacks] to make this work), we will also add the relevant function
-to get "proper" fullscreen behaviour here.
-
-_IF YOU ARE ON A VERSION `< 0.17`_: The `ewmhFullscreen` function does
-  not exist in these versions.  Instead of it, you can try to add
-  `fullscreenEventHook` to your `handleEventHook` to achieve similar
-  functionality (how to do this is explained in the documentation of
-  [XMonad.Hooks.EwmhDesktops]).
-
-To use the two combinators, we compose them with the `xmonad` function
-in the following way:
-
-``` haskell
-  main :: IO ()
-  main = xmonad $ ewmhFullscreen $ ewmh $ def
-      { modMask    = mod4Mask  -- Rebind Mod to the Super key
-      , layoutHook = myLayout  -- Use custom layouts
-      }
-    `additionalKeysP`
-      [ ("M-S-z", spawn "xscreensaver-command -lock")
-      , ("M-S-=", unGrab *> spawn "scrot -s"        )
-      , ("M-]"  , spawn "firefox"                   )
-      ]
-```
-
-Do mind the order of the two combinators—by a particularly awkward set
-of circumstances, they do not commute!
-
-This `main` function is getting pretty crowded now, so let's refactor it
-a little bit.  A good way to do this is to split the config part into
-one function and the "main and all the combinators" part into another.
-Let's call the config part `myConfig` for... obvious reasons.  It would
-look like this:
-
-``` haskell
-  main :: IO ()
-  main = xmonad $ ewmhFullscreen $ ewmh $ myConfig
-
-  myConfig = def
-      { modMask    = mod4Mask  -- Rebind Mod to the Super key
-      , layoutHook = myLayout  -- Use custom layouts
-      }
-    `additionalKeysP`
-      [ ("M-S-z", spawn "xscreensaver-command -lock")
-      , ("M-S-=", unGrab *> spawn "scrot -s"        )
-      , ("M-]"  , spawn "firefox"                   )
-      ]
-```
-
-Much better!
-
-## Make XMonad and Xmobar Talk to Each Other
-
-Onto the main dish.  First, we have to import the necessary modules.
-Add the following to your list of imports:
-
-``` haskell
-  import XMonad.Hooks.DynamicLog
-  import XMonad.Hooks.StatusBar
-  import XMonad.Hooks.StatusBar.PP
-```
-
-_IF YOU ARE ON A VERSION `< 0.17`_: The `XMonad.Hooks.StatusBar` and
-  `XMonad.Hooks.StatusBar.PP` modules don't exist yet.  You can find
-  everything you need in the `XMonad.Hooks.DynamicLog` module, so remove
-  these two imports.
-
-Replace your `main` function above with:
-
-``` haskell
-  main :: IO ()
-  main = xmonad $ ewmhFullscreen $ ewmh $ xmobarProp $ myConfig
-```
-
-_IF YOU ARE ON A VERSION `< 0.17`_: The `xmobarProp` function does not
-  exist in these versions.  Instead of it, use `xmobar` via
-  `main = xmonad . ewmhFullscreen . ewmh =<< xmobar myConfig`
-  and carefully read the part about pipes later on (`xmobar` uses pipes
-  to make xmobar talk to xmonad).
-
-As a quick side-note, we could have also written
-
-``` haskell
-  main :: IO ()
-  main = xmonad . ewmhFullscreen . ewmh . xmobarProp $ myConfig
-```
-
-Notice how `$` became `.`!  The dot operator `(.)` in Haskell means
-function composition and is read from right to left.  What this means in
-this specific case is essentially the following:
-
-  > take the four functions `xmonad`, `ewmhFullscreen`, `ewmh`, and
-  > `xmobarProp` and give me the big new function
-  > `xmonad . ewmhFullscreen . ewmh . xmobarProp` that first executes
-  > `xmobarProp`, then `ewmh`, then `ewmhFullscreen`, and finally
-  > `xmonad`.  Then give it `myConfig` as its argument so it can do its
-  > thing.
-
-This should strike you as nothing more than a syntactical quirk, at
-least in this case.  And indeed, since `($)` is just function
-application there is a very nice relationship between `(.)` and `($)`.
-This may be more obvious if we write everything with parentheses and
-apply the `(.)` operator (because we do have an argument):
-
-``` haskell
-  -- ($) version
-  main = xmonad $ ewmhFullscreen $ ewmh $ xmobarProp $ myConfig
-  -- ($) version with parentheses
-  main = xmonad (ewmhFullscreen (ewmh (xmobarProp (myConfig))))
-
-  -- (.) version with parentheses
-  main = (xmonad . ewmhFullscreen . ewmh . xmobarProp) (myConfig)
-  -- xmobarProp applied
-  main = (xmonad . ewmhFullscreen . ewmh) (xmobarProp (myConfig))
-  -- ewmh applied
-  main = (xmonad . ewmhFullscreen) (ewmh (xmobarProp (myConfig)))
-  -- xmonad and ewmhFullscreen applied
-  main = (xmonad (ewmhFullscreen (ewmh (xmobarProp (myConfig))))
-```
-
-It's the same!  This is special to the interplay with `(.)` and `($)`
-though; if you're on an older version of xmonad and xmonad-contrib and
-use `xmobar` instead of `xmobarProp`, then you _have_ to write
-
-``` haskell
-  main = xmonad . ewmhFullscreen . ewmh =<< xmobar myConfig
-```
-
-and this is _not_ equivalent to
-
-``` haskell
-  main = xmonad (ewmhFullscreen (ewmh =<< xmobar myConfig))
-```
-
-Consult a Haskell book of your choice for why this is the case.
-
-Back to our actual goal: customizing xmonad.  What the code we've
-written does is take our tweaked default configuration `myConfig` and
-add the support we need to make xmobar our status bar.  Do note that you
-will also need to add the `XMonadLog` plugin to your xmobar
-configuration; we will do this together below, so don't sweat it for
-now.
-
-To understand why this is necessary, let's talk a little bit about how
-xmonad and xmobar fit together.  You can make them talk to each other in
-several different ways.
-
-By default, xmobar accepts input on its stdin, which it can display at
-an arbitrary position on the screen.  We want xmonad to send xmobar the
-stuff that you can see at the upper left of the starting screenshots:
-information about available workspaces, current layout, and open
-windows.  Naïvely, we can achieve this by spawning a pipe and letting
-xmonad feed the relevant information to that pipe.  The problem with
-that approach is that when the pipe is not being read and gets full,
-xmonad will freeze!
-
-It is thus much better to switch over to property based logging, where
-we are writing to an X11 property and having xmobar read that; no danger
-when things are not being read!  For this reason we have to use
-`XMonadLog` instead of `StdinReader` in our xmobar.  There's also an
-`UnsafeXMonadLog` available, should you want to send actions to xmobar
-(this is useful, for example, for [XMonad.Util.ClickableWorkspaces],
-which is a new feature in `0.17`).
-
-_IF YOU ARE ON A VERSION `< 0.17`_: As discussed above, the `xmobar`
-  function uses pipes, so you actually do want to use the `StdinReader`.
-  Simply replace _all_ occurences of `XMonadLog` with `StdinReader`
-  below (don't forget the template!)
-
-## Configuring Xmobar
-
-Now, before this will work, we have to configure xmobar.  Here's a nice
-starting point.  Be aware that, while Haskell syntax highlighting is
-used here to make this pretty, xmobar's config is _not_ a Haskell file
-and thus can't execute arbitrary code—at least not by default.  If you
-do want to configure xmobar in Haskell there is a note about that at the
-end of this section.
-
-``` haskell
-  Config { overrideRedirect = False
-         , font     = "xft:iosevka-9"
-         , bgColor  = "#5f5f5f"
-         , fgColor  = "#f8f8f2"
-         , position = TopW L 90
-         , commands = [ Run Weather "EGPF"
-                          [ "--template", "<weather> <tempC>°C"
-                          , "-L", "0"
-                          , "-H", "25"
-                          , "--low"   , "lightblue"
-                          , "--normal", "#f8f8f2"
-                          , "--high"  , "red"
-                          ] 36000
-                      , Run Cpu
-                          [ "-L", "3"
-                          , "-H", "50"
-                          , "--high"  , "red"
-                          , "--normal", "green"
-                          ] 10
-                      , Run Alsa "default" "Master"
-                          [ "--template", "<volumestatus>"
-                          , "--suffix"  , "True"
-                          , "--"
-                          , "--on", ""
-                          ]
-                      , Run Memory ["--template", "Mem: <usedratio>%"] 10
-                      , Run Swap [] 10
-                      , Run Date "%a %Y-%m-%d <fc=#8be9fd>%H:%M</fc>" "date" 10
-                      , Run XMonadLog
-                      ]
-         , sepChar  = "%"
-         , alignSep = "}{"
-         , template = "%XMonadLog% }{ %alsa:default:Master% | %cpu% | %memory% * %swap% | %EGPF% | %date% "
-         }
-```
-
-First, we set the font to use for the bar, as well as the colors.  The
-position options are documented well on the [xmobar home page] or,
-alternatively, in the [quick-start.org] on GitHub.  The particular
-option of `TopW L 90` says to put the bar in the upper left of the
-screen, and make it consume 90% of the width of the screen (we need to
-leave a little bit of space for `trayer-srg`).  If you're up for it—and
-this really requires more shell-scripting than Haskell knowledge—you can
-also try to seamlessly embed trayer into xmobar by using
-[trayer-padding-icon.sh] and following the advice given in that thread.
-
-In the commands list you, well, define commands.  Commands are the
-pieces that generate the content to be displayed in your bar.  These
-will later be combined together in the `template`.  Here, we have
-defined a weather widget, a CPU widget, memory and swap widgets, a date,
-a volume indicator, and of course the data from xmonad via `XMonadLog`.
-
-The `EGPF` in the weather command is a particular station.  Replace both
-(!) occurences of it with your choice of ICAO weather stations.  For a
-list of ICAO codes you can visit the relevant [Wikipedia page].  You can
-of course monitor more than one if you like; see xmobar's [weather
-monitor] documentation for further details.
-
-The `template` then combines everything together.  The `alignSep`
-variable controls the alignment of all of the monitors.  Stuff to be
-left-justified goes before the `}` character, things to be centered
-after it, and things to be right justified after `{`.  We have nothing
-centered so there is nothing in-between them.
-
-Save the file to `~/.xmobarrc`.  Now press `M-q` to reload xmonad; you
-should now see xmobar with your new configuration!  Please note that, at
-this point, the config _has_ to reside in `~/.xmobarrc`.  We will,
-however, discuss how to change this soon.
-
-It is also possible to completely configure xmobar in Haskell, just like
-xmonad.  If you want to know more about that, you can check out the
-[xmobar.hs] example in the official documentation.  For a more
-complicated example, you can also check out [jao's xmobar.hs] (he's the
-current maintainer of xmobar).
-
-## Changing What XMonad Sends to Xmobar
-
-Now that the xmobar side of the picture looks nice, what about the stuff
-that xmonad sends to xmobar?  It would be nice to visually match these
-two.  Sadly, this is not quite possible with our `xmobarProp` function;
-however, looking at the implementation of the function (or, indeed, the
-top-level documentation of the module!) should give us some ideas for
-how to proceed:
-
-``` haskell
-  xmobarProp config =
-    withEasySB (statusBarProp "xmobar" (pure xmobarPP)) toggleStrutsKey config
-```
-
-This means that `xmobarProp` just calls the functions `withEasySB` and
-`statusBarProp` with some arguments; crucially for us, notice the
-`xmobarPP`.  In this context "PP" stands for "pretty-printer"—exactly
-what we want to modify!
-
-Let's copy the implementation over into our main function:
-
-``` haskell
-  main :: IO ()
-  main = xmonad
-       . ewmhFullscreen
-       . ewmh
-       . withEasySB (statusBarProp "xmobar" (pure def)) defToggleStrutsKey
-       $ myConfig
-```
-
-_IF YOU ARE ON A VERSION `< 0.17`_: `xmobar` has a similar definition,
-  relying on `statusBar` alone: `xmobar = statusBar "xmobar" xmobarPP
-    toggleStrutsKey`.  Sadly, the `defToggleStrutsKey` function is not yet
-  exported, so you will have to define it yourself:
-
-  ``` haskell
-    main :: IO ()
-    main = xmonad
-         . ewmhFullscreen
-         . ewmh
-       =<< statusBar "xmobar" def toggleStrutsKey myConfig
-      where
-        toggleStrutsKey :: XConfig Layout -> (KeyMask, KeySym)
-        toggleStrutsKey XConfig{ modMask = m } = (m, xK_b)
-  ```
-
-The `defToggleStrutsKey` here is just the key with which you can toggle
-the bar; it is bound to `M-b`.  If you want to change this, you can also
-define your own:
-
-``` haskell
-  main :: IO ()
-  main = xmonad
-       . ewmhFullscreen
-       . ewmh
-       . withEasySB (statusBarProp "xmobar" (pure def)) toggleStrutsKey
-       $ myConfig
-    where
-      toggleStrutsKey :: XConfig Layout -> (KeyMask, KeySym)
-      toggleStrutsKey XConfig{ modMask = m } = (m, xK_b)
-```
-
-Feel free to change the binding by modifying the `(m, xK_b)` tuple to
-your liking.
-
-If you want your xmobar configuration file to reside somewhere else than
-`~/.xmobarrc`, you can now simply give the file to xmobar as a
-positional argument!  For example:
-
-``` haskell
-  main :: IO ()
-  main = xmonad
-       . ewmhFullscreen
-       . ewmh
-       . withEasySB (statusBarProp "xmobar ~/.config/xmobar/xmobarrc" (pure def)) defToggleStrutsKey
-       $ myConfig
-```
-
-Back to controlling what exactly we send to xmobar.  The `def`
-pretty-printer just gives us the same result that the internal
-`xmobarPP` would have given us.  Let's try to build something on top of
-this.  To prepare, we can first create a new function `myXmobarPP` with
-the default configuration:
-
-``` haskell
-  myXmobarPP :: PP
-  myXmobarPP = def
-```
-
-and then plug that into our main function:
-
-``` haskell
-  main :: IO ()
-  main = xmonad
-       . ewmhFullscreen
-       . ewmh
-       . withEasySB (statusBarProp "xmobar" (pure myXmobarPP)) defToggleStrutsKey
-       $ myConfig
-```
-
-As before, we now change things by modifying that `def` record until we
-find something that we like.  First, for some functionality that we need
-further down we need to import one more module:
-
-``` haskell
-  import XMonad.Util.Loggers
-```
-
-Now we are finally ready to make things pretty.  There are _a lot_ of
-options for the [PP record]; I'd advise you to read through all of them
-now, so you don't get lost!
-
-``` haskell
-  myXmobarPP :: PP
-  myXmobarPP = def
-      { ppSep             = magenta " • "
-      , ppTitleSanitize   = xmobarStrip
-      , ppCurrent         = wrap " " "" . xmobarBorder "Top" "#8be9fd" 2
-      , ppHidden          = white . wrap " " ""
-      , ppHiddenNoWindows = lowWhite . wrap " " ""
-      , ppUrgent          = red . wrap (yellow "!") (yellow "!")
-      , ppOrder           = \[ws, l, _, wins] -> [ws, l, wins]
-      , ppExtras          = [logTitles formatFocused formatUnfocused]
-      }
-    where
-      formatFocused   = wrap (white    "[") (white    "]") . magenta . ppWindow
-      formatUnfocused = wrap (lowWhite "[") (lowWhite "]") . blue    . ppWindow
-
-      -- | Windows should have *some* title, which should not not exceed a
-      -- sane length.
-      ppWindow :: String -> String
-      ppWindow = xmobarRaw . (\w -> if null w then "untitled" else w) . shorten 30
-
-      blue, lowWhite, magenta, red, white, yellow :: String -> String
-      magenta  = xmobarColor "#ff79c6" ""
-      blue     = xmobarColor "#bd93f9" ""
-      white    = xmobarColor "#f8f8f2" ""
-      yellow   = xmobarColor "#f1fa8c" ""
-      red      = xmobarColor "#ff5555" ""
-      lowWhite = xmobarColor "#bbbbbb" ""
-```
-
-_IF YOU ARE ON A VERSION `< 0.17`_: Both `logTitles` and `xmobarBorder`
-  are not available yet, so you will have to remove them.  As an
-  alternative to `xmobarBorder`, a common way to "mark" the currently
-  focused workspace is by using brackets; you can try something like
-  `ppCurrent = wrap (blue "[") (blue "]")` and see if you like it.  Also
-  read the bit about `ppOrder` further down!
-
-That's a lot!  But don't worry, take a deep breath and remind yourself
-of what you read above in the documentation of the [PP record].  Even if
-you haven't read the documentation yet, most of the fields should be
-pretty self-explanatory; `ppTitle` formats the title of the currently
-focused window, `ppCurrent` formats the currently focused workspace,
-`ppHidden` is for the hidden workspaces that have windows on them, etc.
-The rest is just deciding on some pretty colours and formatting things
-just how we like it.
-
-An important thing to talk about may be `ppOrder`.  Quoting from its
-documentation:
-
-  > By default, this function receives a list with three formatted
-  > strings, representing the workspaces, the layout, and the current
-  > window title, respectively. If you have specified any extra loggers
-  > in ppExtras, their output will also be appended to the list.
-
-So the first three argument of the list (`ws`, `l`, and `_` in our case,
-where the `_` just means we want to ignore that argument and not give it
-a name) are the workspaces to show, the currently active layout, and the
-title of the focused window.  The last element—`wins`—is what we gave to
-`ppExtras`; if you added more loggers to that then you would have to add
-more items to the list, like this:
-
-``` haskell
-  ppOrder = \[ws, l, _, wins, more, more2] -> [ws, l, wins, more, more2]
-```
-
-However, many people want to show _all_ window titles on the currently
-focused workspace instead.  For that, one can use `logTitles` from
-[XMonad.Util.Loggers] (remember that module we just imported?).
-However, `logTitles` logs _all_ titles.  Naturally, we don't want to
-show the focused window twice and so we suppress it here by ignoring the
-third argument of `ppOrder` and not returning it.  The functions
-`formatFocused` and `formatUnfocused` should be relatively self
-explanitory—they decide how to format the focused resp. unfocused
-windows.
-
-By the way, the `\ ... ->` syntax in there is Haskell's way to express a
-[lambda abstraction] (or anonymous function, as some languages call it).
-All of the arguments of the function come directly after the `\` and
-before the `->`; in our case, this is a list with exactly four elements
-in it.  Basically, it's a nice way to write a function inline and not
-having to define it inside e.g. a `where` clause.  The above could have
-also be written as
-
-``` haskell
-  myXmobarPP :: PP
-  myXmobarPP = def
-      { -- stuff here
-      , ppOrder = myOrder
-        -- more stuff here
-      }
-    where
-      myOrder [ws, l, _, wins] = [ws, l, wins]
-      -- more stuff here
-```
-
-If you're unsure of the number of elements that your `ppOrder` will
-take, you can also specify the list like this:
-
-``` haskell
-  ppOrder = \(ws : l : _ : wins : _) -> [ws, l, wins]
-```
-
-This says that it is a list of _at least_ four elements (`ws`, `l`, the
-unnamed argument, and `wins`), but that afterwards everything is
-possible.
-
-This config is really quite complicated.  If this is too much for you,
-you can also really just start with the blank
-
-``` haskell
-  myXmobarPP :: PP
-  myXmobarPP = def
-```
-
-then add something, reload xmonad, see how things change and whether you
-like them.  If not, remove that part and try something else.  If you do,
-try to understand how that particular piece of code works.  You'll have
-something approaching the above that you fully understand in no time!
-
-## Configuring Related Utilities
-
-So now you've got a status bar and xmonad.  We still need a few more
-things: a screensaver, a tray for our apps that have tray icons, a way
-to set our desktop background, and the like.
-
-For this, we will need a few pieces of software.
-
-``` shell
-  apt-get install trayer xscreensaver
-```
-
-If you want a network applet, something to set your desktop background,
-and a power-manager:
-
-``` shell
-  apt-get install nm-applet feh xfce4-power-manager
-```
-
-First, configure xscreensaver how you like it with the
-`xscreensaver-demo` command.  Now, we will set these things up in
-`~/.xinitrc` (we could also do most of this in xmonad's `startupHook`,
-but `~/.xinitrc` is perhaps more standard).  If you want to use xmonad
-with a desktop environment, see [Basic Desktop Environment Integration]
-for how to do this.
-
-Your `~/.xinitrc` may wind up looking like this:
-
-``` shell
-  #!/bin/sh
-
-  # [... default stuff that your distro may throw in here ...] #
-
-  # Set up an icon tray
-  trayer --edge top --align right --SetDockType true --SetPartialStrut true \
-   --expand true --width 10 --transparent true --tint 0x5f5f5f --height 18 &
-
-  # Set the default X cursor to the usual pointer
-  xsetroot -cursor_name left_ptr
-
-  # Set a nice background
-  feh --bg-fill --no-fehbg ~/.wallpapers/haskell-red-noise.png
-
-  # Fire up screensaver
-  xscreensaver -no-splash &
-
-  # Power Management
-  xfce4-power-manager &
-
-  if [ -x /usr/bin/nm-applet ] ; then
-     nm-applet --sm-disable &
-  fi
-
-  exec xmonad
-```
-
-Notice the call to `trayer` above.  The options tell it to go on the top
-right, with a default width of 10% of the screen (to nicely match up
-with xmobar, which we set to a width of 90% of the screen).  We give it
-a color and a height.
-
-Then we fire up the rest of the programs that interest us.
-
-Finally, we start xmonad.
-
-<img alt="blank desktop" src="https://user-images.githubusercontent.com/50166980/111529498-84d49080-8762-11eb-9e81-c15dd844b0a9.png" width="660">
-
-Mission accomplished!
-
-Of course substitute the wallpaper for one of your own.  If you like the
-one used above, you can find it [here](https://i.imgur.com/9MQHuZx.png).
-
-## Final Touches
-
-There may be some programs that you don't want xmonad to tile.  The
-classic example here is the [GNU Image Manipulation Program]; it pops up
-all sorts of new windows all the time, and they work best at defined
-sizes.  It makes sense for xmonad to float these kinds of windows by
-default.
-
-This kind of behaviour can be achieved via the `manageHook`, which runs
-when windows are created.  There are several functions to help you match
-on a certain window in [XMonad.ManageHook].  For example, suppose we'd
-want to match on the class name of the application.  With the
-application open, open another terminal and invoke the `xprop` command.
-Then click on the application that you would like to know the properties
-of.  In our case you should see (among other things)
-
-``` shell
-  WM_CLASS(STRING) = "gimp", "Gimp"
-```
-
-The second string in `WM_CLASS` is the class name, which we can access
-with `className` from [XMonad.ManageHook].  The first one is usually
-called the instance name and is matched-on via `appName` from the same
-module.
-
-Let's use the class name for now.  We can tell all windows with that
-class name to float by defining the following manageHook:
-
-``` haskell
-  myManageHook = (className =? "Gimp" --> doFloat)
-```
-
-Say we also want to float all dialogs.  This is easy with the `isDialog`
-function from [XMonad.Hooks.ManageHelpers] (which you should import) and
-a little modification to the `myManageHook` function:
-
-``` haskell
-  myManageHook :: ManageHook
-  myManageHook = composeAll
-      [ className =? "Gimp" --> doFloat
-      , isDialog            --> doFloat
-      ]
-```
-
-Now we just need to tell xmonad to actually use our manageHook.  This is
-as easy as overriding the `manageHook` field in `myConfig`.  You can do
-it like this:
-
-``` haskell
-  myConfig = def
-      { modMask    = mod4Mask      -- Rebind Mod to the Super key
-      , layoutHook = myLayout      -- Use custom layouts
-      , manageHook = myManageHook  -- Match on certain windows
-      }
-    `additionalKeysP`
-      [ ("M-S-z", spawn "xscreensaver-command -lock")
-      , ("M-S-=", unGrab *> spawn "scrot -s"        )
-      , ("M-]"  , spawn "firefox"                   )
-      ]
-```
-
-## The Whole Thing
-
-The full `~/.config/xmonad/xmonad.hs`, in all its glory, now looks like
-this:
-
-``` haskell
-  import XMonad
-
-  import XMonad.Hooks.DynamicLog
-  import XMonad.Hooks.ManageDocks
-  import XMonad.Hooks.ManageHelpers
-  import XMonad.Hooks.StatusBar
-  import XMonad.Hooks.StatusBar.PP
-
-  import XMonad.Util.EZConfig
-  import XMonad.Util.Loggers
-  import XMonad.Util.Ungrab
-
-  import XMonad.Layout.Magnifier
-  import XMonad.Layout.ThreeColumns
-
-  import XMonad.Hooks.EwmhDesktops
-
-
-  main :: IO ()
-  main = xmonad
-       . ewmhFullscreen
-       . ewmh
-       . withEasySB (statusBarProp "xmobar" (pure myXmobarPP)) defToggleStrutsKey
-       $ myConfig
-
-  myConfig = def
-      { modMask    = mod4Mask      -- Rebind Mod to the Super key
-      , layoutHook = myLayout      -- Use custom layouts
-      , manageHook = myManageHook  -- Match on certain windows
-      }
-    `additionalKeysP`
-      [ ("M-S-z", spawn "xscreensaver-command -lock")
-      , ("M-S-=", unGrab *> spawn "scrot -s"        )
-      , ("M-]"  , spawn "firefox"                   )
-      ]
-
-  myManageHook :: ManageHook
-  myManageHook = composeAll
-      [ className =? "Gimp" --> doFloat
-      , isDialog            --> doFloat
-      ]
-
-  myLayout = tiled ||| Mirror tiled ||| Full ||| threeCol
-    where
-      threeCol = magnifiercz' 1.3 $ ThreeColMid nmaster delta ratio
-      tiled    = Tall nmaster delta ratio
-      nmaster  = 1      -- Default number of windows in the master pane
-      ratio    = 1/2    -- Default proportion of screen occupied by master pane
-      delta    = 3/100  -- Percent of screen to increment by when resizing panes
-
-  myXmobarPP :: PP
-  myXmobarPP = def
-      { ppSep             = magenta " • "
-      , ppTitleSanitize   = xmobarStrip
-      , ppCurrent         = wrap " " "" . xmobarBorder "Top" "#8be9fd" 2
-      , ppHidden          = white . wrap " " ""
-      , ppHiddenNoWindows = lowWhite . wrap " " ""
-      , ppUrgent          = red . wrap (yellow "!") (yellow "!")
-      , ppOrder           = \[ws, l, _, wins] -> [ws, l, wins]
-      , ppExtras          = [logTitles formatFocused formatUnfocused]
-      }
-    where
-      formatFocused   = wrap (white    "[") (white    "]") . magenta . ppWindow
-      formatUnfocused = wrap (lowWhite "[") (lowWhite "]") . blue    . ppWindow
-
-      -- | Windows should have *some* title, which should not not exceed a
-      -- sane length.
-      ppWindow :: String -> String
-      ppWindow = xmobarRaw . (\w -> if null w then "untitled" else w) . shorten 30
-
-      blue, lowWhite, magenta, red, white, yellow :: String -> String
-      magenta  = xmobarColor "#ff79c6" ""
-      blue     = xmobarColor "#bd93f9" ""
-      white    = xmobarColor "#f8f8f2" ""
-      yellow   = xmobarColor "#f1fa8c" ""
-      red      = xmobarColor "#ff5555" ""
-      lowWhite = xmobarColor "#bbbbbb" ""
-```
-
-## Further Customizations
-
-The following section mostly consists of extra bits—feel free to skip
-this and jump directly to [Get in Touch](#get-in-touch).  We've covered
-a lot of ground here and sometimes it's really better to let things
-settle a bit before going further; much more so if you're happy with how
-things are looking and feeling right now!
-
-### Beautifying Xmobar
-
-A usual starting point for beautifying xmobar is either to use `xpm`
-icons, or a font like `font-awesome` to add icons to the rest of the
-text.  We will show you how to do the latter.  Xmobar, thankfully, makes
-this very easy; just put a font down under `additionalFonts` and wrap
-your Icons with `<fn>` tags and the respective index of the font
-(starting from `1`).  As an example, consider how we would extend our
-configuration above with this new functionality:
-
-``` haskell
-  Config { overrideRedirect = False
-         , font             = "xft:iosevka-9"
-         , additionalFonts  = ["xft:FontAwesome-9"]
-         ...
-         , Run Battery
-             [ ...
-             , "--lows"   , "<fn=1>\62020</fn>  "
-             , "--mediums", "<fn=1>\62018</fn>  "
-             , "--highs"  , "<fn=1>\62016</fn>  "
-               ...
-             ]
-         ...
-         }
-```
-
-For an explanation of the battery commands used above, see xmobars
-[battery] documentation.
-
-You can also specify workspaces in the same way and feed them to xmobar
-via the property (e.g. have `"<fn=1>\xf120</fn>"` as one of your
-workspace names).
-
-As an example how this would look like in a real configuration, you can
-look at [Liskin's], [slotThe's], or [TheMC47's] xmobar configuration.
-Do note that the last two are Haskell-based and thus may be a little
-hard to understand for newcomers.
-
-[Liskin's]: https://github.com/liskin/dotfiles/blob/home/.xmobarrc
-[TheMC47's]: https://github.com/TheMC47/dotfiles/tree/master/xmobar/xmobarrc
-[slotThe's]: https://gitlab.com/slotThe/dotfiles/-/blob/master/xmobar/.config/xmobarrc/src/xmobarrc.hs
-
-### Renaming Layouts
-
-`Magnifier NoMaster ThreeCol` is quite a mouthful to show in your bar,
-right?  Thankfully there is the nifty [XMonad.Layout.Renamed], which
-makes renaming layouts easy!  We will focus on the `Replace` constructor
-here, as a lot of people will find that that's all they need.  To use it
-we again follow the documentation (try it yourself!)—import the module
-and then change `myLayout` like this:
-
-``` haskell
-  myLayout = tiled ||| Mirror tiled ||| Full ||| threeCol
-    where
-      threeCol
-          = renamed [Replace "ThreeCol"]
-          $ magnifiercz' 1.3
-          $ ThreeColMid nmaster delta ratio
-      tiled   = Tall nmaster delta ratio
-      nmaster = 1      -- Default number of windows in the master pane
-      ratio   = 1/2    -- Default proportion of screen occupied by master pane
-      delta   = 3/100  -- Percent of screen to increment by when resizing panes
-```
-
-The new line `renamed [Replace "ThreeCol"]` tells the layout to throw
-its current name away and use `ThreeCol` instead.  After reloading
-xmonad, you should now see this shorter name in your bar.  The line
-breaks here are just cosmetic, by the way; if you want you can write
-everything in one line:
-
-``` haskell
-  threeCol = renamed [Replace "ThreeCol"] $ magnifiercz' 1.3 $ ThreeColMid nmaster delta ratio
-```
-
-## Get in Touch
-
-The `irc.libera.chat/#xmonad` channel is very friendly and helpful.  It
-is possible that people will not immediately answer—we do have lives as
-well, after all :).  Eventually though, people will usually chime in if
-they have something helpful to say; sometimes this takes 10 minutes,
-other times it may well take 10 hours.  If you don't have an IRC client
-ready to go, the easiest way to join is via [webchat]—just jot down a
-username and you should be good to go!  There is a [log] of the channel
-available, in case you do have to disconnect at some point, so don't
-worry about missing any messages.
-
-If you're not a fan of real-time interactions, you can also post to the
-[xmonad mailing list] or the [xmonad subreddit].
-
-## Trouble?
-
-Check `~/.xsession-errors` or your distribution's equivalent first.  If
-you're using a distribution that does not log into a file automatically,
-you will have to set this up manually.  For example, you could put
-something like
-
-``` shell
-  if [[ ! $DISPLAY ]]; then
-    exec startx >& ~/.xsession-errors
-  fi
-```
-
-into your `~/.profile` file to explicitly log everything into
-`~/.xsession-errors`.
-
-If you can't figure out what's wrong, don't hesitate to
-[get in touch](#get-in-touch)!
-
-## Closing Thoughts
-
-That was quite a ride!  Don't worry if you didn't understand everything
-perfectly, these things take time.  You can re-read parts of this guide
-as often as you need to and—with the risk of sounding like a broken
-record—if you can't figure something out really do not be afraid to
-[get in touch](#get-in-touch).
-
-If you want to see a few more complicated examples of other peoples
-xmonad configurations, look no further!  Below are (in alphabetical
-order) the configurations of a few of xmonad's maintainers.  Just keep
-in mind that these setups are very customized and perhaps a little bit
-hard to replicate (some may rely on features only available in personal
-forks or git), may or may not be documented, and most aren't very pretty
-either :)
-
-  - [byorgey](https://github.com/byorgey/dotfiles)
-  - [geekosaur](https://github.com/geekosaur/xmonad.hs/tree/pyanfar)
-  - [liskin](https://github.com/liskin/dotfiles/tree/home/.xmonad)
-  - [psibi](https://github.com/psibi/dotfiles/tree/master/xmonad)
-  - [slotThe](https://gitlab.com/slotThe/dotfiles/-/tree/master/xmonad/.config/xmonad)
-  - [TheMC47](https://github.com/TheMC47/dotfiles/tree/master/xmonad/.xmonad)
-
-
-[log]: https://ircbrowse.tomsmeding.com/browse/lcxmonad
-[EWMH]: https://specifications.freedesktop.org/wm-spec/wm-spec-1.3.html
-[ICCCM]: https://tronche.com/gui/x/icccm/
-[webchat]: https://kiwiirc.com/nextclient/irc.libera.chat/?#xmonad
-[about xmonad]: https://xmonad.org/about.html
-[shell variable]: https://www.shellscript.sh/variables1.html
-[xmonad-testing]: https://github.com/xmonad/xmonad-testing
-[xmonad subreddit]: https://old.reddit.com/r/xmonad/
-[xmonad guided tour]: https://xmonad.org/tour.html
-[xmonad mailing list]: https://mail.haskell.org/mailman/listinfo/xmonad
-[xmonad's GitHub page]: https://github.com/xmonad/xmonad
-[trayer-padding-icon.sh]: https://github.com/jaor/xmobar/issues/239#issuecomment-233206552
-[xmonad-contrib documentation]: https://hackage.haskell.org/package/xmonad-contrib
-[GNU Image Manipulation Program]: https://www.gimp.org/
-[Basic Desktop Environment Integration]: https://wiki.haskell.org/Xmonad/Basic_Desktop_Environment_Integration
-
-[Hacks]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Util-Hacks.html
-[PP record]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Hooks-DynamicLog.html#t:PP
-[INSTALL.md]: https://github.com/xmonad/xmonad/blob/master/INSTALL.md#stack
-[XMonad.Config]: https://github.com/xmonad/xmonad/blob/master/src/XMonad/Config.hs
-[XMonad.ManageHook]: https://hackage.haskell.org/package/xmonad/docs/XMonad-ManageHook.html
-[XMonad.Util.Loggers]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Util-Loggers.html
-[XMonad.Util.EZConfig]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Util-EZConfig.html
-[XMonad.Layout.Renamed]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Layout-Renamed.html
-[XMonad.Layout.Magnifier]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Layout-Magnifier.html
-[XMonad.Doc.Contributing]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Doc-Configuring.html
-[XMonad.Hooks.EwmhDesktops]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Hooks-EwmhDesktops.html
-[XMonad.Layout.ThreeColumns]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Layout-ThreeColumns.html
-[XMonad.Hooks.ManageHelpers]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Hooks-ManageHelpers.html
-[XMonad.Util.ClickableWorkspaces]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Util-ClickableWorkspaces.html
-
-[xmobar]: https://xmobar.org/
-[battery]: https://github.com/jaor/xmobar/blob/master/doc/plugins.org#batteryp-dirs-args-refreshrate
-[xmobar.hs]: https://github.com/jaor/xmobar/blob/master/examples/xmobar.hs
-[Wikipedia page]: https://en.wikipedia.org/wiki/ICAO_airport_code#Prefixes
-[quick-start.org]: https://github.com/jaor/xmobar/blob/master/doc/quick-start.org#configuration-options
-[jao's xmobar.hs]: https://codeberg.org/jao/xmobar-config
-[weather monitor]: https://github.com/jaor/xmobar/blob/master/doc/plugins.org#weather-monitors
-[xmobar home page]: https://xmobar.org/
-[xmobar's `Installation` section]: https://github.com/jaor/xmobar#installation
-
-[Haskell]: https://www.haskell.org/
-[trayer-srg]: https://github.com/sargon/trayer-srg
-[record update]: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
-[lambda abstraction]: https://wiki.haskell.org/Lambda_abstraction
-[GNU Emacs conventions]: https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Sequences.html#Key-Sequences
diff --git a/source/cabal.haskell-ci b/source/cabal.haskell-ci
deleted file mode 100644
index c78ed7f..0000000
--- a/source/cabal.haskell-ci
+++ /dev/null
@@ -1,10 +0,0 @@
-apt:
-  libx11-dev
-  libxext-dev
-  libxinerama-dev
-  libxrandr-dev
-  libxss-dev
-
-raw-project
-  package xmonad
-    flags: +pedantic
diff --git a/source/cabal.project b/source/cabal.project
deleted file mode 100644
index 6015e48..0000000
--- a/source/cabal.project
+++ /dev/null
@@ -1,4 +0,0 @@
--- cabal.project
-
-packages:
-  xmonad.cabal
diff --git a/source/xmonad.cabal b/simplified/lowarn-version-xmonad-v1336.cabal
similarity index 65%
rename from source/xmonad.cabal
rename to simplified/lowarn-version-xmonad-v1336.cabal
index 5a88cde..db26928 100644
--- a/source/xmonad.cabal
+++ b/simplified/lowarn-version-xmonad-v1336.cabal
@@ -1,4 +1,4 @@
-name:               xmonad
+name:               lowarn-version-xmonad-v1336
 version:            0.16.999
 synopsis:           A tiling window manager
 description:        xmonad is a tiling window manager for X. Windows are arranged
@@ -32,19 +32,7 @@ category:           System
 homepage:           http://xmonad.org
 bug-reports:        https://github.com/xmonad/xmonad/issues
 build-type:         Simple
-extra-source-files: README.md
-                    CHANGES.md
-                    CONFIG
-                    STYLE
-                    tests/*.hs
-                    tests/Properties/*.hs
-                    tests/Properties/Layout/*.hs
-                    man/xmonad.1.markdown
-                    man/xmonad.1
-                    man/xmonad.1.html
-                    man/xmonad.hs
-                    util/hpcReport.sh
-cabal-version:      >= 1.8
+cabal-version:      >= 1.10
 
 source-repository head
   type:     git
@@ -66,7 +54,7 @@ library
                    XMonad.ManageHook
                    XMonad.Operations
                    XMonad.StackSet
-  other-modules:   Paths_xmonad
+  other-modules:   Paths_lowarn_version_xmonad_v1336
   hs-source-dirs:  src
   build-depends:   base                  >= 4.9 && < 5
                  , X11                   >= 1.10 && < 1.11
@@ -88,50 +76,3 @@ library
 
   if flag(pedantic)
     ghc-options:   -Werror
-
-executable xmonad
-  main-is:       Main.hs
-  build-depends: base, X11, mtl, unix, xmonad
-  ghc-options:   -Wall -Wno-unused-do-bind
-
-  -- Keep this in sync with the oldest version in 'tested-with'
-  if impl(ghc > 8.4.4)
-    ghc-options:   -Wno-unused-imports
-
-  if flag(pedantic)
-    ghc-options:   -Werror
-
-test-suite properties
-  type:           exitcode-stdio-1.0
-  main-is:        Properties.hs
-  other-modules:  Instances
-                  Properties.Delete
-                  Properties.Failure
-                  Properties.Floating
-                  Properties.Focus
-                  Properties.GreedyView
-                  Properties.Insert
-                  Properties.Layout.Full
-                  Properties.Layout.Tall
-                  Properties.Screen
-                  Properties.Shift
-                  Properties.Stack
-                  Properties.StackSet
-                  Properties.Swap
-                  Properties.View
-                  Properties.Workspace
-                  Utils
-  hs-source-dirs: tests
-  build-depends:  base
-                , QuickCheck >= 2
-                , X11
-                , containers
-                , xmonad
-
-  if flag(quickcheck-classes) && impl(ghc > 8.5)
-    -- no quickcheck-classes in LTS-12
-    -- GHC 8.4 and lower needs too much boilerplate (Eq1, Show1, …)
-    build-depends: quickcheck-classes >= 0.4.3
-
-  if flag(pedantic)
-    ghc-options:   -Werror
diff --git a/source/man/HCAR.tex b/source/man/HCAR.tex
deleted file mode 100644
index 68d6e6a..0000000
--- a/source/man/HCAR.tex
+++ /dev/null
@@ -1,71 +0,0 @@
-% xmonad-Gx.tex
-\begin{hcarentry}{xmonad}
-\label{xmonad}
-\report{Gwern Branwen}%11/11
-\status{active development}
-\makeheader
-
-XMonad is a tiling window manager for X. Windows are arranged
-automatically to tile the screen without gaps or overlap, maximizing
-screen use. Window manager features are accessible from the keyboard; a
-mouse is optional. XMonad is written, configured, and extensible in
-Haskell. Custom layout algorithms, key bindings, and other extensions may
-be written by the user in config files. Layouts are applied
-dynamically, and different layouts may be used on each workspace.
-Xinerama is fully supported, allowing windows to be tiled on several
-physical screens.
-
-Development since the last report has continued; XMonad founder Don Stewart
-has stepped down and Adam Vogt is the new maintainer.
-After gestating for 2 years, version 0.10 has been released, with simultaneous
-releases of the XMonadContrib library of customizations (which has now grown to
-no less than 216 modules encompassing a dizzying array of features) and the
-xmonad-extras package of extensions,
-
-Details of changes between releases can be found in the release notes:
-\begin{compactitem}
-\item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.8}
-\item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.9}
-% \item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.10}
-\item the Darcs repositories have been upgraded to the hashed format
-\item XMonad.Config.PlainConfig allows writing configs in a more 'normal' style, and not raw Haskell
-\item Supports using local modules in xmonad.hs; for example: to use definitions from \~/.xmonad/lib/XMonad/Stack/MyAdditions.hs
-\item xmonad --restart CLI option
-\item xmonad --replace CLI option
-\item XMonad.Prompt now has customizable keymaps
-\item Actions.GridSelect - a GUI menu for selecting windows or workspaces \& substring search on window names
-\item Actions.OnScreen
-\item Extensions now can have state
-\item Actions.SpawnOn - uses state to spawn applications on the workspace the user was originally on,
-  and not where the user happens to be
-\item Markdown manpages and not man/troff
-\item  XMonad.Layout.ImageButtonDecoration \&\\ XMonad.Util.Image
-\item XMonad.Layout.Groups
-\item XMonad.Layout.ZoomRow
-\item XMonad.Layout.Renamed
-\item XMonad.Layout.Drawer
-\item XMonad.Layout.FullScreen
-\item XMonad.Hooks.ScreenCorners
-\item XMonad.Actions.DynamicWorkspaceOrder
-\item XMonad.Actions.WorkspaceNames
-\item XMonad.Actions.DynamicWorkspaceGroups
-\end{compactitem}
-
-Binary packages of XMonad and XMonadContrib are available for all major Linux distributions.
-
-\FurtherReading
-\begin{compactitem}
-\item Homepage:
- \url{http://xmonad.org/}
-
-\item Git source:
-
- \texttt{git clone} \url{https://github.com/xmonad/xmonad.git}
-
-\item IRC channel:
- \verb+#xmonad @@ irc.freenode.org+
-
-\item Mailing list:
- \email{xmonad@@haskell.org}
-\end{compactitem}
-\end{hcarentry}
diff --git a/source/man/Makefile b/source/man/Makefile
deleted file mode 100644
index 4cef90f..0000000
--- a/source/man/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-.PHONY: all
-all: xmonad.1 xmonad.1.html
-
-xmonad.1.markdown: xmonad.1.markdown.in
-	(cd .. && util/GenerateManpage.hs) <$< >$@
-
-xmonad.1: xmonad.1.markdown
-	pandoc --from=markdown --to=man --standalone --output=$@ $<
-
-xmonad.1.html: xmonad.1.markdown
-	pandoc --from=markdown --to=html --standalone --table-of-contents --output=$@ $<
diff --git a/source/man/xmonad.1 b/source/man/xmonad.1
deleted file mode 100644
index ded482a..0000000
--- a/source/man/xmonad.1
+++ /dev/null
@@ -1,228 +0,0 @@
-.\" Automatically generated by Pandoc 2.5
-.\"
-.TH "XMONAD" "1" "30 September 2018" "Tiling Window Manager" ""
-.hy
-.SH Name
-.PP
-xmonad \- Tiling Window Manager
-.SH Description
-.PP
-\f[I]xmonad\f[R] is a minimalist tiling window manager for X, written in
-Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured.
-At any time windows are arranged so as to maximize the use of screen
-real estate.
-All features of the window manager are accessible purely from the
-keyboard: a mouse is entirely optional.
-\f[I]xmonad\f[R] is configured in Haskell, and custom layout algorithms
-may be implemented by the user in config files.
-A principle of \f[I]xmonad\f[R] is predictability: the user should know
-in advance precisely the window arrangement that will result from any
-action.
-.PP
-By default, \f[I]xmonad\f[R] provides three layout algorithms: tall,
-wide and fullscreen.
-In tall or wide mode, windows are tiled and arranged to prevent overlap
-and maximize screen use.
-Sets of windows are grouped together on virtual screens, and each screen
-retains its own layout, which may be reconfigured dynamically.
-Multiple physical monitors are supported via Xinerama, allowing
-simultaneous display of a number of screens.
-.PP
-By utilizing the expressivity of a modern functional language with a
-rich static type system, \f[I]xmonad\f[R] provides a complete,
-featureful window manager in less than 1200 lines of code, with an
-emphasis on correctness and robustness.
-Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type\-based automated testing.
-A benefit of this is that the code is simple to understand, and easy to
-modify.
-.SH Usage
-.PP
-\f[I]xmonad\f[R] places each window into a \[lq]workspace\[rq].
-Each workspace can have any number of windows, which you can cycle
-though with mod\-j and mod\-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically.
-You can toggle the layout mode with mod\-space, which will cycle through
-the available modes.
-.PP
-You can switch to workspace N with mod\-N.
-For example, to switch to workspace 5, you would press mod\-5.
-Similarly, you can move the current window to another workspace with
-mod\-shift\-N.
-.PP
-When running with multiple monitors (Xinerama), each screen has exactly
-1 workspace visible.
-mod\-{w,e,r} switch the focus between screens, while shift\-mod\-{w,e,r}
-move the current window to that screen.
-When \f[I]xmonad\f[R] starts, workspace 1 is on screen 1, workspace 2 is
-on screen 2, etc.
-When switching workspaces to one that is already visible, the current
-and visible workspaces are swapped.
-.SS Flags
-.PP
-xmonad has several flags which you may pass to the executable.
-These flags are:
-.TP
-.B \[en]recompile
-Recompiles your \f[I]xmonad.hs\f[R] configuration
-.TP
-.B \[en]restart
-Causes the currently running \f[I]xmonad\f[R] process to restart
-.TP
-.B \[en]replace
-Replace the current window manager with xmonad
-.TP
-.B \[en]version
-Display version of \f[I]xmonad\f[R]
-.TP
-.B \[en]verbose\-version
-Display detailed version of \f[I]xmonad\f[R]
-.SS Default keyboard bindings
-.TP
-.B mod\-shift\-return
-Launch terminal
-.TP
-.B mod\-p
-Launch dmenu
-.TP
-.B mod\-shift\-p
-Launch gmrun
-.TP
-.B mod\-shift\-c
-Close the focused window
-.TP
-.B mod\-space
-Rotate through the available layout algorithms
-.TP
-.B mod\-shift\-space
-Reset the layouts on the current workspace to default
-.TP
-.B mod\-n
-Resize viewed windows to the correct size
-.TP
-.B mod\-tab
-Move focus to the next window
-.TP
-.B mod\-shift\-tab
-Move focus to the previous window
-.TP
-.B mod\-j
-Move focus to the next window
-.TP
-.B mod\-k
-Move focus to the previous window
-.TP
-.B mod\-m
-Move focus to the master window
-.TP
-.B mod\-return
-Swap the focused window and the master window
-.TP
-.B mod\-shift\-j
-Swap the focused window with the next window
-.TP
-.B mod\-shift\-k
-Swap the focused window with the previous window
-.TP
-.B mod\-h
-Shrink the master area
-.TP
-.B mod\-l
-Expand the master area
-.TP
-.B mod\-t
-Push window back into tiling
-.TP
-.B mod\-comma
-Increment the number of windows in the master area
-.TP
-.B mod\-period
-Deincrement the number of windows in the master area
-.TP
-.B mod\-shift\-q
-Quit xmonad
-.TP
-.B mod\-q
-Restart xmonad
-.TP
-.B mod\-shift\-slash
-Run xmessage with a summary of the default keybindings (useful for
-beginners)
-.TP
-.B mod\-question
-Run xmessage with a summary of the default keybindings (useful for
-beginners)
-.TP
-.B mod\-[1..9]
-Switch to workspace N
-.TP
-.B mod\-shift\-[1..9]
-Move client to workspace N
-.TP
-.B mod\-{w,e,r}
-Switch to physical/Xinerama screens 1, 2, or 3
-.TP
-.B mod\-shift\-{w,e,r}
-Move client to screen 1, 2, or 3
-.TP
-.B mod\-button1
-Set the window to floating mode and move by dragging
-.TP
-.B mod\-button2
-Raise the window to the top of the stack
-.TP
-.B mod\-button3
-Set the window to floating mode and resize by dragging
-.SH Examples
-.PP
-To use xmonad as your window manager add to your
-\f[I]\[ti]/.xinitrc\f[R] file:
-.RS
-.PP
-exec xmonad
-.RE
-.SH Customization
-.PP
-xmonad is customized in your \f[I]xmonad.hs\f[R], and then restarted
-with mod\-q.
-You can choose where your configuration file lives by
-.IP "1." 3
-Setting \f[C]XMONAD_DATA_DIR,\f[R] \f[C]XMONAD_CONFIG_DIR\f[R], and
-\f[C]XMONAD_CACHE_DIR\f[R]; \f[I]xmonad.hs\f[R] is then expected to be
-in \f[C]XMONAD_CONFIG_DIR\f[R].
-.IP "2." 3
-Creating \f[I]xmonad.hs\f[R] in \f[I]\[ti]/.xmonad\f[R].
-.IP "3." 3
-Creating \f[I]xmonad.hs\f[R] in \f[C]XDG_CONFIG_HOME\f[R].
-Note that, in this case, xmonad will use \f[C]XDG_DATA_HOME\f[R] and
-\f[C]XDG_CACHE_HOME\f[R] for its data and cache directory respectively.
-.PP
-You can find many extensions to the core feature set in the xmonad\-
-contrib package, available through your package manager or from
-xmonad.org (https://xmonad.org).
-.SS Modular Configuration
-.PP
-As of \f[I]xmonad\-0.9\f[R], any additional Haskell modules may be
-placed in \f[I]\[ti]/.xmonad/lib/\f[R] are available in GHC\[cq]s
-searchpath.
-Hierarchical modules are supported: for example, the file
-\f[I]\[ti]/.xmonad/lib/XMonad/Stack/MyAdditions.hs\f[R] could contain:
-.IP
-.nf
-\f[C]
-module XMonad.Stack.MyAdditions (function1) where
-  function1 = error \[dq]function1: Not implemented yet!\[dq]
-\f[R]
-.fi
-.PP
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad\-contrib.
-.SH Bugs
-.PP
-Probably.
-If you find any, please report them to the
-bugtracker (https://github.com/xmonad/xmonad/issues)
diff --git a/source/man/xmonad.1.html b/source/man/xmonad.1.html
deleted file mode 100644
index 30c4692..0000000
--- a/source/man/xmonad.1.html
+++ /dev/null
@@ -1,247 +0,0 @@
-<!DOCTYPE html>
-<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
-<head>
-  <meta charset="utf-8" />
-  <meta name="generator" content="pandoc" />
-  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
-  <meta name="author" content="" />
-  <meta name="dcterms.date" content="2018-09-30" />
-  <title>XMONAD(1) Tiling Window Manager</title>
-  <style type="text/css">
-      code{white-space: pre-wrap;}
-      span.smallcaps{font-variant: small-caps;}
-      span.underline{text-decoration: underline;}
-      div.column{display: inline-block; vertical-align: top; width: 50%;}
-  </style>
-  <style type="text/css">
-a.sourceLine { display: inline-block; line-height: 1.25; }
-a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
-a.sourceLine:empty { height: 1.2em; }
-.sourceCode { overflow: visible; }
-code.sourceCode { white-space: pre; position: relative; }
-div.sourceCode { margin: 1em 0; }
-pre.sourceCode { margin: 0; }
-@media screen {
-div.sourceCode { overflow: auto; }
-}
-@media print {
-code.sourceCode { white-space: pre-wrap; }
-a.sourceLine { text-indent: -1em; padding-left: 1em; }
-}
-pre.numberSource a.sourceLine
-  { position: relative; left: -4em; }
-pre.numberSource a.sourceLine::before
-  { content: attr(title);
-    position: relative; left: -1em; text-align: right; vertical-align: baseline;
-    border: none; pointer-events: all; display: inline-block;
-    -webkit-touch-callout: none; -webkit-user-select: none;
-    -khtml-user-select: none; -moz-user-select: none;
-    -ms-user-select: none; user-select: none;
-    padding: 0 4px; width: 4em;
-    color: #aaaaaa;
-  }
-pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
-div.sourceCode
-  {  }
-@media screen {
-a.sourceLine::before { text-decoration: underline; }
-}
-code span.al { color: #ff0000; font-weight: bold; } /* Alert */
-code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
-code span.at { color: #7d9029; } /* Attribute */
-code span.bn { color: #40a070; } /* BaseN */
-code span.bu { } /* BuiltIn */
-code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
-code span.ch { color: #4070a0; } /* Char */
-code span.cn { color: #880000; } /* Constant */
-code span.co { color: #60a0b0; font-style: italic; } /* Comment */
-code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
-code span.do { color: #ba2121; font-style: italic; } /* Documentation */
-code span.dt { color: #902000; } /* DataType */
-code span.dv { color: #40a070; } /* DecVal */
-code span.er { color: #ff0000; font-weight: bold; } /* Error */
-code span.ex { } /* Extension */
-code span.fl { color: #40a070; } /* Float */
-code span.fu { color: #06287e; } /* Function */
-code span.im { } /* Import */
-code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
-code span.kw { color: #007020; font-weight: bold; } /* Keyword */
-code span.op { color: #666666; } /* Operator */
-code span.ot { color: #007020; } /* Other */
-code span.pp { color: #bc7a00; } /* Preprocessor */
-code span.sc { color: #4070a0; } /* SpecialChar */
-code span.ss { color: #bb6688; } /* SpecialString */
-code span.st { color: #4070a0; } /* String */
-code span.va { color: #19177c; } /* Variable */
-code span.vs { color: #4070a0; } /* VerbatimString */
-code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
-  </style>
-</head>
-<body>
-<header id="title-block-header">
-<h1 class="title">XMONAD(1) Tiling Window Manager</h1>
-<p class="author"></p>
-<p class="date">30 September 2018</p>
-</header>
-<nav id="TOC">
-<ul>
-<li><a href="#name">Name</a></li>
-<li><a href="#description">Description</a></li>
-<li><a href="#usage">Usage</a><ul>
-<li><a href="#flags">Flags</a></li>
-<li><a href="#default-keyboard-bindings">Default keyboard bindings</a></li>
-</ul></li>
-<li><a href="#examples">Examples</a></li>
-<li><a href="#customization">Customization</a><ul>
-<li><a href="#modular-configuration">Modular Configuration</a></li>
-</ul></li>
-<li><a href="#bugs">Bugs</a></li>
-</ul>
-</nav>
-<h1 id="name">Name</h1>
-<p>xmonad - Tiling Window Manager</p>
-<h1 id="description">Description</h1>
-<p><em>xmonad</em> is a minimalist tiling window manager for X, written in Haskell. Windows are managed using automatic layout algorithms, which can be dynamically reconfigured. At any time windows are arranged so as to maximize the use of screen real estate. All features of the window manager are accessible purely from the keyboard: a mouse is entirely optional. <em>xmonad</em> is configured in Haskell, and custom layout algorithms may be implemented by the user in config files. A principle of <em>xmonad</em> is predictability: the user should know in advance precisely the window arrangement that will result from any action.</p>
-<p>By default, <em>xmonad</em> provides three layout algorithms: tall, wide and fullscreen. In tall or wide mode, windows are tiled and arranged to prevent overlap and maximize screen use. Sets of windows are grouped together on virtual screens, and each screen retains its own layout, which may be reconfigured dynamically. Multiple physical monitors are supported via Xinerama, allowing simultaneous display of a number of screens.</p>
-<p>By utilizing the expressivity of a modern functional language with a rich static type system, <em>xmonad</em> provides a complete, featureful window manager in less than 1200 lines of code, with an emphasis on correctness and robustness. Internal properties of the window manager are checked using a combination of static guarantees provided by the type system, and type-based automated testing. A benefit of this is that the code is simple to understand, and easy to modify.</p>
-<h1 id="usage">Usage</h1>
-<p><em>xmonad</em> places each window into a “workspace”. Each workspace can have any number of windows, which you can cycle though with mod-j and mod-k. Windows are either displayed full screen, tiled horizontally, or tiled vertically. You can toggle the layout mode with mod-space, which will cycle through the available modes.</p>
-<p>You can switch to workspace N with mod-N. For example, to switch to workspace 5, you would press mod-5. Similarly, you can move the current window to another workspace with mod-shift-N.</p>
-<p>When running with multiple monitors (Xinerama), each screen has exactly 1 workspace visible. mod-{w,e,r} switch the focus between screens, while shift-mod-{w,e,r} move the current window to that screen. When <em>xmonad</em> starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When switching workspaces to one that is already visible, the current and visible workspaces are swapped.</p>
-<h2 id="flags">Flags</h2>
-<p>xmonad has several flags which you may pass to the executable. These flags are:</p>
-<dl>
-<dt>–recompile</dt>
-<dd>Recompiles your <em>xmonad.hs</em> configuration
-</dd>
-<dt>–restart</dt>
-<dd>Causes the currently running <em>xmonad</em> process to restart
-</dd>
-<dt>–replace</dt>
-<dd>Replace the current window manager with xmonad
-</dd>
-<dt>–version</dt>
-<dd>Display version of <em>xmonad</em>
-</dd>
-<dt>–verbose-version</dt>
-<dd>Display detailed version of <em>xmonad</em>
-</dd>
-</dl>
-<h2 id="default-keyboard-bindings">Default keyboard bindings</h2>
-<dl>
-<dt>mod-shift-return</dt>
-<dd>Launch terminal
-</dd>
-<dt>mod-p</dt>
-<dd>Launch dmenu
-</dd>
-<dt>mod-shift-p</dt>
-<dd>Launch gmrun
-</dd>
-<dt>mod-shift-c</dt>
-<dd>Close the focused window
-</dd>
-<dt>mod-space</dt>
-<dd>Rotate through the available layout algorithms
-</dd>
-<dt>mod-shift-space</dt>
-<dd>Reset the layouts on the current workspace to default
-</dd>
-<dt>mod-n</dt>
-<dd>Resize viewed windows to the correct size
-</dd>
-<dt>mod-tab</dt>
-<dd>Move focus to the next window
-</dd>
-<dt>mod-shift-tab</dt>
-<dd>Move focus to the previous window
-</dd>
-<dt>mod-j</dt>
-<dd>Move focus to the next window
-</dd>
-<dt>mod-k</dt>
-<dd>Move focus to the previous window
-</dd>
-<dt>mod-m</dt>
-<dd>Move focus to the master window
-</dd>
-<dt>mod-return</dt>
-<dd>Swap the focused window and the master window
-</dd>
-<dt>mod-shift-j</dt>
-<dd>Swap the focused window with the next window
-</dd>
-<dt>mod-shift-k</dt>
-<dd>Swap the focused window with the previous window
-</dd>
-<dt>mod-h</dt>
-<dd>Shrink the master area
-</dd>
-<dt>mod-l</dt>
-<dd>Expand the master area
-</dd>
-<dt>mod-t</dt>
-<dd>Push window back into tiling
-</dd>
-<dt>mod-comma</dt>
-<dd>Increment the number of windows in the master area
-</dd>
-<dt>mod-period</dt>
-<dd>Deincrement the number of windows in the master area
-</dd>
-<dt>mod-shift-q</dt>
-<dd>Quit xmonad
-</dd>
-<dt>mod-q</dt>
-<dd>Restart xmonad
-</dd>
-<dt>mod-shift-slash</dt>
-<dd>Run xmessage with a summary of the default keybindings (useful for beginners)
-</dd>
-<dt>mod-question</dt>
-<dd>Run xmessage with a summary of the default keybindings (useful for beginners)
-</dd>
-<dt>mod-[1..9]</dt>
-<dd>Switch to workspace N
-</dd>
-<dt>mod-shift-[1..9]</dt>
-<dd>Move client to workspace N
-</dd>
-<dt>mod-{w,e,r}</dt>
-<dd>Switch to physical/Xinerama screens 1, 2, or 3
-</dd>
-<dt>mod-shift-{w,e,r}</dt>
-<dd>Move client to screen 1, 2, or 3
-</dd>
-<dt>mod-button1</dt>
-<dd>Set the window to floating mode and move by dragging
-</dd>
-<dt>mod-button2</dt>
-<dd>Raise the window to the top of the stack
-</dd>
-<dt>mod-button3</dt>
-<dd>Set the window to floating mode and resize by dragging
-</dd>
-</dl>
-<h1 id="examples">Examples</h1>
-<p>To use xmonad as your window manager add to your <em>~/.xinitrc</em> file:</p>
-<blockquote>
-<p>exec xmonad</p>
-</blockquote>
-<h1 id="customization">Customization</h1>
-<p>xmonad is customized in your <em>xmonad.hs</em>, and then restarted with mod-q. You can choose where your configuration file lives by</p>
-<ol type="1">
-<li>Setting <code>XMONAD_DATA_DIR,</code> <code>XMONAD_CONFIG_DIR</code>, and <code>XMONAD_CACHE_DIR</code>; <em>xmonad.hs</em> is then expected to be in <code>XMONAD_CONFIG_DIR</code>.</li>
-<li>Creating <em>xmonad.hs</em> in <em>~/.xmonad</em>.</li>
-<li>Creating <em>xmonad.hs</em> in <code>XDG_CONFIG_HOME</code>. Note that, in this case, xmonad will use <code>XDG_DATA_HOME</code> and <code>XDG_CACHE_HOME</code> for its data and cache directory respectively.</li>
-</ol>
-<p>You can find many extensions to the core feature set in the xmonad- contrib package, available through your package manager or from <a href="https://xmonad.org">xmonad.org</a>.</p>
-<h2 id="modular-configuration">Modular Configuration</h2>
-<p>As of <em>xmonad-0.9</em>, any additional Haskell modules may be placed in <em>~/.xmonad/lib/</em> are available in GHC’s searchpath. Hierarchical modules are supported: for example, the file <em>~/.xmonad/lib/XMonad/Stack/MyAdditions.hs</em> could contain:</p>
-<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">XMonad.Stack.MyAdditions</span> (function1) <span class="kw">where</span></a>
-<a class="sourceLine" id="cb1-2" title="2">  function1 <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;function1: Not implemented yet!&quot;</span></a></code></pre></div>
-<p>Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that module was contained within xmonad or xmonad-contrib.</p>
-<h1 id="bugs">Bugs</h1>
-<p>Probably. If you find any, please report them to the <a href="https://github.com/xmonad/xmonad/issues">bugtracker</a></p>
-</body>
-</html>
diff --git a/source/man/xmonad.1.markdown b/source/man/xmonad.1.markdown
deleted file mode 100644
index bb53e33..0000000
--- a/source/man/xmonad.1.markdown
+++ /dev/null
@@ -1,210 +0,0 @@
-% XMONAD(1) Tiling Window Manager
-%
-% 30 September 2018
-
-# Name
-
-xmonad - Tiling Window Manager
-
-# Description
-
-_xmonad_ is a minimalist tiling window manager for X, written in Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured. At any time windows are arranged so as to
-maximize the use of screen real estate. All features of the window manager
-are accessible purely from the keyboard: a mouse is entirely optional.
-_xmonad_ is configured in Haskell, and custom layout algorithms may be
-implemented by the user in config files. A principle of _xmonad_ is
-predictability: the user should know in advance precisely the window
-arrangement that will result from any action.
-
-By default, _xmonad_ provides three layout algorithms: tall, wide and
-fullscreen. In tall or wide mode, windows are tiled and arranged to prevent
-overlap and maximize screen use. Sets of windows are grouped together on
-virtual screens, and each screen retains its own layout, which may be
-reconfigured dynamically. Multiple physical monitors are supported via
-Xinerama, allowing simultaneous display of a number of screens.
-
-By utilizing the expressivity of a modern functional language with a rich
-static type system, _xmonad_ provides a complete, featureful window manager
-in less than 1200 lines of code, with an emphasis on correctness and
-robustness. Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type-based automated testing. A benefit of this is that the code is simple
-to understand, and easy to modify.
-
-# Usage
-
-_xmonad_ places each window into a "workspace". Each workspace can have
-any number of windows, which you can cycle though with mod-j and mod-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically. You can toggle the layout mode with mod-space, which will cycle
-through the available modes.
-
-You can switch to workspace N with mod-N. For example, to switch to
-workspace 5, you would press mod-5. Similarly, you can move the current
-window to another workspace with mod-shift-N.
-
-When running with multiple monitors (Xinerama), each screen has exactly 1
-workspace visible. mod-{w,e,r} switch the focus between screens, while
-shift-mod-{w,e,r} move the current window to that screen. When _xmonad_
-starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When
-switching workspaces to one that is already visible, the current and
-visible workspaces are swapped.
-
-## Flags
-
-xmonad  has  several flags which  you may pass to the executable.
-These flags are:
-
---recompile
-:   Recompiles your _xmonad.hs_ configuration
-
---restart
-:   Causes the currently running _xmonad_ process to restart
-
---replace
-:   Replace the current window manager with xmonad
-
---version
-:   Display version of _xmonad_
-
---verbose-version
-:   Display detailed version of _xmonad_
-
-## Default keyboard bindings
-
-mod-shift-return
-:     Launch terminal
-
-mod-p
-:     Launch dmenu
-
-mod-shift-p
-:     Launch gmrun
-
-mod-shift-c
-:     Close the focused window
-
-mod-space
-:     Rotate through the available layout algorithms
-
-mod-shift-space
-:     Reset the layouts on the current workspace to default
-
-mod-n
-:     Resize viewed windows to the correct size
-
-mod-tab
-:     Move focus to the next window
-
-mod-shift-tab
-:     Move focus to the previous window
-
-mod-j
-:     Move focus to the next window
-
-mod-k
-:     Move focus to the previous window
-
-mod-m
-:     Move focus to the master window
-
-mod-return
-:     Swap the focused window and the master window
-
-mod-shift-j
-:     Swap the focused window with the next window
-
-mod-shift-k
-:     Swap the focused window with the previous window
-
-mod-h
-:     Shrink the master area
-
-mod-l
-:     Expand the master area
-
-mod-t
-:     Push window back into tiling
-
-mod-comma
-:     Increment the number of windows in the master area
-
-mod-period
-:     Deincrement the number of windows in the master area
-
-mod-shift-q
-:     Quit xmonad
-
-mod-q
-:     Restart xmonad
-
-mod-shift-slash
-:     Run xmessage with a summary of the default keybindings (useful for beginners)
-
-mod-question
-:     Run xmessage with a summary of the default keybindings (useful for beginners)
-
-mod-[1..9]
-:     Switch to workspace N
-
-mod-shift-[1..9]
-:     Move client to workspace N
-
-mod-{w,e,r}
-:     Switch to physical/Xinerama screens 1, 2, or 3
-
-mod-shift-{w,e,r}
-:     Move client to screen 1, 2, or 3
-
-mod-button1
-:     Set the window to floating mode and move by dragging
-
-mod-button2
-:     Raise the window to the top of the stack
-
-mod-button3
-:     Set the window to floating mode and resize by dragging
-
-# Examples
-
-To use xmonad as your window manager add to your _~/.xinitrc_ file:
-
-> exec xmonad
-
-# Customization
-xmonad is customized in your _xmonad.hs_, and then restarted with mod-q.
-You can choose where your configuration file lives by
-
-  1. Setting `XMONAD_DATA_DIR,` `XMONAD_CONFIG_DIR`, and
-     `XMONAD_CACHE_DIR`; _xmonad.hs_ is then expected to be in
-     `XMONAD_CONFIG_DIR`.
-  2. Creating _xmonad.hs_ in _~/.xmonad_.
-  3. Creating _xmonad.hs_ in `XDG_CONFIG_HOME`.  Note that, in this
-     case, xmonad will use `XDG_DATA_HOME` and `XDG_CACHE_HOME` for its
-     data and cache directory respectively.
-
-You can find many extensions to the core feature set in the xmonad-
-contrib package, available through your  package  manager  or  from
-[xmonad.org].
-
-## Modular Configuration
-As of _xmonad-0.9_, any additional Haskell modules may be placed in
-_~/.xmonad/lib/_ are available in GHC's searchpath. Hierarchical modules
-are supported: for example, the file
-_~/.xmonad/lib/XMonad/Stack/MyAdditions.hs_ could contain:
-
-```haskell
-module XMonad.Stack.MyAdditions (function1) where
-  function1 = error "function1: Not implemented yet!"
-```
-
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad-contrib.
-
-# Bugs
-Probably. If you find any, please report them to the [bugtracker]
-
-[xmonad.org]: https://xmonad.org
-[bugtracker]: https://github.com/xmonad/xmonad/issues
diff --git a/source/man/xmonad.1.markdown.in b/source/man/xmonad.1.markdown.in
deleted file mode 100644
index 6dbc564..0000000
--- a/source/man/xmonad.1.markdown.in
+++ /dev/null
@@ -1,119 +0,0 @@
-% XMONAD(1) Tiling Window Manager
-%
-% 30 September 2018
-
-# Name
-
-xmonad - Tiling Window Manager
-
-# Description
-
-_xmonad_ is a minimalist tiling window manager for X, written in Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured. At any time windows are arranged so as to
-maximize the use of screen real estate. All features of the window manager
-are accessible purely from the keyboard: a mouse is entirely optional.
-_xmonad_ is configured in Haskell, and custom layout algorithms may be
-implemented by the user in config files. A principle of _xmonad_ is
-predictability: the user should know in advance precisely the window
-arrangement that will result from any action.
-
-By default, _xmonad_ provides three layout algorithms: tall, wide and
-fullscreen. In tall or wide mode, windows are tiled and arranged to prevent
-overlap and maximize screen use. Sets of windows are grouped together on
-virtual screens, and each screen retains its own layout, which may be
-reconfigured dynamically. Multiple physical monitors are supported via
-Xinerama, allowing simultaneous display of a number of screens.
-
-By utilizing the expressivity of a modern functional language with a rich
-static type system, _xmonad_ provides a complete, featureful window manager
-in less than 1200 lines of code, with an emphasis on correctness and
-robustness. Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type-based automated testing. A benefit of this is that the code is simple
-to understand, and easy to modify.
-
-# Usage
-
-_xmonad_ places each window into a "workspace". Each workspace can have
-any number of windows, which you can cycle though with mod-j and mod-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically. You can toggle the layout mode with mod-space, which will cycle
-through the available modes.
-
-You can switch to workspace N with mod-N. For example, to switch to
-workspace 5, you would press mod-5. Similarly, you can move the current
-window to another workspace with mod-shift-N.
-
-When running with multiple monitors (Xinerama), each screen has exactly 1
-workspace visible. mod-{w,e,r} switch the focus between screens, while
-shift-mod-{w,e,r} move the current window to that screen. When _xmonad_
-starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When
-switching workspaces to one that is already visible, the current and
-visible workspaces are swapped.
-
-## Flags
-
-xmonad  has  several flags which  you may pass to the executable.
-These flags are:
-
---recompile
-:   Recompiles your _xmonad.hs_ configuration
-
---restart
-:   Causes the currently running _xmonad_ process to restart
-
---replace
-:   Replace the current window manager with xmonad
-
---version
-:   Display version of _xmonad_
-
---verbose-version
-:   Display detailed version of _xmonad_
-
-## Default keyboard bindings
-
-___KEYBINDINGS___
-
-# Examples
-
-To use xmonad as your window manager add to your _~/.xinitrc_ file:
-
-> exec xmonad
-
-# Customization
-xmonad is customized in your _xmonad.hs_, and then restarted with mod-q.
-You can choose where your configuration file lives by
-
-  1. Setting `XMONAD_DATA_DIR,` `XMONAD_CONFIG_DIR`, and
-     `XMONAD_CACHE_DIR`; _xmonad.hs_ is then expected to be in
-     `XMONAD_CONFIG_DIR`.
-  2. Creating _xmonad.hs_ in _~/.xmonad_.
-  3. Creating _xmonad.hs_ in `XDG_CONFIG_HOME`.  Note that, in this
-     case, xmonad will use `XDG_DATA_HOME` and `XDG_CACHE_HOME` for its
-     data and cache directory respectively.
-
-You can find many extensions to the core feature set in the xmonad-
-contrib package, available through your  package  manager  or  from
-[xmonad.org].
-
-## Modular Configuration
-As of _xmonad-0.9_, any additional Haskell modules may be placed in
-_~/.xmonad/lib/_ are available in GHC's searchpath. Hierarchical modules
-are supported: for example, the file
-_~/.xmonad/lib/XMonad/Stack/MyAdditions.hs_ could contain:
-
-```haskell
-module XMonad.Stack.MyAdditions (function1) where
-  function1 = error "function1: Not implemented yet!"
-```
-
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad-contrib.
-
-# Bugs
-Probably. If you find any, please report them to the [bugtracker]
-
-[xmonad.org]: https://xmonad.org
-[bugtracker]: https://github.com/xmonad/xmonad/issues
diff --git a/source/man/xmonad.hs b/source/man/xmonad.hs
deleted file mode 100644
index baf5189..0000000
--- a/source/man/xmonad.hs
+++ /dev/null
@@ -1,333 +0,0 @@
---
--- xmonad example config file.
---
--- A template showing all available configuration hooks,
--- and how to override the defaults in your own xmonad.hs conf file.
---
--- Normally, you'd only override those defaults you care about.
---
-
-import XMonad
-import Data.Monoid
-import System.Exit
-
-import qualified XMonad.StackSet as W
-import qualified Data.Map        as M
-
--- The preferred terminal program, which is used in a binding below and by
--- certain contrib modules.
---
-myTerminal      = "xterm"
-
--- Whether focus follows the mouse pointer.
-myFocusFollowsMouse :: Bool
-myFocusFollowsMouse = True
-
--- Whether clicking on a window to focus also passes the click to the window
-myClickJustFocuses :: Bool
-myClickJustFocuses = False
-
--- Width of the window border in pixels.
---
-myBorderWidth   = 1
-
--- modMask lets you specify which modkey you want to use. The default
--- is mod1Mask ("left alt").  You may also consider using mod3Mask
--- ("right alt"), which does not conflict with emacs keybindings. The
--- "windows key" is usually mod4Mask.
---
-myModMask       = mod1Mask
-
--- The default number of workspaces (virtual screens) and their names.
--- By default we use numeric strings, but any string may be used as a
--- workspace name. The number of workspaces is determined by the length
--- of this list.
---
--- A tagging example:
---
--- > workspaces = ["web", "irc", "code" ] ++ map show [4..9]
---
-myWorkspaces    = ["1","2","3","4","5","6","7","8","9"]
-
--- Border colors for unfocused and focused windows, respectively.
---
-myNormalBorderColor  = "#dddddd"
-myFocusedBorderColor = "#ff0000"
-
-------------------------------------------------------------------------
--- Key bindings. Add, modify or remove key bindings here.
---
-myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $
-
-    -- launch a terminal
-    [ ((modm .|. shiftMask, xK_Return), spawn $ XMonad.terminal conf)
-
-    -- launch dmenu
-    , ((modm,               xK_p     ), spawn "dmenu_run")
-
-    -- launch gmrun
-    , ((modm .|. shiftMask, xK_p     ), spawn "gmrun")
-
-    -- close focused window
-    , ((modm .|. shiftMask, xK_c     ), kill)
-
-     -- Rotate through the available layout algorithms
-    , ((modm,               xK_space ), sendMessage NextLayout)
-
-    --  Reset the layouts on the current workspace to default
-    , ((modm .|. shiftMask, xK_space ), setLayout $ XMonad.layoutHook conf)
-
-    -- Resize viewed windows to the correct size
-    , ((modm,               xK_n     ), refresh)
-
-    -- Move focus to the next window
-    , ((modm,               xK_Tab   ), windows W.focusDown)
-
-    -- Move focus to the next window
-    , ((modm,               xK_j     ), windows W.focusDown)
-
-    -- Move focus to the previous window
-    , ((modm,               xK_k     ), windows W.focusUp  )
-
-    -- Move focus to the master window
-    , ((modm,               xK_m     ), windows W.focusMaster  )
-
-    -- Swap the focused window and the master window
-    , ((modm,               xK_Return), windows W.swapMaster)
-
-    -- Swap the focused window with the next window
-    , ((modm .|. shiftMask, xK_j     ), windows W.swapDown  )
-
-    -- Swap the focused window with the previous window
-    , ((modm .|. shiftMask, xK_k     ), windows W.swapUp    )
-
-    -- Shrink the master area
-    , ((modm,               xK_h     ), sendMessage Shrink)
-
-    -- Expand the master area
-    , ((modm,               xK_l     ), sendMessage Expand)
-
-    -- Push window back into tiling
-    , ((modm,               xK_t     ), withFocused $ windows . W.sink)
-
-    -- Increment the number of windows in the master area
-    , ((modm              , xK_comma ), sendMessage (IncMasterN 1))
-
-    -- Deincrement the number of windows in the master area
-    , ((modm              , xK_period), sendMessage (IncMasterN (-1)))
-
-    -- Toggle the status bar gap
-    -- Use this binding with avoidStruts from Hooks.ManageDocks.
-    -- See also the statusBar function from Hooks.DynamicLog.
-    --
-    -- , ((modm              , xK_b     ), sendMessage ToggleStruts)
-
-    -- Quit xmonad
-    , ((modm .|. shiftMask, xK_q     ), io (exitWith ExitSuccess))
-
-    -- Restart xmonad
-    , ((modm              , xK_q     ), spawn "xmonad --recompile; xmonad --restart")
-
-    -- Run xmessage with a summary of the default keybindings (useful for beginners)
-    , ((modm .|. shiftMask, xK_slash ), spawn ("echo \"" ++ help ++ "\" | xmessage -file -"))
-    ]
-    ++
-
-    --
-    -- mod-[1..9], Switch to workspace N
-    -- mod-shift-[1..9], Move client to workspace N
-    --
-    [((m .|. modm, k), windows $ f i)
-        | (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9]
-        , (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]]
-    ++
-
-    --
-    -- mod-{w,e,r}, Switch to physical/Xinerama screens 1, 2, or 3
-    -- mod-shift-{w,e,r}, Move client to screen 1, 2, or 3
-    --
-    [((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
-        | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
-        , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
-
-
-------------------------------------------------------------------------
--- Mouse bindings: default actions bound to mouse events
---
-myMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $
-
-    -- mod-button1, Set the window to floating mode and move by dragging
-    [ ((modm, button1), (\w -> focus w >> mouseMoveWindow w
-                                       >> windows W.shiftMaster))
-
-    -- mod-button2, Raise the window to the top of the stack
-    , ((modm, button2), (\w -> focus w >> windows W.shiftMaster))
-
-    -- mod-button3, Set the window to floating mode and resize by dragging
-    , ((modm, button3), (\w -> focus w >> mouseResizeWindow w
-                                       >> windows W.shiftMaster))
-
-    -- you may also bind events to the mouse scroll wheel (button4 and button5)
-    ]
-
-------------------------------------------------------------------------
--- Layouts:
-
--- You can specify and transform your layouts by modifying these values.
--- If you change layout bindings be sure to use 'mod-shift-space' after
--- restarting (with 'mod-q') to reset your layout state to the new
--- defaults, as xmonad preserves your old layout settings by default.
---
--- The available layouts.  Note that each layout is separated by |||,
--- which denotes layout choice.
---
-myLayout = tiled ||| Mirror tiled ||| Full
-  where
-     -- default tiling algorithm partitions the screen into two panes
-     tiled   = Tall nmaster delta ratio
-
-     -- The default number of windows in the master pane
-     nmaster = 1
-
-     -- Default proportion of screen occupied by master pane
-     ratio   = 1/2
-
-     -- Percent of screen to increment by when resizing panes
-     delta   = 3/100
-
-------------------------------------------------------------------------
--- Window rules:
-
--- Execute arbitrary actions and WindowSet manipulations when managing
--- a new window. You can use this to, for example, always float a
--- particular program, or have a client always appear on a particular
--- workspace.
---
--- To find the property name associated with a program, use
--- > xprop | grep WM_CLASS
--- and click on the client you're interested in.
---
--- To match on the WM_NAME, you can use 'title' in the same way that
--- 'className' and 'resource' are used below.
---
-myManageHook = composeAll
-    [ className =? "MPlayer"        --> doFloat
-    , className =? "Gimp"           --> doFloat
-    , resource  =? "desktop_window" --> doIgnore
-    , resource  =? "kdesktop"       --> doIgnore ]
-
-------------------------------------------------------------------------
--- Event handling
-
--- * EwmhDesktops users should change this to ewmhDesktopsEventHook
---
--- Defines a custom handler function for X Events. The function should
--- return (All True) if the default handler is to be run afterwards. To
--- combine event hooks use mappend or mconcat from Data.Monoid.
---
-myEventHook = mempty
-
-------------------------------------------------------------------------
--- Status bars and logging
-
--- Perform an arbitrary action on each internal state change or X event.
--- See the 'XMonad.Hooks.DynamicLog' extension for examples.
---
-myLogHook = return ()
-
-------------------------------------------------------------------------
--- Startup hook
-
--- Perform an arbitrary action each time xmonad starts or is restarted
--- with mod-q.  Used by, e.g., XMonad.Layout.PerWorkspace to initialize
--- per-workspace layout choices.
---
--- By default, do nothing.
-myStartupHook = return ()
-
-------------------------------------------------------------------------
--- Now run xmonad with all the defaults we set up.
-
--- Run xmonad with the settings you specify. No need to modify this.
---
-main = xmonad defaults
-
--- A structure containing your configuration settings, overriding
--- fields in the default config. Any you don't override, will
--- use the defaults defined in xmonad/XMonad/Config.hs
---
--- No need to modify this.
---
-defaults = def {
-      -- simple stuff
-        terminal           = myTerminal,
-        focusFollowsMouse  = myFocusFollowsMouse,
-        clickJustFocuses   = myClickJustFocuses,
-        borderWidth        = myBorderWidth,
-        modMask            = myModMask,
-        workspaces         = myWorkspaces,
-        normalBorderColor  = myNormalBorderColor,
-        focusedBorderColor = myFocusedBorderColor,
-
-      -- key bindings
-        keys               = myKeys,
-        mouseBindings      = myMouseBindings,
-
-      -- hooks, layouts
-        layoutHook         = myLayout,
-        manageHook         = myManageHook,
-        handleEventHook    = myEventHook,
-        logHook            = myLogHook,
-        startupHook        = myStartupHook
-    }
-
--- | Finally, a copy of the default bindings in simple textual tabular format.
-help :: String
-help = unlines ["The default modifier key is 'alt'. Default keybindings:",
-    "",
-    "-- launching and killing programs",
-    "mod-Shift-Enter  Launch xterminal",
-    "mod-p            Launch dmenu",
-    "mod-Shift-p      Launch gmrun",
-    "mod-Shift-c      Close/kill the focused window",
-    "mod-Space        Rotate through the available layout algorithms",
-    "mod-Shift-Space  Reset the layouts on the current workSpace to default",
-    "mod-n            Resize/refresh viewed windows to the correct size",
-    "",
-    "-- move focus up or down the window stack",
-    "mod-Tab        Move focus to the next window",
-    "mod-Shift-Tab  Move focus to the previous window",
-    "mod-j          Move focus to the next window",
-    "mod-k          Move focus to the previous window",
-    "mod-m          Move focus to the master window",
-    "",
-    "-- modifying the window order",
-    "mod-Return   Swap the focused window and the master window",
-    "mod-Shift-j  Swap the focused window with the next window",
-    "mod-Shift-k  Swap the focused window with the previous window",
-    "",
-    "-- resizing the master/slave ratio",
-    "mod-h  Shrink the master area",
-    "mod-l  Expand the master area",
-    "",
-    "-- floating layer support",
-    "mod-t  Push window back into tiling; unfloat and re-tile it",
-    "",
-    "-- increase or decrease number of windows in the master area",
-    "mod-comma  (mod-,)   Increment the number of windows in the master area",
-    "mod-period (mod-.)   Deincrement the number of windows in the master area",
-    "",
-    "-- quit, or restart",
-    "mod-Shift-q  Quit xmonad",
-    "mod-q        Restart xmonad",
-    "mod-[1..9]   Switch to workSpace N",
-    "",
-    "-- Workspaces & screens",
-    "mod-Shift-[1..9]   Move client to workspace N",
-    "mod-{w,e,r}        Switch to physical/Xinerama screens 1, 2, or 3",
-    "mod-Shift-{w,e,r}  Move client to screen 1, 2, or 3",
-    "",
-    "-- Mouse bindings: default actions bound to mouse events",
-    "mod-button1  Set the window to floating mode and move by dragging",
-    "mod-button2  Raise the window to the top of the stack",
-    "mod-button3  Set the window to floating mode and resize by dragging"]
diff --git a/source/src/XMonad/Main.hs b/simplified/src/XMonad/Main.hs
index 507094e..b89d13f 100644
--- a/source/src/XMonad/Main.hs
+++ b/simplified/src/XMonad/Main.hs
@@ -44,7 +44,7 @@ import System.Posix.Process (executeFile)
 import System.Exit (exitFailure)
 import System.FilePath
 
-import Paths_xmonad (version)
+import Paths_lowarn_version_xmonad_v1336 (version)
 import Data.Version (showVersion)
 
 import Graphics.X11.Xinerama (compiledWithXinerama)
diff --git a/source/stack.yaml b/source/stack.yaml
deleted file mode 100644
index ffbb3cc..0000000
--- a/source/stack.yaml
+++ /dev/null
@@ -1,22 +0,0 @@
-resolver: lts-16.22
-
-packages:
-- ./
-
-extra-deps:
-- X11-1.10
-
-flags:
-  xmonad:
-    # stack doesn't support automatic flags
-    # https://cabal.readthedocs.io/en/latest/cabal-package.html#resolution-of-conditions-and-flags
-    # https://github.com/commercialhaskell/stack/issues/1313#issuecomment-157259270
-    quickcheck-classes: false
-
-nix:
-  packages:
-    - zlib
-    - xorg.libX11
-    - xorg.libXrandr
-    - xorg.libXScrnSaver
-    - xorg.libXext
diff --git a/source/tests/Instances.hs b/source/tests/Instances.hs
deleted file mode 100644
index e52c5ec..0000000
--- a/source/tests/Instances.hs
+++ /dev/null
@@ -1,140 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Instances where
-
-import Test.QuickCheck
-
-import Utils
-
-import XMonad.StackSet
-import Control.Monad
-import Data.List (nub, genericLength)
-
-import Debug.Trace
-
-import Graphics.X11 (Rectangle(Rectangle))
-import Control.Applicative
-
---
--- The all important Arbitrary instance for StackSet.
---
-instance (Integral i, Integral s, Eq a, Arbitrary a, Arbitrary l, Arbitrary sd)
-         => Arbitrary (StackSet i l a s sd) where
-  arbitrary = do
-      -- TODO: Fix this to be a reasonable higher number, Possibly use PositiveSized
-      numWs        <- choose (1, 20)    -- number of workspaces, there must be at least 1.
-      numScreens   <- choose (1, numWs) -- number of physical screens, there must be at least 1
-      lay <- arbitrary                  -- pick any layout
-
-      wsIdxInFocus <- choose (1, numWs) -- pick index of WS to be in focus
-
-      -- The same screen id's will be present in the list, with high possibility.
-      screens  <- replicateM numScreens arbitrary
-
-      -- Generate a list of "windows" for each workspace.
-      wsWindows  <- vector numWs :: Gen [[a]]
-
-      -- Pick a random window "number" in each workspace, to give focus.
-      focus <- sequence [ if null windows
-                          then return Nothing
-                          else liftM Just $ choose (0, length windows - 1)
-                        | windows <- wsWindows ]
-
-      let tags = [1 .. fromIntegral numWs]
-          focusWsWindows = zip focus wsWindows
-          wss = zip tags focusWsWindows -- tmp representation of a workspace (tag, windows)
-          initSs = new lay tags screens
-      return $
-        view (fromIntegral wsIdxInFocus) $
-        foldr (\(tag, (focus, windows)) ss -> -- Fold through all generated (tags,windows).
-                -- set workspace active by tag and fold through all
-                -- windows while inserting them.  Apply the given number
-                -- of `focusUp` on the resulting StackSet.
-                applyN focus focusUp $ foldr insertUp (view tag ss) windows
-              ) initSs wss
-
-
---
--- Just generate StackSets with Char elements.
---
-type Tag = Int
-type Window = Char
-type T = StackSet Tag Int Window Int Int
-
-
-
-newtype EmptyStackSet = EmptyStackSet T
-    deriving Show
-
-instance Arbitrary EmptyStackSet where
-    arbitrary = do
-        (NonEmptyNubList ns)  <- arbitrary
-        (NonEmptyNubList sds) <- arbitrary
-        l <- arbitrary
-        -- there cannot be more screens than workspaces:
-        return . EmptyStackSet . new l ns $ take (min (length ns) (length sds)) sds
-
-
-
-newtype NonEmptyWindowsStackSet = NonEmptyWindowsStackSet T
-    deriving Show
-
-instance Arbitrary NonEmptyWindowsStackSet where
-  arbitrary =
-    NonEmptyWindowsStackSet `fmap` (arbitrary `suchThat` (not . null . allWindows))
-
-instance Arbitrary Rectangle where
-    arbitrary = Rectangle <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary
-
-
-newtype SizedPositive = SizedPositive Int
-    deriving (Eq, Ord, Show, Read)
-
-instance Arbitrary SizedPositive where
-  arbitrary = sized $ \s -> do x <- choose (1, max 1 s)
-                               return $ SizedPositive x
-
-
-
-newtype NonEmptyNubList a = NonEmptyNubList [a]
-    deriving ( Eq, Ord, Show, Read )
-
-instance (Eq a, Arbitrary a) => Arbitrary (NonEmptyNubList a) where
-  arbitrary   = NonEmptyNubList `fmap` ((liftM nub arbitrary) `suchThat` (not . null))
-
-
-
--- | Pull out an arbitrary tag from the StackSet. This removes the need for the
--- precondition "n `tagMember x` in many properties and thus reduces the number
--- of discarded tests.
---
---  n <- arbitraryTag x
---
--- We can do the reverse with a simple `suchThat`:
---
--- n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-arbitraryTag :: T -> Gen Tag
-arbitraryTag x = do
-  let ts = tags x
-  -- There must be at least 1 workspace, thus at least 1 tag.
-  idx <- choose (0, (length ts) - 1)
-  return $ ts!!idx
-
--- | Pull out an arbitrary window from a StackSet that is guaranteed to have a
--- non empty set of windows. This eliminates the precondition "i `member` x" in
--- a few properties.
---
---
--- foo (nex :: NonEmptyWindowsStackSet) = do
---   let NonEmptyWindowsStackSet x = nex
---   w <- arbitraryWindow nex
---   return $ .......
---
--- We can do the reverse with a simple `suchThat`:
---
---   n <- arbitrary `suchThat` \n' -> not $ n `member` x
-arbitraryWindow :: NonEmptyWindowsStackSet -> Gen Window
-arbitraryWindow (NonEmptyWindowsStackSet x) = do
-  let ws = allWindows x
-  -- We know that there are at least 1 window in a NonEmptyWindowsStackSet.
-  idx <- choose(0, (length ws) - 1)
-  return $ ws!!idx
diff --git a/source/tests/Properties/Delete.hs b/source/tests/Properties/Delete.hs
deleted file mode 100644
index a8b8dd1..0000000
--- a/source/tests/Properties/Delete.hs
+++ /dev/null
@@ -1,70 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Delete where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
--- ---------------------------------------------------------------------
--- 'delete'
-
--- deleting the current item removes it.
-prop_delete x =
-    case peek x of
-        Nothing -> True
-        Just i  -> not (member i (delete i x))
-    where _ = x :: T
-
--- delete is reversible with 'insert'.
--- It is the identity, except for the 'master', which is reset on insert and delete.
---
-prop_delete_insert (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just n  -> insertUp n (delete n y) == y
-    where
-        y = swapMaster x
-
--- delete should be local
-prop_delete_local (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just i  -> hidden_spaces x == hidden_spaces (delete i x)
-
--- delete should not affect focus unless the focused element is what is being deleted
-prop_delete_focus = do
-  -- There should be at least two windows. One in focus, and some to try and
-  -- delete (doesn't have to be windows on the current workspace).  We generate
-  -- our own, since we can't rely on NonEmptyWindowsStackSet returning one in
-  -- the argument with at least two windows.
-  x <- arbitrary `suchThat` \x' -> length (allWindows x') >= 2
-  w <- arbitraryWindow (NonEmptyWindowsStackSet x)
-       -- Make sure we pick a window that is NOT the currently focused
-       `suchThat` \w' -> Just w' /= peek x
-  return $ peek (delete w x) == peek x
-
--- focus movement in the presence of delete:
--- when the last window in the stack set is focused, focus moves `up'.
--- usual case is that it moves 'down'.
-prop_delete_focus_end = do
-    -- Generate a StackSet with at least two windows on the current workspace.
-    x <- arbitrary `suchThat` \(x' :: T) -> length (index x') >= 2
-    let w = last (index x)
-        y = focusWindow w x -- focus last window in stack
-    return $ peek (delete w y) == peek (focusUp y)
-
-
--- focus movement in the presence of delete:
--- when not in the last item in the stack, focus moves down
-prop_delete_focus_not_end = do
-  x <- arbitrary
-       -- There must be at least two windows and the current focused is not the
-       -- last one in the stack.
-       `suchThat` \(x' :: T) ->
-         let currWins = index x'
-         in length (currWins) >= 2 && peek x' /= Just (last currWins)
-  -- This is safe, as we know there are >= 2 windows
-  let Just n = peek x
-  return $ peek (delete n x) == peek (focusDown x)
diff --git a/source/tests/Properties/Failure.hs b/source/tests/Properties/Failure.hs
deleted file mode 100644
index 454e887..0000000
--- a/source/tests/Properties/Failure.hs
+++ /dev/null
@@ -1,30 +0,0 @@
-module Properties.Failure where
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Control.Exception as C
-import System.IO.Unsafe
-import Data.List (isPrefixOf)
-
--- ---------------------------------------------------------------------
--- testing for failure and help out hpc
---
--- Since base 4.9.0.0 `error` appends a stack trace. The tests below
--- use `isPrefixOf` to only test equality on the error message.
---
-prop_abort :: Int -> Bool
-prop_abort _ = unsafePerformIO $ C.catch (abort "fail") check
-   where
-     check (C.SomeException e) =
-       return $ "xmonad: StackSet: fail" `isPrefixOf` show e
-
--- new should fail with an abort
-prop_new_abort :: Int -> Bool
-prop_new_abort _ = unsafePerformIO $ C.catch f check
-   where
-     f = new undefined{-layout-} [] [] `seq` return False
-     check (C.SomeException e) =
-       return $ "xmonad: StackSet: non-positive argument to StackSet.new" `isPrefixOf` show e
-
--- TODO: Fix this?
--- prop_view_should_fail = view {- with some bogus data -}
diff --git a/source/tests/Properties/Floating.hs b/source/tests/Properties/Floating.hs
deleted file mode 100644
index a9afad7..0000000
--- a/source/tests/Properties/Floating.hs
+++ /dev/null
@@ -1,36 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Floating where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Data.Map as M
-
-------------------------------------------------------------------------
--- properties for the floating layer:
-
-prop_float_reversible (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  return $ sink w (float w geom x) == x
-        where
-            geom = RationalRect 100 100 100 100
-
-prop_float_geometry (nex :: NonEmptyWindowsStackSet) = do
-    let NonEmptyWindowsStackSet x = nex
-    w <- arbitraryWindow nex
-    let s = float w geom x
-    return $ M.lookup w (floating s) == Just geom
-  where
-    geom = RationalRect 100 100 100 100
-
-prop_float_delete (nex :: NonEmptyWindowsStackSet) = do
-    let NonEmptyWindowsStackSet x = nex
-    w <- arbitraryWindow nex
-    let s = float w geom x
-        t = delete w s
-    return $ not (w `member` t)
-  where
-    geom = RationalRect 100 100 100 100
diff --git a/source/tests/Properties/Focus.hs b/source/tests/Properties/Focus.hs
deleted file mode 100644
index 6bc0055..0000000
--- a/source/tests/Properties/Focus.hs
+++ /dev/null
@@ -1,74 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Focus where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe (fromJust)
-
--- ---------------------------------------------------------------------
--- rotating focus
---
-
--- master/focus
---
--- The tiling order, and master window, of a stack is unaffected by focus changes.
---
-prop_focus_left_master (SizedPositive n) (x::T) =
-    index (applyN (Just n) focusUp x) == index x
-prop_focus_right_master (SizedPositive  n) (x::T) =
-    index (applyN (Just n) focusDown x) == index x
-prop_focus_master_master (SizedPositive n) (x::T) =
-    index (applyN (Just n) focusMaster x) == index x
-
-prop_focusWindow_master (NonNegative n) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = n `mod` length s
-                   in index (focusWindow (s !! i) x) == index x
-
--- shifting focus is trivially reversible
-prop_focus_left  (x :: T) = (focusUp  (focusDown x)) == x
-prop_focus_right (x :: T) = (focusDown (focusUp  x)) ==  x
-
--- focus master is idempotent
-prop_focusMaster_idem (x :: T) = focusMaster x == focusMaster (focusMaster x)
-
--- focusWindow actually leaves the window focused...
-prop_focusWindow_works (NonNegative (n :: Int)) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = fromIntegral n `mod` length s
-                   in (focus . fromJust . stack . workspace . current) (focusWindow (s !! i) x) == (s !! i)
-
--- rotation through the height of a stack gets us back to the start
-prop_focus_all_l (x :: T) = (foldr (const focusUp) x [1..n]) == x
-  where n = length (index x)
-prop_focus_all_r (x :: T) = (foldr (const focusDown) x [1..n]) == x
-  where n = length (index x)
-
--- prop_rotate_all (x :: T) = f (f x) == f x
---     f x' = foldr (\_ y -> rotate GT y) x' [1..n]
-
--- focus is local to the current workspace
-prop_focus_down_local (x :: T) = hidden_spaces (focusDown x) == hidden_spaces x
-prop_focus_up_local (x :: T) = hidden_spaces (focusUp x) == hidden_spaces x
-
-prop_focus_master_local (x :: T) = hidden_spaces (focusMaster x) == hidden_spaces x
-
-prop_focusWindow_local (NonNegative (n :: Int)) (x::T ) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = fromIntegral n `mod` length s
-                   in hidden_spaces (focusWindow (s !! i) x) == hidden_spaces x
-
--- On an invalid window, the stackset is unmodified
-prop_focusWindow_identity (x::T ) = do
-    n <- arbitrary `suchThat` \n' -> not $ n' `member` x
-    return $ focusWindow n x == x
diff --git a/source/tests/Properties/GreedyView.hs b/source/tests/Properties/GreedyView.hs
deleted file mode 100644
index 3f2eb9b..0000000
--- a/source/tests/Properties/GreedyView.hs
+++ /dev/null
@@ -1,44 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.GreedyView where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (sortBy)
-
--- ---------------------------------------------------------------------
--- greedyViewing workspaces
-
--- greedyView sets the current workspace to 'n'
-prop_greedyView_current (x :: T)  = do
-    n <- arbitraryTag x
-    return $ currentTag (greedyView n x) == n
-
--- greedyView leaves things unchanged for invalid workspaces
-prop_greedyView_current_id (x :: T) = do
-  n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-  return $ currentTag (greedyView n x) == currentTag x
-
--- greedyView *only* sets the current workspace, and touches Xinerama.
--- no workspace contents will be changed.
-prop_greedyView_local  (x :: T) = do
-    n <- arbitraryTag x
-    return $ workspaces x == workspaces (greedyView n x)
-  where
-    workspaces a = sortBy (\s t -> tag s `compare` tag t) $
-                                    workspace (current a)
-                                    : map workspace (visible a) ++ hidden a
-
--- greedyView is idempotent
-prop_greedyView_idem (x :: T) = do
-  n <- arbitraryTag x
-  return $ greedyView n (greedyView n x) == (greedyView n x)
-
--- greedyView is reversible, though shuffles the order of hidden/visible
-prop_greedyView_reversible (x :: T) = do
-    n <- arbitraryTag x
-    return $ normal (greedyView n' (greedyView n x)) == normal x
-    where n'  = currentTag x
diff --git a/source/tests/Properties/Insert.hs b/source/tests/Properties/Insert.hs
deleted file mode 100644
index c277795..0000000
--- a/source/tests/Properties/Insert.hs
+++ /dev/null
@@ -1,52 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Insert where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (nub)
-
--- ---------------------------------------------------------------------
--- 'insert'
-
--- inserting a item into an empty stackset means that item is now a member
-prop_insert_empty i (EmptyStackSet x)= member i (insertUp i x)
-
--- insert should be idempotent
-prop_insert_idem i (x :: T) = insertUp i x == insertUp i (insertUp i x)
-
--- insert when an item is a member should leave the stackset unchanged
-prop_insert_duplicate (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  return $ insertUp w x == x
-
--- push shouldn't change anything but the current workspace
-prop_insert_local (x :: T) = do
-  i <- arbitrary `suchThat` \i' -> not $ i' `member` x
-  return $ hidden_spaces x == hidden_spaces (insertUp i x)
-
--- Inserting a (unique) list of items into an empty stackset should
--- result in the last inserted element having focus.
-prop_insert_peek (EmptyStackSet x) (NonEmptyNubList is) =
-    peek (foldr insertUp x is) == Just (head is)
-
--- insert >> delete is the identity, when i `notElem` .
--- Except for the 'master', which is reset on insert and delete.
---
-prop_insert_delete x = do
-  n <- arbitrary `suchThat` \n -> not $ n `member` x
-  return $ delete n (insertUp n y) == (y :: T)
-    where
-        y = swapMaster x -- sets the master window to the current focus.
-                         -- otherwise, we don't have a rule for where master goes.
-
--- inserting n elements increases current stack size by n
-prop_size_insert is (EmptyStackSet x) =
-        size (foldr insertUp x ws ) ==  (length ws)
-  where
-    ws   = nub is
-    size = length . index
diff --git a/source/tests/Properties/Layout/Full.hs b/source/tests/Properties/Layout/Full.hs
deleted file mode 100644
index eca6ec3..0000000
--- a/source/tests/Properties/Layout/Full.hs
+++ /dev/null
@@ -1,34 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Layout.Full where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-import XMonad.Core
-import XMonad.Layout
-
-import Data.Maybe
-
-------------------------------------------------------------------------
--- Full layout
-
--- pureLayout works for Full
-prop_purelayout_full rect = do
-  x <- (arbitrary :: Gen T) `suchThat` (isJust . peek)
-  let layout = Full
-      st = fromJust . stack . workspace . current $ x
-      ts = pureLayout layout rect st
-  return $
-        length ts == 1        -- only one window to view
-      &&
-        snd (head ts) == rect -- and sets fullscreen
-      &&
-        fst (head ts) == fromJust (peek x) -- and the focused window is shown
-
-
--- what happens when we send an IncMaster message to Full --- Nothing
-prop_sendmsg_full (NonNegative k) =
-         isNothing (Full `pureMessage` (SomeMessage (IncMasterN k)))
-
-prop_desc_full = description Full == show Full
diff --git a/source/tests/Properties/Layout/Tall.hs b/source/tests/Properties/Layout/Tall.hs
deleted file mode 100644
index 5353e62..0000000
--- a/source/tests/Properties/Layout/Tall.hs
+++ /dev/null
@@ -1,116 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Layout.Tall where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-import XMonad.Core
-import XMonad.Layout
-
-import Graphics.X11.Xlib.Types (Rectangle(..))
-
-import Data.Maybe
-import Data.List (sort)
-import Data.Ratio
-
-------------------------------------------------------------------------
--- The Tall layout
-
--- 1 window should always be tiled fullscreen
-prop_tile_fullscreen rect = tile pct rect 1 1 == [rect]
-    where pct = 1/2
-
--- multiple windows
-prop_tile_non_overlap rect windows nmaster = noOverlaps (tile pct rect nmaster windows)
-  where _ = rect :: Rectangle
-        pct = 3 % 100
-
--- splitting horizontally yields sensible results
-prop_split_horizontal (NonNegative n) x =
-      (noOverflows (+) (rect_x x) (rect_width x)) ==>
-        sum (map rect_width xs) == rect_width x
-     &&
-        all (== rect_height x) (map rect_height xs)
-     &&
-        (map rect_x xs) == (sort $ map rect_x xs)
-
-    where
-        xs = splitHorizontally n x
-
--- splitting vertically yields sensible results
-prop_split_vertical (r :: Rational) x =
-        rect_x x == rect_x a && rect_x x == rect_x b
-      &&
-        rect_width x == rect_width a && rect_width x == rect_width b
-    where
-        (a,b) = splitVerticallyBy r x
-
-
--- pureLayout works.
-prop_purelayout_tall n r1 r2 rect = do
-  x <- (arbitrary :: Gen T) `suchThat` (isJust . peek)
-  let layout = Tall n r1 r2
-      st = fromJust . stack . workspace . current $ x
-      ts = pureLayout layout rect st
-  return $
-        length ts == length (index x)
-      &&
-        noOverlaps (map snd ts)
-      &&
-        description layout == "Tall"
-
-
--- Test message handling of Tall
-
--- what happens when we send a Shrink message to Tall
-prop_shrink_tall (NonNegative n) (Positive delta) (NonNegative frac) =
-        n == n' && delta == delta' -- these state components are unchanged
-    && frac' <= frac  && (if frac' < frac then frac' == 0 || frac' == frac - delta
-                                          else frac == 0 )
-        -- remaining fraction should shrink
-    where
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage Shrink)
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
-
--- what happens when we send a Shrink message to Tall
-prop_expand_tall (NonNegative n)
-                 (Positive delta)
-                 (NonNegative n1)
-                 (Positive d1) =
-
-       n == n'
-    && delta == delta' -- these state components are unchanged
-    && frac' >= frac
-    && (if frac' > frac
-           then frac' == 1 || frac' == frac + delta
-           else frac == 1 )
-
-        -- remaining fraction should shrink
-    where
-         frac                 = min 1 (n1 % d1)
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage Expand)
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
--- what happens when we send an IncMaster message to Tall
-prop_incmaster_tall (NonNegative n) (Positive delta) (NonNegative frac)
-                    (NonNegative k) =
-       delta == delta'  && frac == frac' && n' == n + k
-    where
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage (IncMasterN k))
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
-
-
-     --   toMessage LT = SomeMessage Shrink
-     --   toMessage EQ = SomeMessage Expand
-     --   toMessage GT = SomeMessage (IncMasterN 1)
-
-
-prop_desc_mirror n r1 r2 = description (Mirror $! t) == "Mirror Tall"
-    where t = Tall n r1 r2
diff --git a/source/tests/Properties/Screen.hs b/source/tests/Properties/Screen.hs
deleted file mode 100644
index b679fb9..0000000
--- a/source/tests/Properties/Screen.hs
+++ /dev/null
@@ -1,72 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Screen where
-
-import Utils
-import Test.QuickCheck
-import Instances
-
-import Control.Applicative
-import XMonad.StackSet hiding (filter)
-import XMonad.Operations
-import Graphics.X11.Xlib.Types (Dimension)
-
-import Graphics.X11 (Rectangle(Rectangle))
-import XMonad.Layout
-
-prop_screens (x :: T) = n `elem` screens x
- where
-    n = current x
-
--- screens makes sense
-prop_screens_works (x :: T) = screens x == current x : visible x
-
-
-------------------------------------------------------------------------
--- Hints
-
-prop_resize_inc (Positive inc_w,Positive inc_h)  b@(w,h) =
-    w' `mod` inc_w == 0 && h' `mod` inc_h == 0
-   where (w',h') = applyResizeIncHint a b
-         a = (inc_w,inc_h)
-
-prop_resize_inc_extra ((NonNegative inc_w))  b@(w,h) =
-     (w,h) == (w',h')
-   where (w',h') = applyResizeIncHint a b
-         a = (-inc_w,0::Dimension)-- inc_h)
-
-prop_resize_max (Positive inc_w,Positive inc_h)  b@(w,h) =
-    w' <= inc_w && h' <= inc_h
-   where (w',h') = applyMaxSizeHint a b
-         a = (inc_w,inc_h)
-
-prop_resize_max_extra ((NonNegative inc_w))  b@(w,h) =
-     (w,h) == (w',h')
-   where (w',h') = applyMaxSizeHint a b
-         a = (-inc_w,0::Dimension)-- inc_h)
-
-
-prop_aspect_hint_shrink hint (w,h) = case applyAspectHint hint (w,h) of
-  (w',h') -> w' <= w && h' <= h
-
-
--- applyAspectHint does nothing when the supplied (x,y) fits
--- the desired range
-prop_aspect_fits =
-    forAll ((,,,) <$> pos <*> pos <*> pos <*> pos) $ \ (x,y,a,b) ->
-    let f v = applyAspectHint ((x, y+a), (x+b, y)) v
-    in  and [ noOverflows (*) x (y+a), noOverflows (*) (x+b) y ]
-            ==> f (x,y) == (x,y)
-
-  where pos = choose (0, 65535)
-
-prop_point_within r@(Rectangle x y w h) =
-    forAll ((,) <$>
-              choose (0, fromIntegral w - 1) <*>
-              choose (0, fromIntegral h - 1)) $
-        \(dx,dy) ->
-    and [ dx > 0, dy > 0,
-         noOverflows (\ a b -> a + abs b) x w,
-         noOverflows (\ a b -> a + abs b) y h ]
-      ==> pointWithin (x+dx) (y+dy) r
-
-prop_point_within_mirror r (x,y) = pointWithin x y r == pointWithin y x (mirrorRect r)
diff --git a/source/tests/Properties/Shift.hs b/source/tests/Properties/Shift.hs
deleted file mode 100644
index 2150cbf..0000000
--- a/source/tests/Properties/Shift.hs
+++ /dev/null
@@ -1,70 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Shift where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Data.List as L
-
--- ---------------------------------------------------------------------
--- shift
-
--- shift is fully reversible on current window, when focus and master
--- are the same. otherwise, master may move.
-prop_shift_reversible (x :: T) = do
-    i <- arbitraryTag x
-    case peek y of
-      Nothing -> return True
-      Just _  -> return $ normal ((view n . shift n . view i . shift i) y) == normal y
-    where
-        y = swapMaster x
-        n = currentTag y
-
-------------------------------------------------------------------------
--- shiftMaster
-
--- focus/local/idempotent same as swapMaster:
-prop_shift_master_focus (x :: T) = peek x == (peek $ shiftMaster x)
-prop_shift_master_local (x :: T) = hidden_spaces x == hidden_spaces (shiftMaster x)
-prop_shift_master_idempotent (x :: T) = shiftMaster (shiftMaster x) == shiftMaster x
--- ordering is constant modulo the focused window:
-prop_shift_master_ordering (x :: T) = case peek x of
-    Nothing -> True
-    Just m  -> L.delete m (index x) == L.delete m (index $ shiftMaster x)
-
--- ---------------------------------------------------------------------
--- shiftWin
-
--- shiftWin on current window is the same as shift
-prop_shift_win_focus (x :: T) = do
-    n <- arbitraryTag x
-    case peek x of
-      Nothing -> return True
-      Just w  -> return $ shiftWin n w x == shift n x
-
--- shiftWin on a non-existant window is identity
-prop_shift_win_indentity (x :: T) = do
-    n <- arbitraryTag x
-    w <- arbitrary `suchThat` \w' -> not (w' `member` x)
-    return $ shiftWin n w x == x
-
--- shiftWin leaves the current screen as it is, if neither n is the tag
--- of the current workspace nor w on the current workspace
-prop_shift_win_fix_current = do
-  x <- arbitrary `suchThat` \(x' :: T) ->
-         -- Invariant, otherWindows are NOT in the current workspace.
-         let otherWindows = allWindows x' L.\\ index x'
-         in  length(tags x') >= 2 && length(otherWindows) >= 1
-  -- Sadly we have to construct `otherWindows` again, for the actual StackSet
-  -- that got chosen.
-  let otherWindows = allWindows x L.\\ index x
-  -- We know such tag must exists, due to the precondition
-  n <- arbitraryTag x `suchThat` (/= currentTag x)
-  -- we know length is >= 1, from above precondition
-  idx <- choose(0, length(otherWindows) - 1)
-  let w = otherWindows !! idx
-  return $ (current $ x) == (current $ shiftWin n w x)
-
diff --git a/source/tests/Properties/Stack.hs b/source/tests/Properties/Stack.hs
deleted file mode 100644
index 344c4c3..0000000
--- a/source/tests/Properties/Stack.hs
+++ /dev/null
@@ -1,83 +0,0 @@
-{-# LANGUAGE CPP #-}
-{-# LANGUAGE GeneralizedNewtypeDeriving #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Stack where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-import qualified XMonad.StackSet as S (filter)
-
-import Data.Maybe
-
-#ifdef VERSION_quickcheck_classes
-import Data.Proxy
-import Test.QuickCheck.Classes (
-    Laws (lawsTypeclass, lawsProperties), Proxy1 (Proxy1),
-    foldableLaws, traversableLaws,
-    )
-#endif
-
-
--- The list returned by index should be the same length as the actual
--- windows kept in the zipper
-prop_index_length (x :: T) =
-    case stack . workspace . current $ x of
-        Nothing   -> length (index x) == 0
-        Just it -> length (index x) == length (focus it : up it ++ down it)
-
-
--- For all windows in the stackSet, findTag should identify the
--- correct workspace
-prop_findIndex (x :: T) =
-    and [ tag w == fromJust (findTag i x)
-        | w <- workspace (current x) : map workspace (visible x)  ++ hidden x
-        , t <- maybeToList (stack w)
-        , i <- focus t : up t ++ down t
-        ]
-
-prop_allWindowsMember (NonEmptyWindowsStackSet x) = do
-      -- Reimplementation of arbitraryWindow, but to make sure that
-      -- implementation doesn't change in the future, and stop using allWindows,
-      -- which is a key component in this test (together with member).
-  let ws = allWindows x
-  -- We know that there are at least 1 window in a NonEmptyWindowsStackSet.
-  idx <- choose(0, (length ws) - 1)
-  return $ member (ws!!idx) x
-
-
--- preserve order
-prop_filter_order (x :: T) =
-    case stack $ workspace $ current x of
-        Nothing -> True
-        Just s@(Stack i _ _) -> integrate' (S.filter (/= i) s) == filter (/= i) (integrate' (Just s))
-
--- differentiate should return Nothing if the list is empty or Just stack, with
--- the first element of the list is current, and the rest of the list is down.
-prop_differentiate xs =
-        if null xs then differentiate xs == Nothing
-                   else (differentiate xs) == Just (Stack (head xs) [] (tail xs))
-    where _ = xs :: [Int]
-
-
-#ifdef VERSION_quickcheck_classes
--- Check type class laws of 'Data.Foldable.Foldable' and 'Data.Traversable.Traversable'.
-newtype TestStack a = TestStack (Stack a)
-    deriving (Eq, Read, Show, Foldable, Functor)
-
-instance (Arbitrary a) => Arbitrary (TestStack a) where
-   arbitrary = TestStack <$> (Stack <$> arbitrary <*> arbitrary <*> arbitrary)
-   shrink = traverse shrink
-
-instance Traversable TestStack where
-   traverse f (TestStack sx) = fmap TestStack (traverse f sx)
-
-prop_laws_Stack = format (foldableLaws p) <> format (traversableLaws p)
-  where
-    p = Proxy :: Proxy TestStack
-    format laws = [ ("Stack: " <> lawsTypeclass laws <> ": " <> name, prop)
-                  | (name, prop) <- lawsProperties laws ]
-#else
-prop_laws_Stack = []
-#endif
diff --git a/source/tests/Properties/StackSet.hs b/source/tests/Properties/StackSet.hs
deleted file mode 100644
index 7fc5192..0000000
--- a/source/tests/Properties/StackSet.hs
+++ /dev/null
@@ -1,135 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.StackSet where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe
-
-import Data.List (nub)
--- ---------------------------------------------------------------------
--- QuickCheck properties for the StackSet
-
--- Some general hints for creating StackSet properties:
---
--- *  ops that mutate the StackSet are usually local
--- *  most ops on StackSet should either be trivially reversible, or
---    idempotent, or both.
-------------------------------------------------------------------------
-
--- Basic data invariants of the StackSet
---
--- With the new zipper-based StackSet, tracking focus is no longer an
--- issue: the data structure enforces focus by construction.
---
--- But we still need to ensure there are no duplicates, and master/and
--- the xinerama mapping aren't checked by the data structure at all.
---
--- * no element should ever appear more than once in a StackSet
--- * the xinerama screen map should be:
---          -- keys should always index valid workspaces
---          -- monotonically ascending in the elements
--- * the current workspace should be a member of the xinerama screens
---
-invariant (s :: T) = and
-    -- no duplicates
-    [ noDuplicates
-
-    -- TODO: Fix this.
-    -- all this xinerama stuff says we don't have the right structure
---  , validScreens
---  , validWorkspaces
---  , inBounds
-    ]
-  where
-    ws = concat [ focus t : up t ++ down t
-                  | w <- workspace (current s) : map workspace (visible s) ++ hidden s
-                  , t <- maybeToList (stack w)] :: [Char]
-    noDuplicates = nub ws == ws
-
---  validScreens = monotonic . sort . M. . (W.current s : W.visible : W$ s
-
---  validWorkspaces = and [ w `elem` allworkspaces | w <- (M.keys . screens) s ]
---          where allworkspaces = map tag $ current s : prev s ++ next s
-
---  inBounds  = and [ w >=0 && w < size s | (w,sc) <- M.assocs (screens s) ]
-
-monotonic []       = True
-monotonic (x:[])   = True
-monotonic (x:y:zs) | x == y-1  = monotonic (y:zs)
-                   | otherwise = False
-
-prop_invariant = invariant
-
--- and check other ops preserve invariants
-prop_empty_I  (SizedPositive n) l = forAll (choose (1, fromIntegral n)) $  \m ->
-                                      forAll (vector m) $ \ms ->
-        invariant $ new l [0..fromIntegral n-1] ms
-
-prop_view_I n (x :: T) =
-    invariant $ view n x
-
-prop_greedyView_I n (x :: T) =
-    invariant $ greedyView n x
-
-prop_focusUp_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusUp x
-prop_focusMaster_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusMaster x
-prop_focusDown_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusDown x
-
-prop_focus_I (SizedPositive n) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let w = focus . fromJust . stack . workspace . current $
-                           applyN (Just n) focusUp x
-                   in invariant $ focusWindow w x
-
-prop_insertUp_I n (x :: T) = invariant $ insertUp n x
-
-prop_delete_I (x :: T) = invariant $
-    case peek x of
-        Nothing -> x
-        Just i  -> delete i x
-
-prop_swap_master_I (x :: T) = invariant $ swapMaster x
-
-prop_swap_left_I  (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) swapUp x
-prop_swap_right_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) swapDown x
-
-prop_shift_I (x :: T) = do
-  n <- arbitraryTag x
-  return $ invariant $ shift (fromIntegral n) x
-
-prop_shift_win_I (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  n <- arbitraryTag x
-  return $ invariant $ shiftWin n w x
-
-
--- ---------------------------------------------------------------------
-
-
--- empty StackSets have no windows in them
-prop_empty (EmptyStackSet x) =
-        all (== Nothing) [ stack w | w <- workspace (current x)
-                                        : map workspace (visible x) ++ hidden x ]
-
--- empty StackSets always have focus on first workspace
-prop_empty_current (EmptyStackSet x) = currentTag x == head (tags x)
-
--- no windows will be a member of an empty workspace
-prop_member_empty i (EmptyStackSet x) = member i x == False
-
--- peek either yields nothing on the Empty workspace, or Just a valid window
-prop_member_peek (x :: T) =
-    case peek x of
-        Nothing -> True {- then we don't know anything -}
-        Just i  -> member i x
diff --git a/source/tests/Properties/Swap.hs b/source/tests/Properties/Swap.hs
deleted file mode 100644
index a516f2c..0000000
--- a/source/tests/Properties/Swap.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Swap where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
--- ---------------------------------------------------------------------
--- swapUp, swapDown, swapMaster: reordiring windows
-
--- swap is trivially reversible
-prop_swap_left  (x :: T) = (swapUp  (swapDown x)) == x
-prop_swap_right (x :: T) = (swapDown (swapUp  x)) ==  x
--- TODO swap is reversible
--- swap is reversible, but involves moving focus back the window with
--- master on it. easy to do with a mouse...
-{-
-prop_promote_reversible x b = (not . null . fromMaybe [] . flip index x . current $ x) ==>
-                            (raiseFocus y . promote . raiseFocus z . promote) x == x
-  where _            = x :: T
-        dir          = if b then LT else GT
-        (Just y)     = peek x
-        (Just (z:_)) = flip index x . current $ x
--}
-
--- swap doesn't change focus
-prop_swap_master_focus (x :: T) = peek x == (peek $ swapMaster x)
---    = case peek x of
---        Nothing -> True
---        Just f  -> focus (stack (workspace $ current (swap x))) == f
-prop_swap_left_focus   (x :: T) = peek x == (peek $ swapUp   x)
-prop_swap_right_focus  (x :: T) = peek x == (peek $ swapDown  x)
-
--- swap is local
-prop_swap_master_local (x :: T) = hidden_spaces x == hidden_spaces (swapMaster x)
-prop_swap_left_local   (x :: T) = hidden_spaces x == hidden_spaces (swapUp   x)
-prop_swap_right_local  (x :: T) = hidden_spaces x == hidden_spaces (swapDown  x)
-
--- rotation through the height of a stack gets us back to the start
-prop_swap_all_l (x :: T) = (foldr (const swapUp)  x [1..n]) == x
-  where n = length (index x)
-prop_swap_all_r (x :: T) = (foldr (const swapDown) x [1..n]) == x
-  where n = length (index x)
-
-prop_swap_master_idempotent (x :: T) = swapMaster (swapMaster x) == swapMaster x
diff --git a/source/tests/Properties/View.hs b/source/tests/Properties/View.hs
deleted file mode 100644
index ef9b58d..0000000
--- a/source/tests/Properties/View.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.View where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (sortBy)
-
--- ---------------------------------------------------------------------
--- viewing workspaces
-
--- view sets the current workspace to 'n'
-prop_view_current (x :: T) = do
-    n <- arbitraryTag x
-    return $ (tag . workspace . current . view n) x == n
-
--- view *only* sets the current workspace, and touches Xinerama.
--- no workspace contents will be changed.
-prop_view_local  (x :: T) = do
-    n <- arbitraryTag x
-    return $ workspaces x == workspaces (view n x)
-  where
-    workspaces a = sortBy (\s t -> tag s `compare` tag t) $
-                                    workspace (current a)
-                                    : map workspace (visible a) ++ hidden a
-
--- TODO: Fix this
--- view should result in a visible xinerama screen
--- prop_view_xinerama (x :: T) (n :: NonNegative Int) = i `tagMember` x ==>
---     M.member i (screens (view i x))
---   where
---     i = fromIntegral n
-
--- view is idempotent
-prop_view_idem (x :: T) = do
-    n <- arbitraryTag x
-    return $ view n (view n x) == (view n x)
-
--- view is reversible, though shuffles the order of hidden/visible
-prop_view_reversible (x :: T) = do
-    n <- arbitraryTag x
-    return $ normal (view n' (view n x)) == normal x
-  where
-    n' = currentTag x
diff --git a/source/tests/Properties/Workspace.hs b/source/tests/Properties/Workspace.hs
deleted file mode 100644
index 612cba9..0000000
--- a/source/tests/Properties/Workspace.hs
+++ /dev/null
@@ -1,65 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Workspace where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe
-
--- looking up the tag of the current workspace should always produce a tag.
-prop_lookup_current (x :: T) = lookupWorkspace scr x == Just tg
-    where
-        (Screen (Workspace tg  _ _) scr _) = current x
-
--- looking at a visible tag
-prop_lookup_visible = do
-  -- make sure we have some xinerama screens.
-  x <- arbitrary `suchThat` \(x' :: T) -> visible x' /= []
-  let tags = [ tag (workspace y) | y <- visible x ]
-      scr = last [ screen y | y <- visible x ]
-  return $ fromJust (lookupWorkspace scr x) `elem` tags
-
-
-prop_currentTag (x :: T) =
-    currentTag x == tag (workspace (current x))
-
--- Rename a given tag if present in the StackSet.
-prop_rename1 (x::T) = do
-  o <- arbitraryTag x
-  n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-  -- Rename o to n
-  let y = renameTag o n x
-  return $ n `tagMember` y
-
--- Ensure that a given set of workspace tags is present by renaming
--- existing workspaces and\/or creating new hidden workspaces as
--- necessary.
---
-prop_ensure (x :: T) l xs = let y = ensureTags l xs x
-                                in and [ n `tagMember` y | n <- xs ]
-
--- adding a tag should create a new hidden workspace
-prop_ensure_append (x :: T) l = do
-    n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-    let ts = tags x
-        y  = ensureTags l (n:ts) x
-    return $ hidden y /= hidden x     -- doesn't append, renames
-             && and [ isNothing (stack z) && layout z == l | z <- hidden y, tag z == n ]
-
-
-
-
-prop_mapWorkspaceId (x::T) = x == mapWorkspace id x
-
-prop_mapWorkspaceInverse (x::T) = x == mapWorkspace predTag (mapWorkspace succTag x)
-  where predTag w = w { tag = pred $ tag w }
-        succTag w = w { tag = succ $ tag w }
-
-prop_mapLayoutId (x::T) = x == mapLayout id x
-
-prop_mapLayoutInverse (x::T) = x == mapLayout pred (mapLayout succ x)
-
-
diff --git a/source/tests/Properties.hs b/source/tests/Properties.hs
deleted file mode 100644
index 6c7013c..0000000
--- a/source/tests/Properties.hs
+++ /dev/null
@@ -1,200 +0,0 @@
-import Test.QuickCheck
-
--- Our QC instances and properties:
-import Instances
-import Properties.Delete
-import Properties.Failure
-import Properties.Floating
-import Properties.Focus
-import Properties.GreedyView
-import Properties.Insert
-import Properties.Screen
-import Properties.Shift
-import Properties.Stack
-import Properties.StackSet
-import Properties.Swap
-import Properties.View
-import Properties.Workspace
-import Properties.Layout.Full
-import Properties.Layout.Tall
-
-import System.Environment
-import Text.Printf
-
-import Control.Monad
-import Control.Applicative
-
-main :: IO ()
-main = do
-  arg <- fmap (drop 1) getArgs
-  let n = if null arg then 100 else read $ head arg
-      args = stdArgs { maxSuccess = n, maxSize = 100 }
-      qc t = do
-          c <- quickCheckWithResult args t
-          case c of
-            Success {} -> return True
-            _ -> return False
-      perform (s, t) = printf "%-35s: " s >> qc t
-  n <- length . filter not <$> mapM perform tests
-  unless (n == 0) (error (show n ++ " test(s) failed"))
-
-
-
-tests =
-  [("StackSet invariants", property prop_invariant)
-  ,("empty: invariant",    property prop_empty_I)
-  ,("empty is empty",      property prop_empty)
-  ,("empty / current",     property prop_empty_current)
-  ,("empty / member",      property prop_member_empty)
-
-
-  ,("view : invariant",  property prop_view_I)
-  ,("view sets current", property prop_view_current)
-  ,("view idempotent",   property prop_view_idem)
-  ,("view reversible",   property prop_view_reversible)
-
-  ,("view is local",  property prop_view_local)
-
-  ,("greedyView : invariant",  property prop_greedyView_I)
-  ,("greedyView sets current", property prop_greedyView_current)
-  ,("greedyView is safe",      property prop_greedyView_current_id)
-  ,("greedyView idempotent",   property prop_greedyView_idem)
-  ,("greedyView reversible",   property prop_greedyView_reversible)
-  ,("greedyView is local",     property prop_greedyView_local)
-
-  ,("peek/member",  property prop_member_peek)
-
-  ,("index/length", property prop_index_length)
-
-  ,("focus left : invariant",    property prop_focusUp_I)
-  ,("focus master : invariant",  property prop_focusMaster_I)
-  ,("focus right: invariant",    property prop_focusDown_I)
-  ,("focusWindow: invariant",    property prop_focus_I)
-  ,("focus left/master",         property prop_focus_left_master)
-  ,("focus right/master",        property prop_focus_right_master)
-  ,("focus master/master",       property prop_focus_master_master)
-  ,("focusWindow master",        property prop_focusWindow_master)
-  ,("focus left/right",          property prop_focus_left)
-  ,("focus right/left",          property prop_focus_right)
-  ,("focus all left",            property prop_focus_all_l)
-  ,("focus all right",           property prop_focus_all_r)
-  ,("focus down is local",       property prop_focus_down_local)
-  ,("focus up is local",         property prop_focus_up_local)
-  ,("focus master is local",     property prop_focus_master_local)
-  ,("focus master idemp",        property prop_focusMaster_idem)
-
-  ,("focusWindow is local", property prop_focusWindow_local)
-  ,("focusWindow works"   , property prop_focusWindow_works)
-  ,("focusWindow identity", property prop_focusWindow_identity)
-
-  ,("findTag",           property prop_findIndex)
-  ,("allWindows/member", property prop_allWindowsMember)
-  ,("currentTag",        property prop_currentTag)
-
-  ,("insert: invariant",    property prop_insertUp_I)
-  ,("insert/new",           property prop_insert_empty)
-  ,("insert is idempotent", property prop_insert_idem)
-  ,("insert is reversible", property prop_insert_delete)
-  ,("insert is local",      property prop_insert_local)
-  ,("insert duplicates",    property prop_insert_duplicate)
-  ,("insert/peek",          property prop_insert_peek)
-  ,("insert/size",          property prop_size_insert)
-
-  ,("delete: invariant",       property prop_delete_I)
-  ,("delete/empty",            property prop_empty)
-  ,("delete/member",           property prop_delete)
-  ,("delete is reversible",    property prop_delete_insert)
-  ,("delete is local",         property prop_delete_local)
-  ,("delete/focus",            property prop_delete_focus)
-  ,("delete  last/focus up",   property prop_delete_focus_end)
-  ,("delete ~last/focus down", property prop_delete_focus_not_end)
-
-  ,("filter preserves order", property prop_filter_order)
-
-  ,("swapLeft",  property prop_swap_left)
-  ,("swapRight", property prop_swap_right)
-
-  ,("swapMaster: invariant",    property prop_swap_master_I)
-  ,("swapUp: invariant" ,       property prop_swap_left_I)
-  ,("swapDown: invariant",      property prop_swap_right_I)
-  ,("swapMaster id on focus",   property prop_swap_master_focus)
-  ,("swapUp id on focus",       property prop_swap_left_focus)
-  ,("swapDown id on focus",     property prop_swap_right_focus)
-  ,("swapMaster is idempotent", property prop_swap_master_idempotent)
-  ,("swap all left",            property prop_swap_all_l)
-  ,("swap all right",           property prop_swap_all_r)
-  ,("swapMaster is local",      property prop_swap_master_local)
-  ,("swapUp is local",          property prop_swap_left_local)
-  ,("swapDown is local",        property prop_swap_right_local)
-
-  ,("shiftMaster id on focus",        property prop_shift_master_focus)
-  ,("shiftMaster is local",           property prop_shift_master_local)
-  ,("shiftMaster is idempotent",      property prop_shift_master_idempotent)
-  ,("shiftMaster preserves ordering", property prop_shift_master_ordering)
-
-  ,("shift: invariant"    ,       property prop_shift_I)
-  ,("shift is reversible" ,       property prop_shift_reversible)
-  ,("shiftWin: invariant" ,       property prop_shift_win_I)
-  ,("shiftWin is shift on focus", property prop_shift_win_focus)
-  ,("shiftWin fix current" ,      property prop_shift_win_fix_current)
-  ,("shiftWin identity",          property prop_shift_win_indentity)
-
-  ,("floating is reversible" ,  property prop_float_reversible)
-  ,("floating sets geometry" ,  property prop_float_geometry)
-  ,("floats can be deleted",    property prop_float_delete)
-  ,("screens includes current", property prop_screens)
-
-  ,("differentiate works",     property prop_differentiate)
-  ,("lookupTagOnScreen",       property prop_lookup_current)
-  ,("lookupTagOnVisbleScreen", property prop_lookup_visible)
-  ,("screens works",           property prop_screens_works)
-  ,("renaming works",          property prop_rename1)
-  ,("ensure works",            property prop_ensure)
-  ,("ensure hidden semantics", property prop_ensure_append)
-
-  ,("mapWorkspace id",      property prop_mapWorkspaceId)
-  ,("mapWorkspace inverse", property prop_mapWorkspaceInverse)
-
-  ,("mapLayout id",      property prop_mapLayoutId)
-  ,("mapLayout inverse", property prop_mapLayoutInverse)
-
-  ,("abort fails",            property prop_abort)
-  ,("new fails with abort",   property prop_new_abort)
-
-  ,("point within",           property prop_point_within)
-
-  -- tall layout
-
-  ,("tile 1 window fullsize", property prop_tile_fullscreen)
-  ,("tiles never overlap",    property prop_tile_non_overlap)
-  ,("split horizontal",       property prop_split_horizontal)
-  ,("split vertical",         property prop_split_vertical)
-
-  ,("pure layout tall",       property prop_purelayout_tall)
-  ,("send shrink    tall",    property prop_shrink_tall)
-  ,("send expand    tall",    property prop_expand_tall)
-  ,("send incmaster tall",    property prop_incmaster_tall)
-
-  -- full layout
-
-  ,("pure layout full",       property prop_purelayout_full)
-  ,("send message full",      property prop_sendmsg_full)
-  ,("describe full",          property prop_desc_full)
-
-  ,("describe mirror",        property prop_desc_mirror)
-
-  -- resize hints
-  ,("window resize hints: inc",      property prop_resize_inc)
-  ,("window resize hints: inc all",  property prop_resize_inc_extra)
-  ,("window resize hints: max",      property prop_resize_max)
-  ,("window resize hints: max all ", property prop_resize_max_extra)
-
-  ,("window aspect hints: fits", property prop_aspect_fits)
-  ,("window aspect hints: shrinks ", property prop_aspect_hint_shrink)
-
-
-  ,("pointWithin",        property prop_point_within)
-  ,("pointWithin mirror", property prop_point_within_mirror)
-
-  ] <>
-  prop_laws_Stack
diff --git a/source/tests/Utils.hs b/source/tests/Utils.hs
deleted file mode 100644
index e3eef0f..0000000
--- a/source/tests/Utils.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE RankNTypes #-}
-module Utils where
-
-import XMonad.StackSet hiding (filter)
-import Graphics.X11.Xlib.Types (Rectangle(..))
-import Data.List (sortBy)
-
--- Useful operation, the non-local workspaces
-hidden_spaces x = map workspace (visible x) ++ hidden x
-
-
--- normalise workspace list
-normal s = s { hidden = sortBy g (hidden s), visible = sortBy f (visible s) }
-    where
-        f = \a b -> tag (workspace a) `compare` tag (workspace b)
-        g = \a b -> tag a `compare` tag b
-
-
-noOverlaps []  = True
-noOverlaps [_] = True
-noOverlaps xs  = and [ verts a `notOverlap` verts b
-                     | a <- xs
-                     , b <- filter (a /=) xs
-                     ]
-    where
-      verts (Rectangle a b w h) = (a,b,a + fromIntegral w - 1, b + fromIntegral h - 1)
-
-      notOverlap (left1,bottom1,right1,top1)
-                 (left2,bottom2,right2,top2)
-        =  (top1 < bottom2 || top2 < bottom1)
-        || (right1 < left2 || right2 < left1)
-
-
-applyN :: (Integral n) => Maybe n -> (a -> a) -> a -> a
-applyN Nothing f v = v
-applyN (Just 0) f v = v
-applyN (Just n) f v = applyN (Just $ n-1) f (f v)
-
-tags x = map tag $ workspaces x
-
-
--- | noOverflows op a b is True if @a `op` fromIntegral b@ overflows (or
--- otherwise gives the same answer when done using Integer
-noOverflows :: (Integral b, Integral c) =>
-  (forall a. Integral a => a -> a -> a) -> b -> c -> Bool
-noOverflows op a b = toInteger (a `op` fromIntegral b) == toInteger a `op` toInteger b
-
diff --git a/source/tests/loc.hs b/source/tests/loc.hs
deleted file mode 100644
index 238204a..0000000
--- a/source/tests/loc.hs
+++ /dev/null
@@ -1,14 +0,0 @@
-import Control.Monad
-import System.Exit
-
-main = do foo <- getContents
-          let actual_loc = filter (not.null) $ filter isntcomment $
-                           map (dropWhile (==' ')) $ lines foo
-              loc = length actual_loc
-          print loc
-          -- uncomment the following to check for mistakes in isntcomment
-          -- print actual_loc
-
-isntcomment ('-':'-':_) = False
-isntcomment ('{':'-':_) = False -- pragmas
-isntcomment _ = True
diff --git a/source/util/GenerateManpage.hs b/source/util/GenerateManpage.hs
deleted file mode 100755
index 4284cc3..0000000
--- a/source/util/GenerateManpage.hs
+++ /dev/null
@@ -1,73 +0,0 @@
-#!/usr/bin/env runhaskell
-
--- Reads markdown (man/xmonad.1.markdown) from stdin, subtitutes
--- ___KEYBINDINGS___ for key-binding definitions generated from
--- src/XMonad/Config.hs, prints result to stdout.
---
--- Unlike the rest of xmonad, this file is released under the GNU General
--- Public License version 2 or later. (Historical reasons, used to link with
--- GPL-licensed pandoc.)
-
-import Data.Char
-import Data.List
-
-main :: IO ()
-main = do
-    keybindings <- guessBindings
-    interact $ unlines . replace "___KEYBINDINGS___" keybindings . lines
-
--- | The format for the docstrings in "Config.hs" takes the following form:
---
--- @
---   -- mod-x %! Frob the whatsit
--- @
---
--- "Frob the whatsit" will be used as the description for keybinding "mod-x".
--- If the name of the key binding is omitted, the function tries to guess it
--- from the rest of the line. For example:
---
--- @
---   [ ((modMask .|. shiftMask, xK_Return), spawn "xterm") -- %! Launch an xterm
--- @
---
--- Here, "mod-shift-return" will be used as the key binding name.
-
-guessBindings :: IO String
-guessBindings = do
-    buf <- readFile "./src/XMonad/Config.hs"
-    return (intercalate "\n\n" (map markdownDefn (allBindings buf)))
-
-allBindings :: String -> [(String, String)]
-allBindings = concatMap parseLine . lines
-  where
-    parseLine :: String -> [(String, String)]
-    parseLine l
-        | " -- " `isInfixOf` l
-        , Just d <- parseDesc l = [(intercalate "-" (parseKeys l), d)]
-        | otherwise = []
-
-    parseDesc :: String -> Maybe String
-    parseDesc = fmap (trim . drop 4) . find (" %! " `isPrefixOf`) . tails
-
-    parseKeys :: String -> [String]
-    parseKeys l = case lex l of
-        [("", _)] -> []
-        [("--", rest)] -> case words rest of
-            k : "%!" : _ -> [k]
-            _ -> []
-        [(k, rest)] -> parseKey k ++ parseKeys rest
-
-    parseKey :: String -> [String]
-    parseKey k | "Mask" `isSuffixOf` k = [reverse (drop 4 (reverse k))]
-               | "xK_"  `isPrefixOf` k = [map toLower (drop 3 k)]
-               | otherwise             = []
-
--- FIXME: What escaping should we be doing on these strings?
-markdownDefn :: (String, String) -> String
-markdownDefn (key, desc) = key ++ "\n:     " ++ desc
-
-replace :: Eq a => a -> a -> [a] -> [a]
-replace x y = map (\a -> if a == x then y else a)
-
-trim :: String -> String
-trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace
diff --git a/source/util/hpcReport.sh b/source/util/hpcReport.sh
deleted file mode 100644
index ab934b3..0000000
--- a/source/util/hpcReport.sh
+++ /dev/null
@@ -1,33 +0,0 @@
-#!/bin/bash
-
-set -e
-
-if [[ ! ( -e xmonad.cabal && -e dist/hpc/tix/properties/properties.tix ) ]]; then
-  echo "run in the same dir as xmonad.cabal after having run
-
-      cabal configure --enable-tests --enable-library-coverage; cabal test
-
-        "
-  exit 1
-fi
-
-
-propsExclude=$(find tests/Properties -name '*.hs' \
-        | sed -e 's_/_._g' -e 's_.hs$__' -e 's_^tests._--exclude=_' )
-
-hpcFlags="
-  --hpcdir=dist/hpc/mix/
-  dist/hpc/tix/properties/properties.tix
-  "
-
-
-if [[ ! (-e dist/hpc/mix/Main.mix) ]]; then
-  mv dist/hpc/mix/properties/* dist/hpc/mix/
-  mv dist/hpc/mix/xmonad-*/xmonad-*/* dist/hpc/mix/xmonad-*/
-fi
-
-
-hpc markup --destdir=dist/hpc $hpcFlags > /dev/null
-echo "see dist/hpc/hpc_index.html
-"
-hpc report $hpcFlags
