diff --git a/source/.github/ISSUE_TEMPLATE.md b/source/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index d837a67..0000000
--- a/source/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,24 +0,0 @@
-### Problem Description
-
-Describe the problem you are having, what you expect to happen
-instead, and how to reproduce the problem.
-
-### Configuration File
-
-Please include the smallest configuration file that reproduces the
-problem you are experiencing:
-
-```haskell
-module Main (main) where
-
-import XMonad
-
-main :: IO ()
-main = xmonad def
-```
-
-### Checklist
-
-  - [ ] I've read [CONTRIBUTING.md](https://github.com/xmonad/xmonad/blob/master/CONTRIBUTING.md)
-
-  - [ ] I tested my configuration with [xmonad-testing](https://github.com/xmonad/xmonad-testing)
diff --git a/source/.github/PULL_REQUEST_TEMPLATE.md b/source/.github/PULL_REQUEST_TEMPLATE.md
deleted file mode 100644
index 92edcea..0000000
--- a/source/.github/PULL_REQUEST_TEMPLATE.md
+++ /dev/null
@@ -1,14 +0,0 @@
-### Description
-
-Include a description for your changes, including the motivation
-behind them.
-
-### Checklist
-
-  - [ ] I've read [CONTRIBUTING.md](https://github.com/xmonad/xmonad/blob/master/CONTRIBUTING.md)
-
-  - [ ] I've confirmed these changes don't belong in xmonad-contrib instead
-
-  - [ ] I tested my changes with [xmonad-testing](https://github.com/xmonad/xmonad-testing)
-
-  - [ ] I updated the `CHANGES.md` file
diff --git a/source/.github/workflows/tests.yml b/source/.github/workflows/tests.yml
deleted file mode 100644
index b0e47a8..0000000
--- a/source/.github/workflows/tests.yml
+++ /dev/null
@@ -1,39 +0,0 @@
-name: Stack Tests
-
-on:
-    pull_request:
-    push:
-        branches:
-        - master
-
-jobs:
-  build:
-    name: CI
-    runs-on: ${{ matrix.os }}
-    strategy:
-      fail-fast: false
-      matrix:
-        os: [ubuntu-latest]
-        resolver: [lts-16, lts-15, lts-14, lts-12]
-
-    steps:
-      - name: Clone project
-        uses: actions/checkout@v2
-
-      - name: Cache dependencies
-        uses: actions/cache@v2
-        with:
-          path: ~/.stack
-          key: ${{ runner.os }}-${{ matrix.resolver }}-${{ hashFiles('stack.yaml') }}
-          restore-keys: |
-            ${{ runner.os }}-${{ matrix.resolver }}-
-
-      - name: Build and run tests
-        shell: bash
-        run: |
-            set -ex
-            curl -sSL https://get.haskellstack.org/ | sh -s - -f
-            sudo apt install -y libasound2 libasound2-dev libxrandr-dev libtinfo-dev
-            sudo apt install -y libx11-dev libgmp-dev libxss-dev libxft-dev
-            stack test --fast --no-terminal --resolver=${{ matrix.resolver }}
-
diff --git a/source/CHANGES.md b/source/CHANGES.md
deleted file mode 100644
index a146f2d..0000000
--- a/source/CHANGES.md
+++ /dev/null
@@ -1,178 +0,0 @@
-# Change Log / Release Notes
-
-## unknown (unknown)
-
-  * Fixed a bug when using multiple screens with different dimensions,
-    causing some floating windows to be smaller/larger than the size they
-    requested.
-
-  * Added `Typeable layout` constraint to `LayoutClass`, making it possible to
-    cast `Layout` back into a concrete type and extract current layout state
-    from it.
-
-  * Export constructor for `Choose` and `CLR` from `Module.Layout` to allow
-    pattern-matching on the left and right sub-layouts of `Choose l r a`.
-
-## 0.15 (September 30, 2018)
-
-  * Reimplement `sendMessage` to deal properly with windowset changes made
-    during handling.
-
-  * Add new library functions `windowBracket` and `modifyWindowSet` to
-    `XMonad.Operations`.
-
-## 0.14.2 (August 21, 2018)
-
-### Bug Fixes
-
-  * Add the sample configuration file xmonad.hs again to the release tarball.
-    [https://github.com/xmonad/xmonad/issues/181]
-
-## 0.14.1 (August 20, 2018)
-
-### Breaking Changes
-
-  * The cabal build no longer installs xmonad.hs, xmonad.1, and xmonad.1.html
-    as data files. The location cabal picks for chose files isn't useful as
-    standard tools like man(1) won't find them there. Instead, we rely on
-    distributors to pick up the files from the source tarball during the build
-    and to install them into proper locations where their users expect them.
-    [https://github.com/xmonad/xmonad/pull/127]
-
-### Bug Fixes
-
-  * Add support for GHC 8.6.x by providing an instance for 'MonadFail X'. A
-    side effect of that change is that our code no longer compiles with GHC
-    versions prior to 8.0.x. We could work around that, no doubt, but the
-    resulting code would require CPP and Cabal flags and whatnot. It feels more
-    reasonable to just require a moderately recent compiler instead of going
-    through all that trouble.
-
-  * xmonad no longer always recompile on startup. Now it only does so if the
-    executable does not have the name that would be used for the compilation
-    output. The purpose of recompiling and executing the results in this case is
-    so that the `xmonad` executable in the package can be used with custom
-    configurations.
-
-### Enhancements
-
-  * Whenever xmonad recompiles, it now explains how it is attempting to
-    recompile, by outputting logs to stderr. If you are using xmonad as a custom
-    X session, then this will end up in a `.xsession-errors` file.
-
-## 0.14 (July 30, 2018)
-
-### Bug Fixes
-
-  * The state file that xmonad uses while restarting itself is now
-    removed after it is processed.  This fixes a bug that manifested
-    in several different ways:
-
-    - Names of old workspaces would be resurrected after a restart
-    - Screen sizes would be wrong after changing monitor configuration (#90)
-    - `spawnOnce` stopped working (xmonad/xmonad-contrib#155)
-    - Focus did not follow when moving between workspaces (#87)
-    - etc.
-
-  * Recover old behavior (in 0.12) when `focusFollowsMouse == True`:
-    the focus follows when the mouse enters another workspace
-    but not moving into any window.
-
-  * Compiles with GHC 8.4.1
-
-  * Restored compatability with GHC version prior to 8.0.1 by removing the
-    dependency on directory version 1.2.3.
-
-
-## 0.13 (February 10, 2017)
-
-### Breaking Changes
-
-  * When restarting xmonad, resume state is no longer passed to the
-    next process via the command line.  Instead, a temporary state
-    file is created and xmonad's state is serialized to that file.
-
-    When upgrading to 0.13 from a previous version, the `--resume`
-    command line option will automatically migrate to a state file.
-
-    This fixes issue #12.
-
-### Enhancements
-
-  * You can now control which directory xmonad uses for finding your
-    configuration file and which one is used for storing the compiled
-    version of your configuration.  In order of preference:
-
-      1. New environment variables.  If you want to use these ensure
-         you set the correct environment variable and also create the
-         directory it references:
-
-         - `XMONAD_CONFIG_DIR`
-         - `XMONAD_CACHE_DIR`
-         - `XMONAD_DATA_DIR`
-
-      2. The `~/.xmonad` directory.
-
-      3. XDG Base Directory Specification directories, if they exist:
-
-         - `XDG_CONFIG_HOME/xmonad`
-         - `XDG_CACHE_HOME/xmonad`
-         - `XDG_DATA_HOME/xmonad`
-
-    If none of these directories exist then one will be created using
-    the following logic: If the relevant environment variable
-    mentioned in step (1) above is set, the referent directory will be
-    created and used.  Otherwise `~/.xmonad` will be created and used.
-
-    This fixes a few issues, notably #7 and #56.
-
-  * A custom build script can be used when xmonad is given the
-    `--recompile` command line option.  If an executable named `build`
-    exists in the xmonad configuration directory it will be called
-    instead of `ghc`.  It takes one argument, the name of the
-    executable binary it must produce.
-
-    This fixes #8.  (One of two possible custom build solutions.  See
-    the next entry for another solution.)
-
-  * For users who build their xmonad configuration using tools such as
-    cabal or stack, there is another option for executing xmonad.
-
-    Instead of running the `xmonad` executable directly, arrange to
-    have your login manager run your configuration binary instead.
-    Then, in your binary, use the new `launch` command instead of
-    `xmonad`.
-
-    This will keep xmonad from using its configuration file
-    checking/compiling code and directly start the window manager
-    without `exec`ing any other binary.
-
-    See the documentation for the `launch` function in `XMonad.Main`
-    for more details.
-
-    Fixes #8.  (Second way to have a custom build environment for
-    XMonad.  See previous entry for another solution.)
-
-## 0.12 (December 14, 2015)
-
-  * Compiles with GHC 7.10.2, 7.8.4, and 7.6.3
-
-  * Use of [data-default][] allows using `def` where previously you
-    had to write `defaultConfig`, `defaultXPConfig`, etc.
-
-  * The [setlocale][] package is now used instead of a binding shipped
-    with xmonad proper allowing the use of `Main.hs` instead of
-    `Main.hsc`
-
-  * No longer encodes paths for `spawnPID`
-
-  * The default `manageHook` no longer floats Gimp windows
-
-  * Doesn't crash when there are fewer workspaces than screens
-
-  * `Query` is now an instance of `Applicative`
-
-  * Various improvements to the example configuration file
-
-[data-default]: http://hackage.haskell.org/package/data-default
-[setlocale]: https://hackage.haskell.org/package/setlocale
diff --git a/source/CONFIG b/source/CONFIG
deleted file mode 100644
index f83292b..0000000
--- a/source/CONFIG
+++ /dev/null
@@ -1,82 +0,0 @@
-== Configuring xmonad ==
-
-xmonad is configured by creating and editing the file:
-
-    ~/.xmonad/xmonad.hs
-
-xmonad then uses settings from this file as arguments to the window manager,
-on startup. For a complete example of possible settings, see the file:
-
-    man/xmonad.hs
-
-Further examples are on the website, wiki and extension documentation.
-
-    http://haskell.org/haskellwiki/Xmonad
-
-== A simple example ==
-
-Here is a basic example, which overrides the default border width,
-default terminal, and some colours. This text goes in the file
-$HOME/.xmonad/xmonad.hs :
-
-    import XMonad
-
-    main = xmonad $ def
-        { borderWidth        = 2
-        , terminal           = "urxvt"
-        , normalBorderColor  = "#cccccc"
-        , focusedBorderColor = "#cd8b00" }
-
-You can find the defaults in the file:
-
-    XMonad/Config.hs
-
-== Checking your xmonad.hs is correct ==
-
-Place this text in ~/.xmonad/xmonad.hs, and then check that it is
-syntactically and type correct by loading it in the Haskell
-interpreter:
-
-    $ ghci ~/.xmonad/xmonad.hs
-    GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
-    Loading package base ... linking ... done.
-    Ok, modules loaded: Main.
-
-    Prelude Main> :t main
-    main :: IO ()
-
-Ok, looks good.
-
-== Loading your configuration ==
-
-To have xmonad start using your settings, type 'mod-q'.  xmonad will
-then load this new file, and run it.  If it is unable to, the defaults
-are used.
-
-To load successfully, both 'xmonad' and 'ghc' must be in your $PATH
-environment variable.  If GHC isn't in your path, for some reason, you
-can compile the xmonad.hs file yourself:
-
-    $ cd ~/.xmonad
-    $ ghc --make xmonad.hs
-    $ ls
-    xmonad    xmonad.hi xmonad.hs xmonad.o
-
-When you hit mod-q, this newly compiled xmonad will be used.
-
-== Where are the defaults? ==
-
-The default configuration values are defined in the source file:
-
-    XMonad/Config.hs
-
-the XConfig data structure itself is defined in:
-
-    XMonad/Core.hs
-
-== Extensions ==
-
-Since the xmonad.hs file is just another Haskell module, you may import
-and use any Haskell code or libraries you wish. For example, you can use
-things from the xmonad-contrib library, or other code you write
-yourself.
diff --git a/source/CONTRIBUTING.md b/source/CONTRIBUTING.md
deleted file mode 100644
index b8d4796..0000000
--- a/source/CONTRIBUTING.md
+++ /dev/null
@@ -1,141 +0,0 @@
-# Contributing to xmonad and xmonad-contrib
-
-## Before Creating a GitHub Issue
-
-New issue submissions should adhere to the following guidelines:
-
-  * Does your issue have to do with [xmonad][], [xmonad-contrib][], or
-    maybe even with the [X11][] library?
-
-    Please submit your issue to the **correct** GitHub repository.
-
-  * To help you figure out which repository to submit your issue to,
-    and to help us resolve the problem you are having, create the
-    smallest configuration file you can that reproduces the problem.
-
-    You may find that the [xmonad-testing][] repository is helpful in
-    reproducing the problem with a smaller configuration file.
-
-    Once you've done that please include the configuration file with
-    your GitHub issue.
-
-  * If possible, use the [xmonad-testing][] repository to test your
-    configuration with the bleeding-edge development version of xmonad
-    and xmonad-contrib.  We might have already fixed your problem.
-
-## Contributing Changes/Patches
-
-Have a change to xmonad that you want included in the next release?
-Awesome!  Here are a few things to keep in mind:
-
-  * Review the above section about creating GitHub issues.
-
-  * It's always best to talk with the community before making any
-    nontrivial changes to xmonad.  There are a couple of ways you can
-    chat with us:
-
-    - Post a message to the [mailing list][ml].
-
-    - Join the `#xmonad` IRC channel on `chat.freenode.org`.
-
-  * Continue reading this document!
-
-## Expediting Reviews and Merges
-
-Here are some tips for getting your changes merged into xmonad:
-
-  * If your changes can go into [xmonad-contrib][] instead
-    of [xmonad][], please do so.  We rarely accept new features to
-    xmonad.  (Not that we don't accept changes to xmonad, just that we
-    prefer changes to xmonad-contrib instead.)
-
-  * Change the fewest files as possible.  If it makes sense, submit a
-    completely new module to xmonad-contrib.
-
-  * Your changes should include relevant entries in the `CHANGES.md`
-    file.  Help us communicate changes to the community.
-
-  * Make sure you test your changes using the [xmonad-testing][]
-    repository.  Include a new configuration file that shows off your
-    changes if possible by creating a PR on that repository as well.
-
-  * Make sure you read the section on rebasing and squashing commits
-    below.
-
-## Rebasing and Squashing Commits
-
-Under no circumstances should you ever merge the master branch into
-your feature branch.  This makes it nearly impossible to review your
-changes and we *will not accept your PR* if you do this.
-
-Instead of merging you should rebase your changes on top of the master
-branch.  If a core team member asks you to "rebase your changes" this
-is what they are talking about.
-
-It's also helpful to squash all of your commits so that your pull
-request only contains a single commit.  Again, this makes it easier to
-review your changes and identify the changes later on in the Git
-history.
-
-### How to Rebase Your Changes
-
-The goal of rebasing is to bring recent changes from the master branch
-into your feature branch.  This often helps resolve conflicts where
-you have changed a file that also changed in a recently merged pull
-request (i.e. the `CHANGES.md` file).  Here is how you do that.
-
-  1. Make sure that you have a `git remote` configured for the main
-     repository.  I like to call this remote `upstream`:
-
-        $ git remote add upstream https://github.com/xmonad/xmonad-contrib.git
-
-  2. Pull from upstream and rewrite your changes on top of master.  For
-     this to work you should not have any modified files in your
-     working directory.  Run these commands from within your feature
-     branch (the branch you are asking to be merged):
-
-        $ git fetch --all
-        $ git pull --rebase upstream master
-
-  3. If the rebase was successful you can now push your feature branch
-     back to GitHub.  You need to force the push since your commits
-     have been rewritten and have new IDs:
-
-        $ git push --force-with-lease
-
-  4. Your pull request should now be conflict-free and only contain the
-     changes that you actually made.
-
-### How to Squash Commits
-
-The goal of squashing commits is to produce a clean Git history where
-each pull request contains just one commit.
-
-  1. Use `git log` to see how many commits you are including in your
-     pull request.  (If you've already submitted your pull request you
-     can see this in the GitHub interface.)
-
-  2. Rebase all of those commits into a single commit.  Assuming you
-     want to squash the last four (4) commits into a single commit:
-
-        $ git rebase -i HEAD~4
-
-  3. Git will open your editor and display the commits you are
-     rebasing with the word "pick" in front of them.
-
-  4. Leave the first listed commit as "pick" and change the remaining
-     commits from "pick" to "squash".
-
-  5. Save the file and exit your editor.  Git will create a new commit
-     and open your editor so you can modify the commit message.
-
-  6. If everything was successful you can push your changed history
-     back up to GitHub:
-
-        $ git push --force-with-lease
-
-[xmonad]: https://github.com/xmonad/xmonad
-[xmonad-contrib]: https://github.com/xmonad/xmonad-contrib
-[xmonad-testing]: https://github.com/xmonad/xmonad-testing
-[x11]: https://github.com/xmonad/X11
-[ml]: https://mail.haskell.org/cgi-bin/mailman/listinfo/xmonad
diff --git a/source/MAINTAINERS.md b/source/MAINTAINERS.md
deleted file mode 100644
index 28a6a6b..0000000
--- a/source/MAINTAINERS.md
+++ /dev/null
@@ -1,83 +0,0 @@
-# XMonad Maintainers
-
-## The XMonad Core Team
-
-  * Adam Vogt [GitHub][aavogt]
-
-  * Brandon S Allbery [GitHub][geekosaur], IRC: `geekosaur`
-
-  * Brent Yorgey [GitHub][byorgey], IRC: `byorgey`
-
-  * Daniel Wagner [GitHub][dmwit], IRC: `dmwit`
-
-  * David Lazar [GitHub][davidlazar]
-
-  * Devin Mullins [GitHub][twifkak]
-
-  * Peter J. Jones [GitHub][pjones], [Twitter][twitter:pjones], [OpenPGP Key][pgp:pjones], IRC: `pmade`
-
-## Release Procedures
-
-When the time comes to release another version of XMonad and Contrib...
-
-  1. Create a release branch (e.g., `release-0.XX`).
-
-     This will allow you to separate the release process from main
-     development.  Changes you make on this branch will be merged back
-     into `master` as one of the last steps.
-
-  2. Update the version number in the `*.cabal` files and verify
-     dependencies and documentation.  This includes the `tested-with:`
-     field.
-
-  3. Use the [packdeps][] tool to ensure you have the dependency
-     versions correct.  If you need to update the version of a
-     dependency then you should rebuild and retest.
-
-  4. Review documentation files and make sure they are accurate:
-
-     - `README.md`
-     - `CHANGES.md`
-     - and the `example-config.hs` in the `xmonad-testing` repo
-
-  5. Generate the manpage:
-
-     * `cabal configure` with the `-fgeneratemanpage` flag
-     * Build the project
-     * Run the `generatemanpage` tool from the top level of this repo
-     * Review the man page: `man -l man/xmonad.1`
-
-  6. Tag the repository with the release version (e.g., `v0.13`)
-
-  7. Build the project tarballs (`cabal sdist`)
-
-  8. Upload the packages to Hackage (`cabal upload`)
-
-  9. Merge the release branches into `master`
-
-  10. Update the website:
-
-      * Generate and push haddocks with `xmonad-web/gen-docs.sh`
-
-      * Check that `tour.html` and `intro.html` are up to date, and
-        mention all core bindings
-
-  11. Update the topic for the IRC channel (`#xmonad`)
-
-  12. Send the `announce-0.XX.txt` file to:
-
-      - XMonad mailing list
-      - Haskell Cafe
-
-[packdeps]: http://hackage.haskell.org/package/packdeps
-
-[aavogt]: https://github.com/orgs/xmonad/people/aavogt
-[geekosaur]: https://github.com/orgs/xmonad/people/geekosaur
-[byorgey]: https://github.com/orgs/xmonad/people/byorgey
-[dmwit]: https://github.com/orgs/xmonad/people/dmwit
-[davidlazar]: https://github.com/orgs/xmonad/people/davidlazar
-[twifkak]: https://github.com/orgs/xmonad/people/twifkak
-
-[pjones]: https://github.com/orgs/xmonad/people/pjones
-[twitter:pjones]: https://twitter.com/contextualdev
-[pgp:pjones]: http://pgp.mit.edu/pks/lookup?op=get&search=0x526722D1204284CB
diff --git a/source/Main.hs b/source/Main.hs
deleted file mode 100644
index 28351d0..0000000
--- a/source/Main.hs
+++ /dev/null
@@ -1,20 +0,0 @@
-----------------------------------------------------------------------------
--- |
--- Module      :  Main
--- Copyright   :  (c) Spencer Janssen 2007
--- License     :  BSD3-style (see LICENSE)
---
--- Maintainer  :  sjanssen@cse.unl.edu
--- Stability   :  unstable
--- Portability :  not portable, uses mtl, X11, posix
---
--- xmonad, a minimalist, tiling window manager for X11
---
------------------------------------------------------------------------------
-
-module Main (main) where
-
-import XMonad
-
-main :: IO ()
-main = xmonad def
diff --git a/source/README.md b/source/README.md
deleted file mode 100644
index eaccf7b..0000000
--- a/source/README.md
+++ /dev/null
@@ -1,129 +0,0 @@
-# xmonad: A Tiling Window Manager
-
-![Stack Tests](https://github.com/xmonad/xmonad/workflows/Stack%20Tests/badge.svg)
-
-[xmonad][] is a tiling window manager for X. Windows are arranged
-automatically to tile the screen without gaps or overlap, maximising
-screen use. Window manager features are accessible from the keyboard:
-a mouse is optional. xmonad is written, configured and extensible in
-Haskell. Custom layout algorithms, key bindings and other extensions
-may be written by the user in config files. Layouts are applied
-dynamically, and different layouts may be used on each
-workspace. Xinerama is fully supported, allowing windows to be tiled
-on several physical screens.
-
-## Quick Start
-
-  * From hackage:
-
-        cabal update
-        cabal install xmonad xmonad-contrib
-
-  * Alternatively, build from source using the following repositories:
-
-    - <https://github.com/xmonad/xmonad>
-
-    - <https://github.com/xmonad/xmonad-contrib>
-
-For the full story, read on.
-
-## Building
-
-Building is quite straightforward, and requires a basic Haskell toolchain.
-On many systems xmonad is available as a binary package in your
-package system (e.g. on Debian or Gentoo). If at all possible, use this
-in preference to a source build, as the dependency resolution will be
-simpler.
-
-We'll now walk through the complete list of toolchain dependencies.
-
-  * GHC: the Glasgow Haskell Compiler
-
-    You first need a Haskell compiler. Your distribution's package
-    system will have binaries of GHC (the Glasgow Haskell Compiler),
-    the compiler we use, so install that first. If your operating
-    system's package system doesn't provide a binary version of GHC
-    and the `cabal-install` tool, you can install both using the
-    [Haskell Platform][platform].
-
-    It shouldn't be necessary to compile GHC from source -- every common
-    system has a pre-build binary version.  However, if you want to
-    build from source, the following links will be helpful:
-
-      - GHC: <http://haskell.org/ghc/>
-
-      - Cabal: <http://haskell.org/cabal/download.html>
-
-  * X11 libraries:
-
-    Since you're building an X application, you'll need the C X11
-    library headers. On many platforms, these come pre-installed. For
-    others, such as Debian, you can get them from your package manager:
-
-        # for xmonad
-        $ apt-get install libx11-dev libxinerama-dev libxext-dev libxrandr-dev libxss-dev
-
-        # for xmonad-contrib
-        $ apt-get install libxft-dev
-
-Then build and install with:
-
-    $ cabal install
-
-## Running xmonad
-
-If you built XMonad using `cabal` then add:
-
-    exec $HOME/.cabal/bin/xmonad
-
-to the last line of your `.xsession` or `.xinitrc` file.
-
-## Configuring
-
-See the [CONFIG][] document and the [example configuration file][example-config].
-
-## XMonadContrib
-
-There are many extensions to xmonad available in the XMonadContrib
-(xmc) library. Examples include an ion3-like tabbed layout, a
-prompt/program launcher, and various other useful modules.
-XMonadContrib is available at:
-
-  * Latest release: <http://hackage.haskell.org/package/xmonad-contrib>
-
-  * Git version: <https://github.com/xmonad/xmonad-contrib>
-
-## Other Useful Programs
-
-A nicer xterm replacement, that supports resizing better:
-
-  * urxvt: <http://software.schmorp.de/pkg/rxvt-unicode.html>
-
-For custom status bars:
-
-  * xmobar: <http://hackage.haskell.org/package/xmobar>
-
-  * taffybar: <https://github.com/travitch/taffybar>
-
-  * dzen: <https://github.com/robm/dzen>
-
-For a program dispatch menu:
-
-  * [XMonad.Prompt.Shell][xmc-prompt-shell]: (from [XMonadContrib][])
-
-  * dmenu: <https://tools.suckless.org/dmenu/>
-
-  * gmrun: (in your package system)
-
-## Authors
-
-  * Spencer Janssen
-  * Don Stewart
-  * Jason Creighton
-
-[xmonad]: http://xmonad.org
-[xmonadcontrib]: https://hackage.haskell.org/package/xmonad-contrib
-[xmc-prompt-shell]: https://hackage.haskell.org/package/xmonad-contrib/docs/XMonad-Prompt-Shell.html
-[platform]: http://haskell.org/platform/
-[example-config]: https://github.com/xmonad/xmonad-contrib/blob/master/XMonad/Config/Example.hs
-[config]: https://github.com/xmonad/xmonad/blob/master/CONFIG
diff --git a/source/STYLE b/source/STYLE
deleted file mode 100644
index e55d75d..0000000
--- a/source/STYLE
+++ /dev/null
@@ -1,22 +0,0 @@
-
-== Coding guidelines for contributing to
-== xmonad and the xmonad contributed extensions
-
-* Comment every top level function (particularly exported functions), and
-  provide a type signature; use Haddock syntax in the comments.
-
-* Follow the coding style of the other modules.
-
-* Code should be compilable with -Wall -Werror -fno-warn-unused-do-bind -fwarn-tabs.
-  There should be no warnings.
-
-* Partial functions should be avoided: the window manager should not
-  crash, so do not call `error` or `undefined`
-
-* Use 4 spaces for indenting.
-
-* Any pure function added to the core should have QuickCheck properties
-  precisely defining its behavior.
-
-* New modules should identify the author, and be submitted under
-  the same license as xmonad (BSD3 license or freer).
diff --git a/source/cabal.project b/source/cabal.project
deleted file mode 100644
index 746035b..0000000
--- a/source/cabal.project
+++ /dev/null
@@ -1,7 +0,0 @@
--- cabal.project
-
-packages:
-  xmonad.cabal
-
-package xmonad
-  flags: +generatemanpage
diff --git a/source/xmonad.cabal b/simplified/lowarn-version-xmonad-v1289.cabal
similarity index 66%
rename from source/xmonad.cabal
rename to simplified/lowarn-version-xmonad-v1289.cabal
index f795fe9..2731768 100644
--- a/source/xmonad.cabal
+++ b/simplified/lowarn-version-xmonad-v1289.cabal
@@ -1,4 +1,4 @@
-name:               xmonad
+name:               lowarn-version-xmonad-v1289
 version:            0.15
 synopsis:           A tiling window manager
 description:        xmonad is a tiling window manager for X. Windows are arranged
@@ -33,20 +33,7 @@ category:           System
 homepage:           http://xmonad.org
 bug-reports:        https://github.com/xmonad/xmonad/issues
 build-type:         Simple
-extra-source-files: README.md
-                    CHANGES.md
-                    CONFIG
-                    STYLE
-                    tests/*.hs
-                    tests/Properties/*.hs
-                    tests/Properties/Layout/*.hs
-                    man/xmonad.1.markdown
-                    man/xmonad.1
-                    man/xmonad.1.html
-                    man/xmonad.hs
-                    util/GenerateManpage.hs
-                    util/hpcReport.sh
-cabal-version:      >= 1.8
+cabal-version:      >= 1.10
 
 source-repository head
   type:     git
@@ -71,10 +58,10 @@ library
                    XMonad.ManageHook
                    XMonad.Operations
                    XMonad.StackSet
-  other-modules:   Paths_xmonad
+  other-modules:   Paths_lowarn_version_xmonad_v1289
   hs-source-dirs:  src
   build-depends:   base                  >= 4.9 && < 5
-                 , X11                   >= 1.8 && < 1.10
+                 , X11                   >= 1.8 && < 1.11
                  , containers
                  , data-default
                  , directory
@@ -86,43 +73,7 @@ library
                  , unix
                  , utf8-string           >= 0.3 && < 1.1
   ghc-options:     -funbox-strict-fields -Wall -fno-warn-unused-do-bind
+  default-language: Haskell2010
 
   if flag(testing)
     buildable: False
-
-executable xmonad
-  main-is:       Main.hs
-  build-depends: base, X11, mtl, unix, xmonad
-  ghc-options:   -Wall -fno-warn-unused-do-bind
-
-executable generatemanpage
-  main-is:        GenerateManpage.hs
-  hs-source-dirs: util
-
-  if flag(generatemanpage)
-    build-depends: base, pandoc > 2.10, regex-posix, text
-  else
-    buildable: False
-
-test-suite properties
-  type:           exitcode-stdio-1.0
-  main-is:        Properties.hs
-  other-modules:  Instances
-                  Properties.Delete
-                  Properties.Failure
-                  Properties.Floating
-                  Properties.Focus
-                  Properties.GreedyView
-                  Properties.Insert
-                  Properties.Layout.Full
-                  Properties.Layout.Tall
-                  Properties.Screen
-                  Properties.Shift
-                  Properties.Stack
-                  Properties.StackSet
-                  Properties.Swap
-                  Properties.View
-                  Properties.Workspace
-                  Utils
-  hs-source-dirs: tests
-  build-depends:  base, QuickCheck >= 2, X11, containers, extensible-exceptions, xmonad
diff --git a/source/man/HCAR.tex b/source/man/HCAR.tex
deleted file mode 100644
index 68d6e6a..0000000
--- a/source/man/HCAR.tex
+++ /dev/null
@@ -1,71 +0,0 @@
-% xmonad-Gx.tex
-\begin{hcarentry}{xmonad}
-\label{xmonad}
-\report{Gwern Branwen}%11/11
-\status{active development}
-\makeheader
-
-XMonad is a tiling window manager for X. Windows are arranged
-automatically to tile the screen without gaps or overlap, maximizing
-screen use. Window manager features are accessible from the keyboard; a
-mouse is optional. XMonad is written, configured, and extensible in
-Haskell. Custom layout algorithms, key bindings, and other extensions may
-be written by the user in config files. Layouts are applied
-dynamically, and different layouts may be used on each workspace.
-Xinerama is fully supported, allowing windows to be tiled on several
-physical screens.
-
-Development since the last report has continued; XMonad founder Don Stewart
-has stepped down and Adam Vogt is the new maintainer.
-After gestating for 2 years, version 0.10 has been released, with simultaneous
-releases of the XMonadContrib library of customizations (which has now grown to
-no less than 216 modules encompassing a dizzying array of features) and the
-xmonad-extras package of extensions,
-
-Details of changes between releases can be found in the release notes:
-\begin{compactitem}
-\item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.8}
-\item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.9}
-% \item \url{http://haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.10}
-\item the Darcs repositories have been upgraded to the hashed format
-\item XMonad.Config.PlainConfig allows writing configs in a more 'normal' style, and not raw Haskell
-\item Supports using local modules in xmonad.hs; for example: to use definitions from \~/.xmonad/lib/XMonad/Stack/MyAdditions.hs
-\item xmonad --restart CLI option
-\item xmonad --replace CLI option
-\item XMonad.Prompt now has customizable keymaps
-\item Actions.GridSelect - a GUI menu for selecting windows or workspaces \& substring search on window names
-\item Actions.OnScreen
-\item Extensions now can have state
-\item Actions.SpawnOn - uses state to spawn applications on the workspace the user was originally on,
-  and not where the user happens to be
-\item Markdown manpages and not man/troff
-\item  XMonad.Layout.ImageButtonDecoration \&\\ XMonad.Util.Image
-\item XMonad.Layout.Groups
-\item XMonad.Layout.ZoomRow
-\item XMonad.Layout.Renamed
-\item XMonad.Layout.Drawer
-\item XMonad.Layout.FullScreen
-\item XMonad.Hooks.ScreenCorners
-\item XMonad.Actions.DynamicWorkspaceOrder
-\item XMonad.Actions.WorkspaceNames
-\item XMonad.Actions.DynamicWorkspaceGroups
-\end{compactitem}
-
-Binary packages of XMonad and XMonadContrib are available for all major Linux distributions.
-
-\FurtherReading
-\begin{compactitem}
-\item Homepage:
- \url{http://xmonad.org/}
-
-\item Git source:
-
- \texttt{git clone} \url{https://github.com/xmonad/xmonad.git}
-
-\item IRC channel:
- \verb+#xmonad @@ irc.freenode.org+
-
-\item Mailing list:
- \email{xmonad@@haskell.org}
-\end{compactitem}
-\end{hcarentry}
diff --git a/source/man/xmonad.1 b/source/man/xmonad.1
deleted file mode 100644
index 3ec791f..0000000
--- a/source/man/xmonad.1
+++ /dev/null
@@ -1,289 +0,0 @@
-.\" Automatically generated by Pandoc 2.2.1
-.\"
-.TH "XMONAD" "1" "30 September 2018" "Tiling Window Manager" ""
-.hy
-.SH Name
-.PP
-xmonad \- Tiling Window Manager
-.SH Description
-.PP
-\f[I]xmonad\f[] is a minimalist tiling window manager for X, written in
-Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured.
-At any time windows are arranged so as to maximize the use of screen
-real estate.
-All features of the window manager are accessible purely from the
-keyboard: a mouse is entirely optional.
-\f[I]xmonad\f[] is configured in Haskell, and custom layout algorithms
-may be implemented by the user in config files.
-A principle of \f[I]xmonad\f[] is predictability: the user should know
-in advance precisely the window arrangement that will result from any
-action.
-.PP
-By default, \f[I]xmonad\f[] provides three layout algorithms: tall, wide
-and fullscreen.
-In tall or wide mode, windows are tiled and arranged to prevent overlap
-and maximize screen use.
-Sets of windows are grouped together on virtual screens, and each screen
-retains its own layout, which may be reconfigured dynamically.
-Multiple physical monitors are supported via Xinerama, allowing
-simultaneous display of a number of screens.
-.PP
-By utilizing the expressivity of a modern functional language with a
-rich static type system, \f[I]xmonad\f[] provides a complete, featureful
-window manager in less than 1200 lines of code, with an emphasis on
-correctness and robustness.
-Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type\-based automated testing.
-A benefit of this is that the code is simple to understand, and easy to
-modify.
-.SH Usage
-.PP
-\f[I]xmonad\f[] places each window into a \[lq]workspace\[rq].
-Each workspace can have any number of windows, which you can cycle
-though with mod\-j and mod\-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically.
-You can toggle the layout mode with mod\-space, which will cycle through
-the available modes.
-.PP
-You can switch to workspace N with mod\-N.
-For example, to switch to workspace 5, you would press mod\-5.
-Similarly, you can move the current window to another workspace with
-mod\-shift\-N.
-.PP
-When running with multiple monitors (Xinerama), each screen has exactly
-1 workspace visible.
-mod\-{w,e,r} switch the focus between screens, while shift\-mod\-{w,e,r}
-move the current window to that screen.
-When \f[I]xmonad\f[] starts, workspace 1 is on screen 1, workspace 2 is
-on screen 2, etc.
-When switching workspaces to one that is already visible, the current
-and visible workspaces are swapped.
-.SS Flags
-.PP
-xmonad has several flags which you may pass to the executable.
-These flags are:
-.TP
-.B \[en]recompile
-Recompiles your configuration in \f[I]~/.xmonad/xmonad.hs\f[]
-.RS
-.RE
-.TP
-.B \[en]restart
-Causes the currently running \f[I]xmonad\f[] process to restart
-.RS
-.RE
-.TP
-.B \[en]replace
-Replace the current window manager with xmonad
-.RS
-.RE
-.TP
-.B \[en]version
-Display version of \f[I]xmonad\f[]
-.RS
-.RE
-.TP
-.B \[en]verbose\-version
-Display detailed version of \f[I]xmonad\f[]
-.RS
-.RE
-.PP
-##Default keyboard bindings
-.TP
-.B mod\-shift\-return
-Launch terminal
-.RS
-.RE
-.TP
-.B mod\-p
-Launch dmenu
-.RS
-.RE
-.TP
-.B mod\-shift\-p
-Launch gmrun
-.RS
-.RE
-.TP
-.B mod\-shift\-c
-Close the focused window
-.RS
-.RE
-.TP
-.B mod\-space
-Rotate through the available layout algorithms
-.RS
-.RE
-.TP
-.B mod\-shift\-space
-Reset the layouts on the current workspace to default
-.RS
-.RE
-.TP
-.B mod\-n
-Resize viewed windows to the correct size
-.RS
-.RE
-.TP
-.B mod\-tab
-Move focus to the next window
-.RS
-.RE
-.TP
-.B mod\-shift\-tab
-Move focus to the previous window
-.RS
-.RE
-.TP
-.B mod\-j
-Move focus to the next window
-.RS
-.RE
-.TP
-.B mod\-k
-Move focus to the previous window
-.RS
-.RE
-.TP
-.B mod\-m
-Move focus to the master window
-.RS
-.RE
-.TP
-.B mod\-return
-Swap the focused window and the master window
-.RS
-.RE
-.TP
-.B mod\-shift\-j
-Swap the focused window with the next window
-.RS
-.RE
-.TP
-.B mod\-shift\-k
-Swap the focused window with the previous window
-.RS
-.RE
-.TP
-.B mod\-h
-Shrink the master area
-.RS
-.RE
-.TP
-.B mod\-l
-Expand the master area
-.RS
-.RE
-.TP
-.B mod\-t
-Push window back into tiling
-.RS
-.RE
-.TP
-.B mod\-comma
-Increment the number of windows in the master area
-.RS
-.RE
-.TP
-.B mod\-period
-Deincrement the number of windows in the master area
-.RS
-.RE
-.TP
-.B mod\-shift\-q
-Quit xmonad
-.RS
-.RE
-.TP
-.B mod\-q
-Restart xmonad
-.RS
-.RE
-.TP
-.B mod\-shift\-slash
-Run xmessage with a summary of the default keybindings (useful for
-beginners)
-.RS
-.RE
-.TP
-.B mod\-question
-Run xmessage with a summary of the default keybindings (useful for
-beginners)
-.RS
-.RE
-.TP
-.B mod\-[1..9]
-Switch to workspace N
-.RS
-.RE
-.TP
-.B mod\-shift\-[1..9]
-Move client to workspace N
-.RS
-.RE
-.TP
-.B mod\-{w,e,r}
-Switch to physical/Xinerama screens 1, 2, or 3
-.RS
-.RE
-.TP
-.B mod\-shift\-{w,e,r}
-Move client to screen 1, 2, or 3
-.RS
-.RE
-.TP
-.B mod\-button1
-Set the window to floating mode and move by dragging
-.RS
-.RE
-.TP
-.B mod\-button2
-Raise the window to the top of the stack
-.RS
-.RE
-.TP
-.B mod\-button3
-Set the window to floating mode and resize by dragging
-.RS
-.RE
-.SH Examples
-.PP
-To use xmonad as your window manager add to your \f[I]~/.xinitrc\f[]
-file:
-.RS
-.PP
-exec xmonad
-.RE
-.SH Customization
-.PP
-xmonad is customized in ~/.xmonad/xmonad.hs, and then restarted with
-mod\-q.
-.PP
-You can find many extensions to the core feature set in the xmonad\-
-contrib package, available through your package manager or from
-xmonad.org (http://xmonad.org).
-.SS Modular Configuration
-.PP
-As of \f[I]xmonad\-0.9\f[], any additional Haskell modules may be placed
-in \f[I]~/.xmonad/lib/\f[] are available in GHC's searchpath.
-Hierarchical modules are supported: for example, the file
-\f[I]~/.xmonad/lib/XMonad/Stack/MyAdditions.hs\f[] could contain:
-.IP
-.nf
-\f[C]
-module\ XMonad.Stack.MyAdditions\ (function1)\ where
-\ \ function1\ =\ error\ "function1:\ Not\ implemented\ yet!"
-\f[]
-.fi
-.PP
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad\-contrib.
-.SH Bugs
-.PP
-Probably.
-If you find any, please report them to the
-bugtracker (https://github.com/xmonad/xmonad/issues)
diff --git a/source/man/xmonad.1.html b/source/man/xmonad.1.html
deleted file mode 100644
index 1d2f071..0000000
--- a/source/man/xmonad.1.html
+++ /dev/null
@@ -1,244 +0,0 @@
-<!DOCTYPE html>
-<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
-<head>
-  <meta charset="utf-8" />
-  <meta name="generator" content="pandoc" />
-  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
-  <meta name="author" content="" />
-  <meta name="dcterms.date" content="2018-09-30" />
-  <title>XMONAD(1) Tiling Window Manager</title>
-  <style type="text/css">
-      code{white-space: pre-wrap;}
-      span.smallcaps{font-variant: small-caps;}
-      span.underline{text-decoration: underline;}
-      div.column{display: inline-block; vertical-align: top; width: 50%;}
-  </style>
-  <style type="text/css">
-a.sourceLine { display: inline-block; line-height: 1.25; }
-a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
-a.sourceLine:empty { height: 1.2em; }
-.sourceCode { overflow: visible; }
-code.sourceCode { white-space: pre; position: relative; }
-div.sourceCode { margin: 1em 0; }
-pre.sourceCode { margin: 0; }
-@media screen {
-div.sourceCode { overflow: auto; }
-}
-@media print {
-code.sourceCode { white-space: pre-wrap; }
-a.sourceLine { text-indent: -1em; padding-left: 1em; }
-}
-pre.numberSource a.sourceLine
-  { position: relative; left: -4em; }
-pre.numberSource a.sourceLine::before
-  { content: attr(data-line-number);
-    position: relative; left: -1em; text-align: right; vertical-align: baseline;
-    border: none; pointer-events: all; display: inline-block;
-    -webkit-touch-callout: none; -webkit-user-select: none;
-    -khtml-user-select: none; -moz-user-select: none;
-    -ms-user-select: none; user-select: none;
-    padding: 0 4px; width: 4em;
-    color: #aaaaaa;
-  }
-pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
-div.sourceCode
-  {  }
-@media screen {
-a.sourceLine::before { text-decoration: underline; }
-}
-code span.al { color: #ff0000; font-weight: bold; } /* Alert */
-code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
-code span.at { color: #7d9029; } /* Attribute */
-code span.bn { color: #40a070; } /* BaseN */
-code span.bu { } /* BuiltIn */
-code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
-code span.ch { color: #4070a0; } /* Char */
-code span.cn { color: #880000; } /* Constant */
-code span.co { color: #60a0b0; font-style: italic; } /* Comment */
-code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
-code span.do { color: #ba2121; font-style: italic; } /* Documentation */
-code span.dt { color: #902000; } /* DataType */
-code span.dv { color: #40a070; } /* DecVal */
-code span.er { color: #ff0000; font-weight: bold; } /* Error */
-code span.ex { } /* Extension */
-code span.fl { color: #40a070; } /* Float */
-code span.fu { color: #06287e; } /* Function */
-code span.im { } /* Import */
-code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
-code span.kw { color: #007020; font-weight: bold; } /* Keyword */
-code span.op { color: #666666; } /* Operator */
-code span.ot { color: #007020; } /* Other */
-code span.pp { color: #bc7a00; } /* Preprocessor */
-code span.sc { color: #4070a0; } /* SpecialChar */
-code span.ss { color: #bb6688; } /* SpecialString */
-code span.st { color: #4070a0; } /* String */
-code span.va { color: #19177c; } /* Variable */
-code span.vs { color: #4070a0; } /* VerbatimString */
-code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
-  </style>
-  <!--[if lt IE 9]>
-    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
-  <![endif]-->
-</head>
-<body>
-<header>
-<h1 class="title">XMONAD(1) Tiling Window Manager</h1>
-<p class="author"></p>
-<p class="date">30 September 2018</p>
-</header>
-<nav id="TOC">
-<ul>
-<li><a href="#name">Name</a></li>
-<li><a href="#description">Description</a></li>
-<li><a href="#usage">Usage</a><ul>
-<li><a href="#flags">Flags</a></li>
-</ul></li>
-<li><a href="#examples">Examples</a></li>
-<li><a href="#customization">Customization</a><ul>
-<li><a href="#modular-configuration">Modular Configuration</a></li>
-</ul></li>
-<li><a href="#bugs">Bugs</a></li>
-</ul>
-</nav>
-<h1 id="name">Name</h1>
-<p>xmonad - Tiling Window Manager</p>
-<h1 id="description">Description</h1>
-<p><em>xmonad</em> is a minimalist tiling window manager for X, written in Haskell. Windows are managed using automatic layout algorithms, which can be dynamically reconfigured. At any time windows are arranged so as to maximize the use of screen real estate. All features of the window manager are accessible purely from the keyboard: a mouse is entirely optional. <em>xmonad</em> is configured in Haskell, and custom layout algorithms may be implemented by the user in config files. A principle of <em>xmonad</em> is predictability: the user should know in advance precisely the window arrangement that will result from any action.</p>
-<p>By default, <em>xmonad</em> provides three layout algorithms: tall, wide and fullscreen. In tall or wide mode, windows are tiled and arranged to prevent overlap and maximize screen use. Sets of windows are grouped together on virtual screens, and each screen retains its own layout, which may be reconfigured dynamically. Multiple physical monitors are supported via Xinerama, allowing simultaneous display of a number of screens.</p>
-<p>By utilizing the expressivity of a modern functional language with a rich static type system, <em>xmonad</em> provides a complete, featureful window manager in less than 1200 lines of code, with an emphasis on correctness and robustness. Internal properties of the window manager are checked using a combination of static guarantees provided by the type system, and type-based automated testing. A benefit of this is that the code is simple to understand, and easy to modify.</p>
-<h1 id="usage">Usage</h1>
-<p><em>xmonad</em> places each window into a “workspace”. Each workspace can have any number of windows, which you can cycle though with mod-j and mod-k. Windows are either displayed full screen, tiled horizontally, or tiled vertically. You can toggle the layout mode with mod-space, which will cycle through the available modes.</p>
-<p>You can switch to workspace N with mod-N. For example, to switch to workspace 5, you would press mod-5. Similarly, you can move the current window to another workspace with mod-shift-N.</p>
-<p>When running with multiple monitors (Xinerama), each screen has exactly 1 workspace visible. mod-{w,e,r} switch the focus between screens, while shift-mod-{w,e,r} move the current window to that screen. When <em>xmonad</em> starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When switching workspaces to one that is already visible, the current and visible workspaces are swapped.</p>
-<h2 id="flags">Flags</h2>
-<p>xmonad has several flags which you may pass to the executable. These flags are:</p>
-<dl>
-<dt>–recompile</dt>
-<dd>Recompiles your configuration in <em>~/.xmonad/xmonad.hs</em>
-</dd>
-<dt>–restart</dt>
-<dd>Causes the currently running <em>xmonad</em> process to restart
-</dd>
-<dt>–replace</dt>
-<dd>Replace the current window manager with xmonad
-</dd>
-<dt>–version</dt>
-<dd>Display version of <em>xmonad</em>
-</dd>
-<dt>–verbose-version</dt>
-<dd>Display detailed version of <em>xmonad</em>
-</dd>
-</dl>
-<p>##Default keyboard bindings</p>
-<dl>
-<dt>mod-shift-return</dt>
-<dd>Launch terminal
-</dd>
-<dt>mod-p</dt>
-<dd>Launch dmenu
-</dd>
-<dt>mod-shift-p</dt>
-<dd>Launch gmrun
-</dd>
-<dt>mod-shift-c</dt>
-<dd>Close the focused window
-</dd>
-<dt>mod-space</dt>
-<dd>Rotate through the available layout algorithms
-</dd>
-<dt>mod-shift-space</dt>
-<dd>Reset the layouts on the current workspace to default
-</dd>
-<dt>mod-n</dt>
-<dd>Resize viewed windows to the correct size
-</dd>
-<dt>mod-tab</dt>
-<dd>Move focus to the next window
-</dd>
-<dt>mod-shift-tab</dt>
-<dd>Move focus to the previous window
-</dd>
-<dt>mod-j</dt>
-<dd>Move focus to the next window
-</dd>
-<dt>mod-k</dt>
-<dd>Move focus to the previous window
-</dd>
-<dt>mod-m</dt>
-<dd>Move focus to the master window
-</dd>
-<dt>mod-return</dt>
-<dd>Swap the focused window and the master window
-</dd>
-<dt>mod-shift-j</dt>
-<dd>Swap the focused window with the next window
-</dd>
-<dt>mod-shift-k</dt>
-<dd>Swap the focused window with the previous window
-</dd>
-<dt>mod-h</dt>
-<dd>Shrink the master area
-</dd>
-<dt>mod-l</dt>
-<dd>Expand the master area
-</dd>
-<dt>mod-t</dt>
-<dd>Push window back into tiling
-</dd>
-<dt>mod-comma</dt>
-<dd>Increment the number of windows in the master area
-</dd>
-<dt>mod-period</dt>
-<dd>Deincrement the number of windows in the master area
-</dd>
-<dt>mod-shift-q</dt>
-<dd>Quit xmonad
-</dd>
-<dt>mod-q</dt>
-<dd>Restart xmonad
-</dd>
-<dt>mod-shift-slash</dt>
-<dd>Run xmessage with a summary of the default keybindings (useful for beginners)
-</dd>
-<dt>mod-question</dt>
-<dd>Run xmessage with a summary of the default keybindings (useful for beginners)
-</dd>
-<dt>mod-[1..9]</dt>
-<dd>Switch to workspace N
-</dd>
-<dt>mod-shift-[1..9]</dt>
-<dd>Move client to workspace N
-</dd>
-<dt>mod-{w,e,r}</dt>
-<dd>Switch to physical/Xinerama screens 1, 2, or 3
-</dd>
-<dt>mod-shift-{w,e,r}</dt>
-<dd>Move client to screen 1, 2, or 3
-</dd>
-<dt>mod-button1</dt>
-<dd>Set the window to floating mode and move by dragging
-</dd>
-<dt>mod-button2</dt>
-<dd>Raise the window to the top of the stack
-</dd>
-<dt>mod-button3</dt>
-<dd>Set the window to floating mode and resize by dragging
-</dd>
-</dl>
-<h1 id="examples">Examples</h1>
-<p>To use xmonad as your window manager add to your <em>~/.xinitrc</em> file:</p>
-<blockquote>
-<p>exec xmonad</p>
-</blockquote>
-<h1 id="customization">Customization</h1>
-<p>xmonad is customized in ~/.xmonad/xmonad.hs, and then restarted with mod-q.</p>
-<p>You can find many extensions to the core feature set in the xmonad- contrib package, available through your package manager or from <a href="http://xmonad.org">xmonad.org</a>.</p>
-<h2 id="modular-configuration">Modular Configuration</h2>
-<p>As of <em>xmonad-0.9</em>, any additional Haskell modules may be placed in <em>~/.xmonad/lib/</em> are available in GHC’s searchpath. Hierarchical modules are supported: for example, the file <em>~/.xmonad/lib/XMonad/Stack/MyAdditions.hs</em> could contain:</p>
-<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">XMonad.Stack.MyAdditions</span> (function1) <span class="kw">where</span></a>
-<a class="sourceLine" id="cb1-2" data-line-number="2">  function1 <span class="fu">=</span> error <span class="st">&quot;function1: Not implemented yet!&quot;</span></a></code></pre></div>
-<p>Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that module was contained within xmonad or xmonad-contrib.</p>
-<h1 id="bugs">Bugs</h1>
-<p>Probably. If you find any, please report them to the <a href="https://github.com/xmonad/xmonad/issues">bugtracker</a></p>
-</body>
-</html>
diff --git a/source/man/xmonad.1.markdown b/source/man/xmonad.1.markdown
deleted file mode 100644
index 258abf3..0000000
--- a/source/man/xmonad.1.markdown
+++ /dev/null
@@ -1,111 +0,0 @@
-% XMONAD(1) Tiling Window Manager
-%
-% 30 September 2018
-
-# Name
-
-xmonad - Tiling Window Manager
-
-# Description
-
-_xmonad_ is a minimalist tiling window manager for X, written in Haskell.
-Windows are managed using automatic layout algorithms, which can be
-dynamically reconfigured. At any time windows are arranged so as to
-maximize the use of screen real estate. All features of the window manager
-are accessible purely from the keyboard: a mouse is entirely optional.
-_xmonad_ is configured in Haskell, and custom layout algorithms may be
-implemented by the user in config files. A principle of _xmonad_ is
-predictability: the user should know in advance precisely the window
-arrangement that will result from any action.
-
-By default, _xmonad_ provides three layout algorithms: tall, wide and
-fullscreen. In tall or wide mode, windows are tiled and arranged to prevent
-overlap and maximize screen use. Sets of windows are grouped together on
-virtual screens, and each screen retains its own layout, which may be
-reconfigured dynamically. Multiple physical monitors are supported via
-Xinerama, allowing simultaneous display of a number of screens.
-
-By utilizing the expressivity of a modern functional language with a rich
-static type system, _xmonad_ provides a complete, featureful window manager
-in less than 1200 lines of code, with an emphasis on correctness and
-robustness. Internal properties of the window manager are checked using a
-combination of static guarantees provided by the type system, and
-type-based automated testing. A benefit of this is that the code is simple
-to understand, and easy to modify.
-
-# Usage
-
-_xmonad_ places each window into a "workspace". Each workspace can have
-any number of windows, which you can cycle though with mod-j and mod-k.
-Windows are either displayed full screen, tiled horizontally, or tiled
-vertically. You can toggle the layout mode with mod-space, which will cycle
-through the available modes.
-
-You can switch to workspace N with mod-N. For example, to switch to
-workspace 5, you would press mod-5. Similarly, you can move the current
-window to another workspace with mod-shift-N.
-
-When running with multiple monitors (Xinerama), each screen has exactly 1
-workspace visible. mod-{w,e,r} switch the focus between screens, while
-shift-mod-{w,e,r} move the current window to that screen. When _xmonad_
-starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc. When
-switching workspaces to one that is already visible, the current and
-visible workspaces are swapped.
-
-## Flags
-
-xmonad  has  several flags which  you may pass to the executable.
-These flags are:
-
---recompile
-:   Recompiles your configuration in _~/.xmonad/xmonad.hs_
-
---restart
-:   Causes the currently running _xmonad_ process to restart
-
---replace
-:   Replace the current window manager with xmonad
-
---version
-:   Display version of _xmonad_
-
---verbose-version
-:   Display detailed version of _xmonad_
-
-## Default keyboard bindings
-
-___KEYBINDINGS___
-
-# Examples
-
-To use xmonad as your window manager add to your _~/.xinitrc_ file:
-
-> exec xmonad
-
-# Customization
-xmonad is customized in ~/.xmonad/xmonad.hs, and then restarted
-with mod-q.
-
-You can find many extensions to the core feature set in the xmonad-
-contrib package, available through your  package  manager  or  from
-[xmonad.org].
-
-## Modular Configuration
-As of _xmonad-0.9_, any additional Haskell modules may be placed in
-_~/.xmonad/lib/_ are available in GHC's searchpath. Hierarchical modules
-are supported: for example, the file
-_~/.xmonad/lib/XMonad/Stack/MyAdditions.hs_ could contain:
-
-```haskell
-module XMonad.Stack.MyAdditions (function1) where
-  function1 = error "function1: Not implemented yet!"
-```
-
-Your xmonad.hs may then import XMonad.Stack.MyAdditions as if that
-module was contained within xmonad or xmonad-contrib.
-
-# Bugs
-Probably. If you find any, please report them to the [bugtracker]
-
-[xmonad.org]: http://xmonad.org
-[bugtracker]: https://github.com/xmonad/xmonad/issues
diff --git a/source/man/xmonad.hs b/source/man/xmonad.hs
deleted file mode 100644
index baf5189..0000000
--- a/source/man/xmonad.hs
+++ /dev/null
@@ -1,333 +0,0 @@
---
--- xmonad example config file.
---
--- A template showing all available configuration hooks,
--- and how to override the defaults in your own xmonad.hs conf file.
---
--- Normally, you'd only override those defaults you care about.
---
-
-import XMonad
-import Data.Monoid
-import System.Exit
-
-import qualified XMonad.StackSet as W
-import qualified Data.Map        as M
-
--- The preferred terminal program, which is used in a binding below and by
--- certain contrib modules.
---
-myTerminal      = "xterm"
-
--- Whether focus follows the mouse pointer.
-myFocusFollowsMouse :: Bool
-myFocusFollowsMouse = True
-
--- Whether clicking on a window to focus also passes the click to the window
-myClickJustFocuses :: Bool
-myClickJustFocuses = False
-
--- Width of the window border in pixels.
---
-myBorderWidth   = 1
-
--- modMask lets you specify which modkey you want to use. The default
--- is mod1Mask ("left alt").  You may also consider using mod3Mask
--- ("right alt"), which does not conflict with emacs keybindings. The
--- "windows key" is usually mod4Mask.
---
-myModMask       = mod1Mask
-
--- The default number of workspaces (virtual screens) and their names.
--- By default we use numeric strings, but any string may be used as a
--- workspace name. The number of workspaces is determined by the length
--- of this list.
---
--- A tagging example:
---
--- > workspaces = ["web", "irc", "code" ] ++ map show [4..9]
---
-myWorkspaces    = ["1","2","3","4","5","6","7","8","9"]
-
--- Border colors for unfocused and focused windows, respectively.
---
-myNormalBorderColor  = "#dddddd"
-myFocusedBorderColor = "#ff0000"
-
-------------------------------------------------------------------------
--- Key bindings. Add, modify or remove key bindings here.
---
-myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $
-
-    -- launch a terminal
-    [ ((modm .|. shiftMask, xK_Return), spawn $ XMonad.terminal conf)
-
-    -- launch dmenu
-    , ((modm,               xK_p     ), spawn "dmenu_run")
-
-    -- launch gmrun
-    , ((modm .|. shiftMask, xK_p     ), spawn "gmrun")
-
-    -- close focused window
-    , ((modm .|. shiftMask, xK_c     ), kill)
-
-     -- Rotate through the available layout algorithms
-    , ((modm,               xK_space ), sendMessage NextLayout)
-
-    --  Reset the layouts on the current workspace to default
-    , ((modm .|. shiftMask, xK_space ), setLayout $ XMonad.layoutHook conf)
-
-    -- Resize viewed windows to the correct size
-    , ((modm,               xK_n     ), refresh)
-
-    -- Move focus to the next window
-    , ((modm,               xK_Tab   ), windows W.focusDown)
-
-    -- Move focus to the next window
-    , ((modm,               xK_j     ), windows W.focusDown)
-
-    -- Move focus to the previous window
-    , ((modm,               xK_k     ), windows W.focusUp  )
-
-    -- Move focus to the master window
-    , ((modm,               xK_m     ), windows W.focusMaster  )
-
-    -- Swap the focused window and the master window
-    , ((modm,               xK_Return), windows W.swapMaster)
-
-    -- Swap the focused window with the next window
-    , ((modm .|. shiftMask, xK_j     ), windows W.swapDown  )
-
-    -- Swap the focused window with the previous window
-    , ((modm .|. shiftMask, xK_k     ), windows W.swapUp    )
-
-    -- Shrink the master area
-    , ((modm,               xK_h     ), sendMessage Shrink)
-
-    -- Expand the master area
-    , ((modm,               xK_l     ), sendMessage Expand)
-
-    -- Push window back into tiling
-    , ((modm,               xK_t     ), withFocused $ windows . W.sink)
-
-    -- Increment the number of windows in the master area
-    , ((modm              , xK_comma ), sendMessage (IncMasterN 1))
-
-    -- Deincrement the number of windows in the master area
-    , ((modm              , xK_period), sendMessage (IncMasterN (-1)))
-
-    -- Toggle the status bar gap
-    -- Use this binding with avoidStruts from Hooks.ManageDocks.
-    -- See also the statusBar function from Hooks.DynamicLog.
-    --
-    -- , ((modm              , xK_b     ), sendMessage ToggleStruts)
-
-    -- Quit xmonad
-    , ((modm .|. shiftMask, xK_q     ), io (exitWith ExitSuccess))
-
-    -- Restart xmonad
-    , ((modm              , xK_q     ), spawn "xmonad --recompile; xmonad --restart")
-
-    -- Run xmessage with a summary of the default keybindings (useful for beginners)
-    , ((modm .|. shiftMask, xK_slash ), spawn ("echo \"" ++ help ++ "\" | xmessage -file -"))
-    ]
-    ++
-
-    --
-    -- mod-[1..9], Switch to workspace N
-    -- mod-shift-[1..9], Move client to workspace N
-    --
-    [((m .|. modm, k), windows $ f i)
-        | (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9]
-        , (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]]
-    ++
-
-    --
-    -- mod-{w,e,r}, Switch to physical/Xinerama screens 1, 2, or 3
-    -- mod-shift-{w,e,r}, Move client to screen 1, 2, or 3
-    --
-    [((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
-        | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
-        , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
-
-
-------------------------------------------------------------------------
--- Mouse bindings: default actions bound to mouse events
---
-myMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $
-
-    -- mod-button1, Set the window to floating mode and move by dragging
-    [ ((modm, button1), (\w -> focus w >> mouseMoveWindow w
-                                       >> windows W.shiftMaster))
-
-    -- mod-button2, Raise the window to the top of the stack
-    , ((modm, button2), (\w -> focus w >> windows W.shiftMaster))
-
-    -- mod-button3, Set the window to floating mode and resize by dragging
-    , ((modm, button3), (\w -> focus w >> mouseResizeWindow w
-                                       >> windows W.shiftMaster))
-
-    -- you may also bind events to the mouse scroll wheel (button4 and button5)
-    ]
-
-------------------------------------------------------------------------
--- Layouts:
-
--- You can specify and transform your layouts by modifying these values.
--- If you change layout bindings be sure to use 'mod-shift-space' after
--- restarting (with 'mod-q') to reset your layout state to the new
--- defaults, as xmonad preserves your old layout settings by default.
---
--- The available layouts.  Note that each layout is separated by |||,
--- which denotes layout choice.
---
-myLayout = tiled ||| Mirror tiled ||| Full
-  where
-     -- default tiling algorithm partitions the screen into two panes
-     tiled   = Tall nmaster delta ratio
-
-     -- The default number of windows in the master pane
-     nmaster = 1
-
-     -- Default proportion of screen occupied by master pane
-     ratio   = 1/2
-
-     -- Percent of screen to increment by when resizing panes
-     delta   = 3/100
-
-------------------------------------------------------------------------
--- Window rules:
-
--- Execute arbitrary actions and WindowSet manipulations when managing
--- a new window. You can use this to, for example, always float a
--- particular program, or have a client always appear on a particular
--- workspace.
---
--- To find the property name associated with a program, use
--- > xprop | grep WM_CLASS
--- and click on the client you're interested in.
---
--- To match on the WM_NAME, you can use 'title' in the same way that
--- 'className' and 'resource' are used below.
---
-myManageHook = composeAll
-    [ className =? "MPlayer"        --> doFloat
-    , className =? "Gimp"           --> doFloat
-    , resource  =? "desktop_window" --> doIgnore
-    , resource  =? "kdesktop"       --> doIgnore ]
-
-------------------------------------------------------------------------
--- Event handling
-
--- * EwmhDesktops users should change this to ewmhDesktopsEventHook
---
--- Defines a custom handler function for X Events. The function should
--- return (All True) if the default handler is to be run afterwards. To
--- combine event hooks use mappend or mconcat from Data.Monoid.
---
-myEventHook = mempty
-
-------------------------------------------------------------------------
--- Status bars and logging
-
--- Perform an arbitrary action on each internal state change or X event.
--- See the 'XMonad.Hooks.DynamicLog' extension for examples.
---
-myLogHook = return ()
-
-------------------------------------------------------------------------
--- Startup hook
-
--- Perform an arbitrary action each time xmonad starts or is restarted
--- with mod-q.  Used by, e.g., XMonad.Layout.PerWorkspace to initialize
--- per-workspace layout choices.
---
--- By default, do nothing.
-myStartupHook = return ()
-
-------------------------------------------------------------------------
--- Now run xmonad with all the defaults we set up.
-
--- Run xmonad with the settings you specify. No need to modify this.
---
-main = xmonad defaults
-
--- A structure containing your configuration settings, overriding
--- fields in the default config. Any you don't override, will
--- use the defaults defined in xmonad/XMonad/Config.hs
---
--- No need to modify this.
---
-defaults = def {
-      -- simple stuff
-        terminal           = myTerminal,
-        focusFollowsMouse  = myFocusFollowsMouse,
-        clickJustFocuses   = myClickJustFocuses,
-        borderWidth        = myBorderWidth,
-        modMask            = myModMask,
-        workspaces         = myWorkspaces,
-        normalBorderColor  = myNormalBorderColor,
-        focusedBorderColor = myFocusedBorderColor,
-
-      -- key bindings
-        keys               = myKeys,
-        mouseBindings      = myMouseBindings,
-
-      -- hooks, layouts
-        layoutHook         = myLayout,
-        manageHook         = myManageHook,
-        handleEventHook    = myEventHook,
-        logHook            = myLogHook,
-        startupHook        = myStartupHook
-    }
-
--- | Finally, a copy of the default bindings in simple textual tabular format.
-help :: String
-help = unlines ["The default modifier key is 'alt'. Default keybindings:",
-    "",
-    "-- launching and killing programs",
-    "mod-Shift-Enter  Launch xterminal",
-    "mod-p            Launch dmenu",
-    "mod-Shift-p      Launch gmrun",
-    "mod-Shift-c      Close/kill the focused window",
-    "mod-Space        Rotate through the available layout algorithms",
-    "mod-Shift-Space  Reset the layouts on the current workSpace to default",
-    "mod-n            Resize/refresh viewed windows to the correct size",
-    "",
-    "-- move focus up or down the window stack",
-    "mod-Tab        Move focus to the next window",
-    "mod-Shift-Tab  Move focus to the previous window",
-    "mod-j          Move focus to the next window",
-    "mod-k          Move focus to the previous window",
-    "mod-m          Move focus to the master window",
-    "",
-    "-- modifying the window order",
-    "mod-Return   Swap the focused window and the master window",
-    "mod-Shift-j  Swap the focused window with the next window",
-    "mod-Shift-k  Swap the focused window with the previous window",
-    "",
-    "-- resizing the master/slave ratio",
-    "mod-h  Shrink the master area",
-    "mod-l  Expand the master area",
-    "",
-    "-- floating layer support",
-    "mod-t  Push window back into tiling; unfloat and re-tile it",
-    "",
-    "-- increase or decrease number of windows in the master area",
-    "mod-comma  (mod-,)   Increment the number of windows in the master area",
-    "mod-period (mod-.)   Deincrement the number of windows in the master area",
-    "",
-    "-- quit, or restart",
-    "mod-Shift-q  Quit xmonad",
-    "mod-q        Restart xmonad",
-    "mod-[1..9]   Switch to workSpace N",
-    "",
-    "-- Workspaces & screens",
-    "mod-Shift-[1..9]   Move client to workspace N",
-    "mod-{w,e,r}        Switch to physical/Xinerama screens 1, 2, or 3",
-    "mod-Shift-{w,e,r}  Move client to screen 1, 2, or 3",
-    "",
-    "-- Mouse bindings: default actions bound to mouse events",
-    "mod-button1  Set the window to floating mode and move by dragging",
-    "mod-button2  Raise the window to the top of the stack",
-    "mod-button3  Set the window to floating mode and resize by dragging"]
diff --git a/source/src/XMonad/Main.hs b/simplified/src/XMonad/Main.hs
index 1b0b16e..9673ea2 100644
--- a/source/src/XMonad/Main.hs
+++ b/simplified/src/XMonad/Main.hs
@@ -44,7 +44,7 @@ import System.Posix.Process (executeFile)
 import System.Exit (exitFailure)
 import System.FilePath
 
-import Paths_xmonad (version)
+import Paths_lowarn_version_xmonad_v1289 (version)
 import Data.Version (showVersion)
 
 import Graphics.X11.Xinerama (compiledWithXinerama)
@@ -61,7 +61,7 @@ xmonad conf = do
 
     let launch' args = do
               catchIO buildLaunch
-              conf' @ XConfig { layoutHook = Layout l }
+              conf'@XConfig { layoutHook = Layout l }
                   <- handleExtraArgs conf args conf{ layoutHook = Layout (layoutHook conf) }
               withArgs [] $ launch (conf' { layoutHook = l })
 
diff --git a/source/stack.yaml b/source/stack.yaml
deleted file mode 100644
index 641c6a2..0000000
--- a/source/stack.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
-resolver: lts-16.22
-
-packages:
-  - ./
-
-extra-deps:
-- X11-1.9.2
diff --git a/source/tests/Instances.hs b/source/tests/Instances.hs
deleted file mode 100644
index e52c5ec..0000000
--- a/source/tests/Instances.hs
+++ /dev/null
@@ -1,140 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Instances where
-
-import Test.QuickCheck
-
-import Utils
-
-import XMonad.StackSet
-import Control.Monad
-import Data.List (nub, genericLength)
-
-import Debug.Trace
-
-import Graphics.X11 (Rectangle(Rectangle))
-import Control.Applicative
-
---
--- The all important Arbitrary instance for StackSet.
---
-instance (Integral i, Integral s, Eq a, Arbitrary a, Arbitrary l, Arbitrary sd)
-         => Arbitrary (StackSet i l a s sd) where
-  arbitrary = do
-      -- TODO: Fix this to be a reasonable higher number, Possibly use PositiveSized
-      numWs        <- choose (1, 20)    -- number of workspaces, there must be at least 1.
-      numScreens   <- choose (1, numWs) -- number of physical screens, there must be at least 1
-      lay <- arbitrary                  -- pick any layout
-
-      wsIdxInFocus <- choose (1, numWs) -- pick index of WS to be in focus
-
-      -- The same screen id's will be present in the list, with high possibility.
-      screens  <- replicateM numScreens arbitrary
-
-      -- Generate a list of "windows" for each workspace.
-      wsWindows  <- vector numWs :: Gen [[a]]
-
-      -- Pick a random window "number" in each workspace, to give focus.
-      focus <- sequence [ if null windows
-                          then return Nothing
-                          else liftM Just $ choose (0, length windows - 1)
-                        | windows <- wsWindows ]
-
-      let tags = [1 .. fromIntegral numWs]
-          focusWsWindows = zip focus wsWindows
-          wss = zip tags focusWsWindows -- tmp representation of a workspace (tag, windows)
-          initSs = new lay tags screens
-      return $
-        view (fromIntegral wsIdxInFocus) $
-        foldr (\(tag, (focus, windows)) ss -> -- Fold through all generated (tags,windows).
-                -- set workspace active by tag and fold through all
-                -- windows while inserting them.  Apply the given number
-                -- of `focusUp` on the resulting StackSet.
-                applyN focus focusUp $ foldr insertUp (view tag ss) windows
-              ) initSs wss
-
-
---
--- Just generate StackSets with Char elements.
---
-type Tag = Int
-type Window = Char
-type T = StackSet Tag Int Window Int Int
-
-
-
-newtype EmptyStackSet = EmptyStackSet T
-    deriving Show
-
-instance Arbitrary EmptyStackSet where
-    arbitrary = do
-        (NonEmptyNubList ns)  <- arbitrary
-        (NonEmptyNubList sds) <- arbitrary
-        l <- arbitrary
-        -- there cannot be more screens than workspaces:
-        return . EmptyStackSet . new l ns $ take (min (length ns) (length sds)) sds
-
-
-
-newtype NonEmptyWindowsStackSet = NonEmptyWindowsStackSet T
-    deriving Show
-
-instance Arbitrary NonEmptyWindowsStackSet where
-  arbitrary =
-    NonEmptyWindowsStackSet `fmap` (arbitrary `suchThat` (not . null . allWindows))
-
-instance Arbitrary Rectangle where
-    arbitrary = Rectangle <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary
-
-
-newtype SizedPositive = SizedPositive Int
-    deriving (Eq, Ord, Show, Read)
-
-instance Arbitrary SizedPositive where
-  arbitrary = sized $ \s -> do x <- choose (1, max 1 s)
-                               return $ SizedPositive x
-
-
-
-newtype NonEmptyNubList a = NonEmptyNubList [a]
-    deriving ( Eq, Ord, Show, Read )
-
-instance (Eq a, Arbitrary a) => Arbitrary (NonEmptyNubList a) where
-  arbitrary   = NonEmptyNubList `fmap` ((liftM nub arbitrary) `suchThat` (not . null))
-
-
-
--- | Pull out an arbitrary tag from the StackSet. This removes the need for the
--- precondition "n `tagMember x` in many properties and thus reduces the number
--- of discarded tests.
---
---  n <- arbitraryTag x
---
--- We can do the reverse with a simple `suchThat`:
---
--- n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-arbitraryTag :: T -> Gen Tag
-arbitraryTag x = do
-  let ts = tags x
-  -- There must be at least 1 workspace, thus at least 1 tag.
-  idx <- choose (0, (length ts) - 1)
-  return $ ts!!idx
-
--- | Pull out an arbitrary window from a StackSet that is guaranteed to have a
--- non empty set of windows. This eliminates the precondition "i `member` x" in
--- a few properties.
---
---
--- foo (nex :: NonEmptyWindowsStackSet) = do
---   let NonEmptyWindowsStackSet x = nex
---   w <- arbitraryWindow nex
---   return $ .......
---
--- We can do the reverse with a simple `suchThat`:
---
---   n <- arbitrary `suchThat` \n' -> not $ n `member` x
-arbitraryWindow :: NonEmptyWindowsStackSet -> Gen Window
-arbitraryWindow (NonEmptyWindowsStackSet x) = do
-  let ws = allWindows x
-  -- We know that there are at least 1 window in a NonEmptyWindowsStackSet.
-  idx <- choose(0, (length ws) - 1)
-  return $ ws!!idx
diff --git a/source/tests/Properties/Delete.hs b/source/tests/Properties/Delete.hs
deleted file mode 100644
index a8b8dd1..0000000
--- a/source/tests/Properties/Delete.hs
+++ /dev/null
@@ -1,70 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Delete where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
--- ---------------------------------------------------------------------
--- 'delete'
-
--- deleting the current item removes it.
-prop_delete x =
-    case peek x of
-        Nothing -> True
-        Just i  -> not (member i (delete i x))
-    where _ = x :: T
-
--- delete is reversible with 'insert'.
--- It is the identity, except for the 'master', which is reset on insert and delete.
---
-prop_delete_insert (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just n  -> insertUp n (delete n y) == y
-    where
-        y = swapMaster x
-
--- delete should be local
-prop_delete_local (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just i  -> hidden_spaces x == hidden_spaces (delete i x)
-
--- delete should not affect focus unless the focused element is what is being deleted
-prop_delete_focus = do
-  -- There should be at least two windows. One in focus, and some to try and
-  -- delete (doesn't have to be windows on the current workspace).  We generate
-  -- our own, since we can't rely on NonEmptyWindowsStackSet returning one in
-  -- the argument with at least two windows.
-  x <- arbitrary `suchThat` \x' -> length (allWindows x') >= 2
-  w <- arbitraryWindow (NonEmptyWindowsStackSet x)
-       -- Make sure we pick a window that is NOT the currently focused
-       `suchThat` \w' -> Just w' /= peek x
-  return $ peek (delete w x) == peek x
-
--- focus movement in the presence of delete:
--- when the last window in the stack set is focused, focus moves `up'.
--- usual case is that it moves 'down'.
-prop_delete_focus_end = do
-    -- Generate a StackSet with at least two windows on the current workspace.
-    x <- arbitrary `suchThat` \(x' :: T) -> length (index x') >= 2
-    let w = last (index x)
-        y = focusWindow w x -- focus last window in stack
-    return $ peek (delete w y) == peek (focusUp y)
-
-
--- focus movement in the presence of delete:
--- when not in the last item in the stack, focus moves down
-prop_delete_focus_not_end = do
-  x <- arbitrary
-       -- There must be at least two windows and the current focused is not the
-       -- last one in the stack.
-       `suchThat` \(x' :: T) ->
-         let currWins = index x'
-         in length (currWins) >= 2 && peek x' /= Just (last currWins)
-  -- This is safe, as we know there are >= 2 windows
-  let Just n = peek x
-  return $ peek (delete n x) == peek (focusDown x)
diff --git a/source/tests/Properties/Failure.hs b/source/tests/Properties/Failure.hs
deleted file mode 100644
index a46d723..0000000
--- a/source/tests/Properties/Failure.hs
+++ /dev/null
@@ -1,30 +0,0 @@
-module Properties.Failure where
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Control.Exception.Extensible as C
-import System.IO.Unsafe
-import Data.List (isPrefixOf)
-
--- ---------------------------------------------------------------------
--- testing for failure and help out hpc
---
--- Since base 4.9.0.0 `error` appends a stack trace. The tests below
--- use `isPrefixOf` to only test equality on the error message.
---
-prop_abort :: Int -> Bool
-prop_abort _ = unsafePerformIO $ C.catch (abort "fail") check
-   where
-     check (C.SomeException e) =
-       return $ "xmonad: StackSet: fail" `isPrefixOf` show e
-
--- new should fail with an abort
-prop_new_abort :: Int -> Bool
-prop_new_abort _ = unsafePerformIO $ C.catch f check
-   where
-     f = new undefined{-layout-} [] [] `seq` return False
-     check (C.SomeException e) =
-       return $ "xmonad: StackSet: non-positive argument to StackSet.new" `isPrefixOf` show e
-
--- TODO: Fix this?
--- prop_view_should_fail = view {- with some bogus data -}
diff --git a/source/tests/Properties/Floating.hs b/source/tests/Properties/Floating.hs
deleted file mode 100644
index a9afad7..0000000
--- a/source/tests/Properties/Floating.hs
+++ /dev/null
@@ -1,36 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Floating where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Data.Map as M
-
-------------------------------------------------------------------------
--- properties for the floating layer:
-
-prop_float_reversible (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  return $ sink w (float w geom x) == x
-        where
-            geom = RationalRect 100 100 100 100
-
-prop_float_geometry (nex :: NonEmptyWindowsStackSet) = do
-    let NonEmptyWindowsStackSet x = nex
-    w <- arbitraryWindow nex
-    let s = float w geom x
-    return $ M.lookup w (floating s) == Just geom
-  where
-    geom = RationalRect 100 100 100 100
-
-prop_float_delete (nex :: NonEmptyWindowsStackSet) = do
-    let NonEmptyWindowsStackSet x = nex
-    w <- arbitraryWindow nex
-    let s = float w geom x
-        t = delete w s
-    return $ not (w `member` t)
-  where
-    geom = RationalRect 100 100 100 100
diff --git a/source/tests/Properties/Focus.hs b/source/tests/Properties/Focus.hs
deleted file mode 100644
index 6bc0055..0000000
--- a/source/tests/Properties/Focus.hs
+++ /dev/null
@@ -1,74 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Focus where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe (fromJust)
-
--- ---------------------------------------------------------------------
--- rotating focus
---
-
--- master/focus
---
--- The tiling order, and master window, of a stack is unaffected by focus changes.
---
-prop_focus_left_master (SizedPositive n) (x::T) =
-    index (applyN (Just n) focusUp x) == index x
-prop_focus_right_master (SizedPositive  n) (x::T) =
-    index (applyN (Just n) focusDown x) == index x
-prop_focus_master_master (SizedPositive n) (x::T) =
-    index (applyN (Just n) focusMaster x) == index x
-
-prop_focusWindow_master (NonNegative n) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = n `mod` length s
-                   in index (focusWindow (s !! i) x) == index x
-
--- shifting focus is trivially reversible
-prop_focus_left  (x :: T) = (focusUp  (focusDown x)) == x
-prop_focus_right (x :: T) = (focusDown (focusUp  x)) ==  x
-
--- focus master is idempotent
-prop_focusMaster_idem (x :: T) = focusMaster x == focusMaster (focusMaster x)
-
--- focusWindow actually leaves the window focused...
-prop_focusWindow_works (NonNegative (n :: Int)) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = fromIntegral n `mod` length s
-                   in (focus . fromJust . stack . workspace . current) (focusWindow (s !! i) x) == (s !! i)
-
--- rotation through the height of a stack gets us back to the start
-prop_focus_all_l (x :: T) = (foldr (const focusUp) x [1..n]) == x
-  where n = length (index x)
-prop_focus_all_r (x :: T) = (foldr (const focusDown) x [1..n]) == x
-  where n = length (index x)
-
--- prop_rotate_all (x :: T) = f (f x) == f x
---     f x' = foldr (\_ y -> rotate GT y) x' [1..n]
-
--- focus is local to the current workspace
-prop_focus_down_local (x :: T) = hidden_spaces (focusDown x) == hidden_spaces x
-prop_focus_up_local (x :: T) = hidden_spaces (focusUp x) == hidden_spaces x
-
-prop_focus_master_local (x :: T) = hidden_spaces (focusMaster x) == hidden_spaces x
-
-prop_focusWindow_local (NonNegative (n :: Int)) (x::T ) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let s = index x
-                       i = fromIntegral n `mod` length s
-                   in hidden_spaces (focusWindow (s !! i) x) == hidden_spaces x
-
--- On an invalid window, the stackset is unmodified
-prop_focusWindow_identity (x::T ) = do
-    n <- arbitrary `suchThat` \n' -> not $ n' `member` x
-    return $ focusWindow n x == x
diff --git a/source/tests/Properties/GreedyView.hs b/source/tests/Properties/GreedyView.hs
deleted file mode 100644
index 3f2eb9b..0000000
--- a/source/tests/Properties/GreedyView.hs
+++ /dev/null
@@ -1,44 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.GreedyView where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (sortBy)
-
--- ---------------------------------------------------------------------
--- greedyViewing workspaces
-
--- greedyView sets the current workspace to 'n'
-prop_greedyView_current (x :: T)  = do
-    n <- arbitraryTag x
-    return $ currentTag (greedyView n x) == n
-
--- greedyView leaves things unchanged for invalid workspaces
-prop_greedyView_current_id (x :: T) = do
-  n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-  return $ currentTag (greedyView n x) == currentTag x
-
--- greedyView *only* sets the current workspace, and touches Xinerama.
--- no workspace contents will be changed.
-prop_greedyView_local  (x :: T) = do
-    n <- arbitraryTag x
-    return $ workspaces x == workspaces (greedyView n x)
-  where
-    workspaces a = sortBy (\s t -> tag s `compare` tag t) $
-                                    workspace (current a)
-                                    : map workspace (visible a) ++ hidden a
-
--- greedyView is idempotent
-prop_greedyView_idem (x :: T) = do
-  n <- arbitraryTag x
-  return $ greedyView n (greedyView n x) == (greedyView n x)
-
--- greedyView is reversible, though shuffles the order of hidden/visible
-prop_greedyView_reversible (x :: T) = do
-    n <- arbitraryTag x
-    return $ normal (greedyView n' (greedyView n x)) == normal x
-    where n'  = currentTag x
diff --git a/source/tests/Properties/Insert.hs b/source/tests/Properties/Insert.hs
deleted file mode 100644
index c277795..0000000
--- a/source/tests/Properties/Insert.hs
+++ /dev/null
@@ -1,52 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Insert where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (nub)
-
--- ---------------------------------------------------------------------
--- 'insert'
-
--- inserting a item into an empty stackset means that item is now a member
-prop_insert_empty i (EmptyStackSet x)= member i (insertUp i x)
-
--- insert should be idempotent
-prop_insert_idem i (x :: T) = insertUp i x == insertUp i (insertUp i x)
-
--- insert when an item is a member should leave the stackset unchanged
-prop_insert_duplicate (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  return $ insertUp w x == x
-
--- push shouldn't change anything but the current workspace
-prop_insert_local (x :: T) = do
-  i <- arbitrary `suchThat` \i' -> not $ i' `member` x
-  return $ hidden_spaces x == hidden_spaces (insertUp i x)
-
--- Inserting a (unique) list of items into an empty stackset should
--- result in the last inserted element having focus.
-prop_insert_peek (EmptyStackSet x) (NonEmptyNubList is) =
-    peek (foldr insertUp x is) == Just (head is)
-
--- insert >> delete is the identity, when i `notElem` .
--- Except for the 'master', which is reset on insert and delete.
---
-prop_insert_delete x = do
-  n <- arbitrary `suchThat` \n -> not $ n `member` x
-  return $ delete n (insertUp n y) == (y :: T)
-    where
-        y = swapMaster x -- sets the master window to the current focus.
-                         -- otherwise, we don't have a rule for where master goes.
-
--- inserting n elements increases current stack size by n
-prop_size_insert is (EmptyStackSet x) =
-        size (foldr insertUp x ws ) ==  (length ws)
-  where
-    ws   = nub is
-    size = length . index
diff --git a/source/tests/Properties/Layout/Full.hs b/source/tests/Properties/Layout/Full.hs
deleted file mode 100644
index eca6ec3..0000000
--- a/source/tests/Properties/Layout/Full.hs
+++ /dev/null
@@ -1,34 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Layout.Full where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-import XMonad.Core
-import XMonad.Layout
-
-import Data.Maybe
-
-------------------------------------------------------------------------
--- Full layout
-
--- pureLayout works for Full
-prop_purelayout_full rect = do
-  x <- (arbitrary :: Gen T) `suchThat` (isJust . peek)
-  let layout = Full
-      st = fromJust . stack . workspace . current $ x
-      ts = pureLayout layout rect st
-  return $
-        length ts == 1        -- only one window to view
-      &&
-        snd (head ts) == rect -- and sets fullscreen
-      &&
-        fst (head ts) == fromJust (peek x) -- and the focused window is shown
-
-
--- what happens when we send an IncMaster message to Full --- Nothing
-prop_sendmsg_full (NonNegative k) =
-         isNothing (Full `pureMessage` (SomeMessage (IncMasterN k)))
-
-prop_desc_full = description Full == show Full
diff --git a/source/tests/Properties/Layout/Tall.hs b/source/tests/Properties/Layout/Tall.hs
deleted file mode 100644
index 5353e62..0000000
--- a/source/tests/Properties/Layout/Tall.hs
+++ /dev/null
@@ -1,116 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Layout.Tall where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-import XMonad.Core
-import XMonad.Layout
-
-import Graphics.X11.Xlib.Types (Rectangle(..))
-
-import Data.Maybe
-import Data.List (sort)
-import Data.Ratio
-
-------------------------------------------------------------------------
--- The Tall layout
-
--- 1 window should always be tiled fullscreen
-prop_tile_fullscreen rect = tile pct rect 1 1 == [rect]
-    where pct = 1/2
-
--- multiple windows
-prop_tile_non_overlap rect windows nmaster = noOverlaps (tile pct rect nmaster windows)
-  where _ = rect :: Rectangle
-        pct = 3 % 100
-
--- splitting horizontally yields sensible results
-prop_split_horizontal (NonNegative n) x =
-      (noOverflows (+) (rect_x x) (rect_width x)) ==>
-        sum (map rect_width xs) == rect_width x
-     &&
-        all (== rect_height x) (map rect_height xs)
-     &&
-        (map rect_x xs) == (sort $ map rect_x xs)
-
-    where
-        xs = splitHorizontally n x
-
--- splitting vertically yields sensible results
-prop_split_vertical (r :: Rational) x =
-        rect_x x == rect_x a && rect_x x == rect_x b
-      &&
-        rect_width x == rect_width a && rect_width x == rect_width b
-    where
-        (a,b) = splitVerticallyBy r x
-
-
--- pureLayout works.
-prop_purelayout_tall n r1 r2 rect = do
-  x <- (arbitrary :: Gen T) `suchThat` (isJust . peek)
-  let layout = Tall n r1 r2
-      st = fromJust . stack . workspace . current $ x
-      ts = pureLayout layout rect st
-  return $
-        length ts == length (index x)
-      &&
-        noOverlaps (map snd ts)
-      &&
-        description layout == "Tall"
-
-
--- Test message handling of Tall
-
--- what happens when we send a Shrink message to Tall
-prop_shrink_tall (NonNegative n) (Positive delta) (NonNegative frac) =
-        n == n' && delta == delta' -- these state components are unchanged
-    && frac' <= frac  && (if frac' < frac then frac' == 0 || frac' == frac - delta
-                                          else frac == 0 )
-        -- remaining fraction should shrink
-    where
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage Shrink)
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
-
--- what happens when we send a Shrink message to Tall
-prop_expand_tall (NonNegative n)
-                 (Positive delta)
-                 (NonNegative n1)
-                 (Positive d1) =
-
-       n == n'
-    && delta == delta' -- these state components are unchanged
-    && frac' >= frac
-    && (if frac' > frac
-           then frac' == 1 || frac' == frac + delta
-           else frac == 1 )
-
-        -- remaining fraction should shrink
-    where
-         frac                 = min 1 (n1 % d1)
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage Expand)
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
--- what happens when we send an IncMaster message to Tall
-prop_incmaster_tall (NonNegative n) (Positive delta) (NonNegative frac)
-                    (NonNegative k) =
-       delta == delta'  && frac == frac' && n' == n + k
-    where
-         l1                   = Tall n delta frac
-         Just l2@(Tall n' delta' frac') = l1 `pureMessage` (SomeMessage (IncMasterN k))
-        --  pureMessage :: layout a -> SomeMessage -> Maybe (layout a)
-
-
-
-     --   toMessage LT = SomeMessage Shrink
-     --   toMessage EQ = SomeMessage Expand
-     --   toMessage GT = SomeMessage (IncMasterN 1)
-
-
-prop_desc_mirror n r1 r2 = description (Mirror $! t) == "Mirror Tall"
-    where t = Tall n r1 r2
diff --git a/source/tests/Properties/Screen.hs b/source/tests/Properties/Screen.hs
deleted file mode 100644
index d12f954..0000000
--- a/source/tests/Properties/Screen.hs
+++ /dev/null
@@ -1,73 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Screen where
-
-import Utils
-import Test.QuickCheck
-import Instances
-
-import Control.Applicative
-import XMonad.StackSet hiding (filter)
-import XMonad.Operations
-import Graphics.X11.Xlib.Types (Dimension)
-
-import Graphics.X11 (Rectangle(Rectangle))
-import XMonad.Layout
-
-prop_screens (x :: T) = n `elem` screens x
- where
-    n = current x
-
--- screens makes sense
-prop_screens_works (x :: T) = screens x == current x : visible x
-
-
-------------------------------------------------------------------------
--- Hints
-
-prop_resize_inc (Positive inc_w,Positive inc_h)  b@(w,h) =
-    w' `mod` inc_w == 0 && h' `mod` inc_h == 0
-   where (w',h') = applyResizeIncHint a b
-         a = (inc_w,inc_h)
-
-prop_resize_inc_extra ((NonNegative inc_w))  b@(w,h) =
-     (w,h) == (w',h')
-   where (w',h') = applyResizeIncHint a b
-         a = (-inc_w,0::Dimension)-- inc_h)
-
-prop_resize_max (Positive inc_w,Positive inc_h)  b@(w,h) =
-    w' <= inc_w && h' <= inc_h
-   where (w',h') = applyMaxSizeHint a b
-         a = (inc_w,inc_h)
-
-prop_resize_max_extra ((NonNegative inc_w))  b@(w,h) =
-     (w,h) == (w',h')
-   where (w',h') = applyMaxSizeHint a b
-         a = (-inc_w,0::Dimension)-- inc_h)
-
-
-prop_aspect_hint_shrink hint (w,h) = case applyAspectHint hint (w,h) of
-  (w',h') -> w' <= w && h' <= h
-
-
--- applyAspectHint does nothing when the supplied (x,y) fits
--- the desired range
-prop_aspect_fits =
-    forAll ((,,,) <$> pos <*> pos <*> pos <*> pos) $ \ (x,y,a,b) -> 
-    let f v = applyAspectHint ((x, y+a), (x+b, y)) v
-    in  and [ noOverflows (*) x (y+a), noOverflows (*) (x+b) y ]
-            ==> f (x,y) == (x,y)
-
-  where pos = choose (0, 65535)
-        mul a b = toInteger (a*b) /= toInteger a * toInteger b
-
-prop_point_within r @ (Rectangle x y w h) =
-    forAll ((,) <$>
-              choose (0, fromIntegral w - 1) <*>
-              choose (0, fromIntegral h - 1)) $
-        \(dx,dy) ->
-    and [ dx > 0, dy > 0,
-         noOverflows (\ a b -> a + abs b) x w,
-         noOverflows (\ a b -> a + abs b) y h ]
-      ==> pointWithin (x+dx) (y+dy) r
-
-prop_point_within_mirror r (x,y) = pointWithin x y r == pointWithin y x (mirrorRect r)
diff --git a/source/tests/Properties/Shift.hs b/source/tests/Properties/Shift.hs
deleted file mode 100644
index 2150cbf..0000000
--- a/source/tests/Properties/Shift.hs
+++ /dev/null
@@ -1,70 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Shift where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import qualified Data.List as L
-
--- ---------------------------------------------------------------------
--- shift
-
--- shift is fully reversible on current window, when focus and master
--- are the same. otherwise, master may move.
-prop_shift_reversible (x :: T) = do
-    i <- arbitraryTag x
-    case peek y of
-      Nothing -> return True
-      Just _  -> return $ normal ((view n . shift n . view i . shift i) y) == normal y
-    where
-        y = swapMaster x
-        n = currentTag y
-
-------------------------------------------------------------------------
--- shiftMaster
-
--- focus/local/idempotent same as swapMaster:
-prop_shift_master_focus (x :: T) = peek x == (peek $ shiftMaster x)
-prop_shift_master_local (x :: T) = hidden_spaces x == hidden_spaces (shiftMaster x)
-prop_shift_master_idempotent (x :: T) = shiftMaster (shiftMaster x) == shiftMaster x
--- ordering is constant modulo the focused window:
-prop_shift_master_ordering (x :: T) = case peek x of
-    Nothing -> True
-    Just m  -> L.delete m (index x) == L.delete m (index $ shiftMaster x)
-
--- ---------------------------------------------------------------------
--- shiftWin
-
--- shiftWin on current window is the same as shift
-prop_shift_win_focus (x :: T) = do
-    n <- arbitraryTag x
-    case peek x of
-      Nothing -> return True
-      Just w  -> return $ shiftWin n w x == shift n x
-
--- shiftWin on a non-existant window is identity
-prop_shift_win_indentity (x :: T) = do
-    n <- arbitraryTag x
-    w <- arbitrary `suchThat` \w' -> not (w' `member` x)
-    return $ shiftWin n w x == x
-
--- shiftWin leaves the current screen as it is, if neither n is the tag
--- of the current workspace nor w on the current workspace
-prop_shift_win_fix_current = do
-  x <- arbitrary `suchThat` \(x' :: T) ->
-         -- Invariant, otherWindows are NOT in the current workspace.
-         let otherWindows = allWindows x' L.\\ index x'
-         in  length(tags x') >= 2 && length(otherWindows) >= 1
-  -- Sadly we have to construct `otherWindows` again, for the actual StackSet
-  -- that got chosen.
-  let otherWindows = allWindows x L.\\ index x
-  -- We know such tag must exists, due to the precondition
-  n <- arbitraryTag x `suchThat` (/= currentTag x)
-  -- we know length is >= 1, from above precondition
-  idx <- choose(0, length(otherWindows) - 1)
-  let w = otherWindows !! idx
-  return $ (current $ x) == (current $ shiftWin n w x)
-
diff --git a/source/tests/Properties/Stack.hs b/source/tests/Properties/Stack.hs
deleted file mode 100644
index 586df1d..0000000
--- a/source/tests/Properties/Stack.hs
+++ /dev/null
@@ -1,51 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Stack where
-
-import Test.QuickCheck
-import Instances
-
-import XMonad.StackSet hiding (filter)
-import qualified XMonad.StackSet as S (filter)
-
-import Data.Maybe
-
-
--- The list returned by index should be the same length as the actual
--- windows kept in the zipper
-prop_index_length (x :: T) =
-    case stack . workspace . current $ x of
-        Nothing   -> length (index x) == 0
-        Just it -> length (index x) == length (focus it : up it ++ down it)
-
-
--- For all windows in the stackSet, findTag should identify the
--- correct workspace
-prop_findIndex (x :: T) =
-    and [ tag w == fromJust (findTag i x)
-        | w <- workspace (current x) : map workspace (visible x)  ++ hidden x
-        , t <- maybeToList (stack w)
-        , i <- focus t : up t ++ down t
-        ]
-
-prop_allWindowsMember (NonEmptyWindowsStackSet x) = do
-      -- Reimplementation of arbitraryWindow, but to make sure that
-      -- implementation doesn't change in the future, and stop using allWindows,
-      -- which is a key component in this test (together with member).
-  let ws = allWindows x
-  -- We know that there are at least 1 window in a NonEmptyWindowsStackSet.
-  idx <- choose(0, (length ws) - 1)
-  return $ member (ws!!idx) x
-
-
--- preserve order
-prop_filter_order (x :: T) =
-    case stack $ workspace $ current x of
-        Nothing -> True
-        Just s@(Stack i _ _) -> integrate' (S.filter (/= i) s) == filter (/= i) (integrate' (Just s))
-
--- differentiate should return Nothing if the list is empty or Just stack, with
--- the first element of the list is current, and the rest of the list is down.
-prop_differentiate xs =
-        if null xs then differentiate xs == Nothing
-                   else (differentiate xs) == Just (Stack (head xs) [] (tail xs))
-    where _ = xs :: [Int]
diff --git a/source/tests/Properties/StackSet.hs b/source/tests/Properties/StackSet.hs
deleted file mode 100644
index 7fc5192..0000000
--- a/source/tests/Properties/StackSet.hs
+++ /dev/null
@@ -1,135 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.StackSet where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe
-
-import Data.List (nub)
--- ---------------------------------------------------------------------
--- QuickCheck properties for the StackSet
-
--- Some general hints for creating StackSet properties:
---
--- *  ops that mutate the StackSet are usually local
--- *  most ops on StackSet should either be trivially reversible, or
---    idempotent, or both.
-------------------------------------------------------------------------
-
--- Basic data invariants of the StackSet
---
--- With the new zipper-based StackSet, tracking focus is no longer an
--- issue: the data structure enforces focus by construction.
---
--- But we still need to ensure there are no duplicates, and master/and
--- the xinerama mapping aren't checked by the data structure at all.
---
--- * no element should ever appear more than once in a StackSet
--- * the xinerama screen map should be:
---          -- keys should always index valid workspaces
---          -- monotonically ascending in the elements
--- * the current workspace should be a member of the xinerama screens
---
-invariant (s :: T) = and
-    -- no duplicates
-    [ noDuplicates
-
-    -- TODO: Fix this.
-    -- all this xinerama stuff says we don't have the right structure
---  , validScreens
---  , validWorkspaces
---  , inBounds
-    ]
-  where
-    ws = concat [ focus t : up t ++ down t
-                  | w <- workspace (current s) : map workspace (visible s) ++ hidden s
-                  , t <- maybeToList (stack w)] :: [Char]
-    noDuplicates = nub ws == ws
-
---  validScreens = monotonic . sort . M. . (W.current s : W.visible : W$ s
-
---  validWorkspaces = and [ w `elem` allworkspaces | w <- (M.keys . screens) s ]
---          where allworkspaces = map tag $ current s : prev s ++ next s
-
---  inBounds  = and [ w >=0 && w < size s | (w,sc) <- M.assocs (screens s) ]
-
-monotonic []       = True
-monotonic (x:[])   = True
-monotonic (x:y:zs) | x == y-1  = monotonic (y:zs)
-                   | otherwise = False
-
-prop_invariant = invariant
-
--- and check other ops preserve invariants
-prop_empty_I  (SizedPositive n) l = forAll (choose (1, fromIntegral n)) $  \m ->
-                                      forAll (vector m) $ \ms ->
-        invariant $ new l [0..fromIntegral n-1] ms
-
-prop_view_I n (x :: T) =
-    invariant $ view n x
-
-prop_greedyView_I n (x :: T) =
-    invariant $ greedyView n x
-
-prop_focusUp_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusUp x
-prop_focusMaster_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusMaster x
-prop_focusDown_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) focusDown x
-
-prop_focus_I (SizedPositive n) (x :: T) =
-    case peek x of
-        Nothing -> True
-        Just _  -> let w = focus . fromJust . stack . workspace . current $
-                           applyN (Just n) focusUp x
-                   in invariant $ focusWindow w x
-
-prop_insertUp_I n (x :: T) = invariant $ insertUp n x
-
-prop_delete_I (x :: T) = invariant $
-    case peek x of
-        Nothing -> x
-        Just i  -> delete i x
-
-prop_swap_master_I (x :: T) = invariant $ swapMaster x
-
-prop_swap_left_I  (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) swapUp x
-prop_swap_right_I (SizedPositive n) (x :: T) =
-    invariant $ applyN (Just n) swapDown x
-
-prop_shift_I (x :: T) = do
-  n <- arbitraryTag x
-  return $ invariant $ shift (fromIntegral n) x
-
-prop_shift_win_I (nex :: NonEmptyWindowsStackSet) = do
-  let NonEmptyWindowsStackSet x = nex
-  w <- arbitraryWindow nex
-  n <- arbitraryTag x
-  return $ invariant $ shiftWin n w x
-
-
--- ---------------------------------------------------------------------
-
-
--- empty StackSets have no windows in them
-prop_empty (EmptyStackSet x) =
-        all (== Nothing) [ stack w | w <- workspace (current x)
-                                        : map workspace (visible x) ++ hidden x ]
-
--- empty StackSets always have focus on first workspace
-prop_empty_current (EmptyStackSet x) = currentTag x == head (tags x)
-
--- no windows will be a member of an empty workspace
-prop_member_empty i (EmptyStackSet x) = member i x == False
-
--- peek either yields nothing on the Empty workspace, or Just a valid window
-prop_member_peek (x :: T) =
-    case peek x of
-        Nothing -> True {- then we don't know anything -}
-        Just i  -> member i x
diff --git a/source/tests/Properties/Swap.hs b/source/tests/Properties/Swap.hs
deleted file mode 100644
index a516f2c..0000000
--- a/source/tests/Properties/Swap.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Swap where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
--- ---------------------------------------------------------------------
--- swapUp, swapDown, swapMaster: reordiring windows
-
--- swap is trivially reversible
-prop_swap_left  (x :: T) = (swapUp  (swapDown x)) == x
-prop_swap_right (x :: T) = (swapDown (swapUp  x)) ==  x
--- TODO swap is reversible
--- swap is reversible, but involves moving focus back the window with
--- master on it. easy to do with a mouse...
-{-
-prop_promote_reversible x b = (not . null . fromMaybe [] . flip index x . current $ x) ==>
-                            (raiseFocus y . promote . raiseFocus z . promote) x == x
-  where _            = x :: T
-        dir          = if b then LT else GT
-        (Just y)     = peek x
-        (Just (z:_)) = flip index x . current $ x
--}
-
--- swap doesn't change focus
-prop_swap_master_focus (x :: T) = peek x == (peek $ swapMaster x)
---    = case peek x of
---        Nothing -> True
---        Just f  -> focus (stack (workspace $ current (swap x))) == f
-prop_swap_left_focus   (x :: T) = peek x == (peek $ swapUp   x)
-prop_swap_right_focus  (x :: T) = peek x == (peek $ swapDown  x)
-
--- swap is local
-prop_swap_master_local (x :: T) = hidden_spaces x == hidden_spaces (swapMaster x)
-prop_swap_left_local   (x :: T) = hidden_spaces x == hidden_spaces (swapUp   x)
-prop_swap_right_local  (x :: T) = hidden_spaces x == hidden_spaces (swapDown  x)
-
--- rotation through the height of a stack gets us back to the start
-prop_swap_all_l (x :: T) = (foldr (const swapUp)  x [1..n]) == x
-  where n = length (index x)
-prop_swap_all_r (x :: T) = (foldr (const swapDown) x [1..n]) == x
-  where n = length (index x)
-
-prop_swap_master_idempotent (x :: T) = swapMaster (swapMaster x) == swapMaster x
diff --git a/source/tests/Properties/View.hs b/source/tests/Properties/View.hs
deleted file mode 100644
index ef9b58d..0000000
--- a/source/tests/Properties/View.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.View where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.List (sortBy)
-
--- ---------------------------------------------------------------------
--- viewing workspaces
-
--- view sets the current workspace to 'n'
-prop_view_current (x :: T) = do
-    n <- arbitraryTag x
-    return $ (tag . workspace . current . view n) x == n
-
--- view *only* sets the current workspace, and touches Xinerama.
--- no workspace contents will be changed.
-prop_view_local  (x :: T) = do
-    n <- arbitraryTag x
-    return $ workspaces x == workspaces (view n x)
-  where
-    workspaces a = sortBy (\s t -> tag s `compare` tag t) $
-                                    workspace (current a)
-                                    : map workspace (visible a) ++ hidden a
-
--- TODO: Fix this
--- view should result in a visible xinerama screen
--- prop_view_xinerama (x :: T) (n :: NonNegative Int) = i `tagMember` x ==>
---     M.member i (screens (view i x))
---   where
---     i = fromIntegral n
-
--- view is idempotent
-prop_view_idem (x :: T) = do
-    n <- arbitraryTag x
-    return $ view n (view n x) == (view n x)
-
--- view is reversible, though shuffles the order of hidden/visible
-prop_view_reversible (x :: T) = do
-    n <- arbitraryTag x
-    return $ normal (view n' (view n x)) == normal x
-  where
-    n' = currentTag x
diff --git a/source/tests/Properties/Workspace.hs b/source/tests/Properties/Workspace.hs
deleted file mode 100644
index 612cba9..0000000
--- a/source/tests/Properties/Workspace.hs
+++ /dev/null
@@ -1,65 +0,0 @@
-{-# LANGUAGE ScopedTypeVariables #-}
-module Properties.Workspace where
-
-import Test.QuickCheck
-import Instances
-import Utils
-
-import XMonad.StackSet hiding (filter)
-
-import Data.Maybe
-
--- looking up the tag of the current workspace should always produce a tag.
-prop_lookup_current (x :: T) = lookupWorkspace scr x == Just tg
-    where
-        (Screen (Workspace tg  _ _) scr _) = current x
-
--- looking at a visible tag
-prop_lookup_visible = do
-  -- make sure we have some xinerama screens.
-  x <- arbitrary `suchThat` \(x' :: T) -> visible x' /= []
-  let tags = [ tag (workspace y) | y <- visible x ]
-      scr = last [ screen y | y <- visible x ]
-  return $ fromJust (lookupWorkspace scr x) `elem` tags
-
-
-prop_currentTag (x :: T) =
-    currentTag x == tag (workspace (current x))
-
--- Rename a given tag if present in the StackSet.
-prop_rename1 (x::T) = do
-  o <- arbitraryTag x
-  n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-  -- Rename o to n
-  let y = renameTag o n x
-  return $ n `tagMember` y
-
--- Ensure that a given set of workspace tags is present by renaming
--- existing workspaces and\/or creating new hidden workspaces as
--- necessary.
---
-prop_ensure (x :: T) l xs = let y = ensureTags l xs x
-                                in and [ n `tagMember` y | n <- xs ]
-
--- adding a tag should create a new hidden workspace
-prop_ensure_append (x :: T) l = do
-    n <- arbitrary `suchThat` \n' -> not $ n' `tagMember` x
-    let ts = tags x
-        y  = ensureTags l (n:ts) x
-    return $ hidden y /= hidden x     -- doesn't append, renames
-             && and [ isNothing (stack z) && layout z == l | z <- hidden y, tag z == n ]
-
-
-
-
-prop_mapWorkspaceId (x::T) = x == mapWorkspace id x
-
-prop_mapWorkspaceInverse (x::T) = x == mapWorkspace predTag (mapWorkspace succTag x)
-  where predTag w = w { tag = pred $ tag w }
-        succTag w = w { tag = succ $ tag w }
-
-prop_mapLayoutId (x::T) = x == mapLayout id x
-
-prop_mapLayoutInverse (x::T) = x == mapLayout pred (mapLayout succ x)
-
-
diff --git a/source/tests/Properties.hs b/source/tests/Properties.hs
deleted file mode 100644
index 62ebeb6..0000000
--- a/source/tests/Properties.hs
+++ /dev/null
@@ -1,201 +0,0 @@
-import Test.QuickCheck
-
--- Our QC instances and properties:
-import Instances
-import Properties.Delete
-import Properties.Failure
-import Properties.Floating
-import Properties.Focus
-import Properties.GreedyView
-import Properties.Insert
-import Properties.Screen
-import Properties.Shift
-import Properties.Stack
-import Properties.StackSet
-import Properties.Swap
-import Properties.View
-import Properties.Workspace
-import Properties.Layout.Full
-import Properties.Layout.Tall
-
-import System.Environment
-import Text.Printf
-
-import Control.Monad
-import Control.Applicative
-
-main :: IO ()
-main = do
-  arg <- fmap (drop 1) getArgs
-  let n = if null arg then 100 else read $ head arg
-      args = stdArgs { maxSuccess = n, maxSize = 100 }
-      qc t = do
-          c <- quickCheckWithResult args t
-          case c of
-            Success {} -> return True
-            _ -> return False
-      perform (s, t) = printf "%-35s: " s >> qc t
-  n <- length . filter not <$> mapM perform tests
-  unless (n == 0) (error (show n ++ " test(s) failed"))
-
-
-
-tests =
-  [("StackSet invariants", property prop_invariant)
-  ,("empty: invariant",    property prop_empty_I)
-  ,("empty is empty",      property prop_empty)
-  ,("empty / current",     property prop_empty_current)
-  ,("empty / member",      property prop_member_empty)
-
-
-  ,("view : invariant",  property prop_view_I)
-  ,("view sets current", property prop_view_current)
-  ,("view idempotent",   property prop_view_idem)
-  ,("view reversible",   property prop_view_reversible)
-
-  ,("view is local",  property prop_view_local)
-
-  ,("greedyView : invariant",  property prop_greedyView_I)
-  ,("greedyView sets current", property prop_greedyView_current)
-  ,("greedyView is safe",      property prop_greedyView_current_id)
-  ,("greedyView idempotent",   property prop_greedyView_idem)
-  ,("greedyView reversible",   property prop_greedyView_reversible)
-  ,("greedyView is local",     property prop_greedyView_local)
-
-  ,("peek/member",  property prop_member_peek)
-
-  ,("index/length", property prop_index_length)
-
-  ,("focus left : invariant",    property prop_focusUp_I)
-  ,("focus master : invariant",  property prop_focusMaster_I)
-  ,("focus right: invariant",    property prop_focusDown_I)
-  ,("focusWindow: invariant",    property prop_focus_I)
-  ,("focus left/master",         property prop_focus_left_master)
-  ,("focus right/master",        property prop_focus_right_master)
-  ,("focus master/master",       property prop_focus_master_master)
-  ,("focusWindow master",        property prop_focusWindow_master)
-  ,("focus left/right",          property prop_focus_left)
-  ,("focus right/left",          property prop_focus_right)
-  ,("focus all left",            property prop_focus_all_l)
-  ,("focus all right",           property prop_focus_all_r)
-  ,("focus down is local",       property prop_focus_down_local)
-  ,("focus up is local",         property prop_focus_up_local)
-  ,("focus master is local",     property prop_focus_master_local)
-  ,("focus master idemp",        property prop_focusMaster_idem)
-
-  ,("focusWindow is local", property prop_focusWindow_local)
-  ,("focusWindow works"   , property prop_focusWindow_works)
-  ,("focusWindow identity", property prop_focusWindow_identity)
-
-  ,("findTag",           property prop_findIndex)
-  ,("allWindows/member", property prop_allWindowsMember)
-  ,("currentTag",        property prop_currentTag)
-
-  ,("insert: invariant",    property prop_insertUp_I)
-  ,("insert/new",           property prop_insert_empty)
-  ,("insert is idempotent", property prop_insert_idem)
-  ,("insert is reversible", property prop_insert_delete)
-  ,("insert is local",      property prop_insert_local)
-  ,("insert duplicates",    property prop_insert_duplicate)
-  ,("insert/peek",          property prop_insert_peek)
-  ,("insert/size",          property prop_size_insert)
-
-  ,("delete: invariant",       property prop_delete_I)
-  ,("delete/empty",            property prop_empty)
-  ,("delete/member",           property prop_delete)
-  ,("delete is reversible",    property prop_delete_insert)
-  ,("delete is local",         property prop_delete_local)
-  ,("delete/focus",            property prop_delete_focus)
-  ,("delete  last/focus up",   property prop_delete_focus_end)
-  ,("delete ~last/focus down", property prop_delete_focus_not_end)
-
-  ,("filter preserves order", property prop_filter_order)
-
-  ,("swapLeft",  property prop_swap_left)
-  ,("swapRight", property prop_swap_right)
-
-  ,("swapMaster: invariant",    property prop_swap_master_I)
-  ,("swapUp: invariant" ,       property prop_swap_left_I)
-  ,("swapDown: invariant",      property prop_swap_right_I)
-  ,("swapMaster id on focus",   property prop_swap_master_focus)
-  ,("swapUp id on focus",       property prop_swap_left_focus)
-  ,("swapDown id on focus",     property prop_swap_right_focus)
-  ,("swapMaster is idempotent", property prop_swap_master_idempotent)
-  ,("swap all left",            property prop_swap_all_l)
-  ,("swap all right",           property prop_swap_all_r)
-  ,("swapMaster is local",      property prop_swap_master_local)
-  ,("swapUp is local",          property prop_swap_left_local)
-  ,("swapDown is local",        property prop_swap_right_local)
-
-  ,("shiftMaster id on focus",        property prop_shift_master_focus)
-  ,("shiftMaster is local",           property prop_shift_master_local)
-  ,("shiftMaster is idempotent",      property prop_shift_master_idempotent)
-  ,("shiftMaster preserves ordering", property prop_shift_master_ordering)
-
-  ,("shift: invariant"    ,       property prop_shift_I)
-  ,("shift is reversible" ,       property prop_shift_reversible)
-  ,("shiftWin: invariant" ,       property prop_shift_win_I)
-  ,("shiftWin is shift on focus", property prop_shift_win_focus)
-  ,("shiftWin fix current" ,      property prop_shift_win_fix_current)
-  ,("shiftWin identity",          property prop_shift_win_indentity)
-
-  ,("floating is reversible" ,  property prop_float_reversible)
-  ,("floating sets geometry" ,  property prop_float_geometry)
-  ,("floats can be deleted",    property prop_float_delete)
-  ,("screens includes current", property prop_screens)
-
-  ,("differentiate works",     property prop_differentiate)
-  ,("lookupTagOnScreen",       property prop_lookup_current)
-  ,("lookupTagOnVisbleScreen", property prop_lookup_visible)
-  ,("screens works",           property prop_screens_works)
-  ,("renaming works",          property prop_rename1)
-  ,("ensure works",            property prop_ensure)
-  ,("ensure hidden semantics", property prop_ensure_append)
-
-  ,("mapWorkspace id",      property prop_mapWorkspaceId)
-  ,("mapWorkspace inverse", property prop_mapWorkspaceInverse)
-
-  ,("mapLayout id",      property prop_mapLayoutId)
-  ,("mapLayout inverse", property prop_mapLayoutInverse)
-
-  ,("abort fails",            property prop_abort)
-  ,("new fails with abort",   property prop_new_abort)
-
-  ,("point within",           property prop_point_within)
-
-  -- tall layout
-
-  ,("tile 1 window fullsize", property prop_tile_fullscreen)
-  ,("tiles never overlap",    property prop_tile_non_overlap)
-  ,("split horizontal",       property prop_split_horizontal)
-  ,("split vertical",         property prop_split_vertical)
-
-  ,("pure layout tall",       property prop_purelayout_tall)
-  ,("send shrink    tall",    property prop_shrink_tall)
-  ,("send expand    tall",    property prop_expand_tall)
-  ,("send incmaster tall",    property prop_incmaster_tall)
-
-  -- full layout
-
-  ,("pure layout full",       property prop_purelayout_full)
-  ,("send message full",      property prop_sendmsg_full)
-  ,("describe full",          property prop_desc_full)
-
-  ,("describe mirror",        property prop_desc_mirror)
-
-  -- resize hints
-  ,("window resize hints: inc",      property prop_resize_inc)
-  ,("window resize hints: inc all",  property prop_resize_inc_extra)
-  ,("window resize hints: max",      property prop_resize_max)
-  ,("window resize hints: max all ", property prop_resize_max_extra)
-
-  ,("window aspect hints: fits", property prop_aspect_fits)
-  ,("window aspect hints: shrinks ", property prop_aspect_hint_shrink)
-
-
-  ,("pointWithin",        property prop_point_within)
-  ,("pointWithin mirror", property prop_point_within_mirror)
-
-  ]
-
-
diff --git a/source/tests/Utils.hs b/source/tests/Utils.hs
deleted file mode 100644
index e3eef0f..0000000
--- a/source/tests/Utils.hs
+++ /dev/null
@@ -1,47 +0,0 @@
-{-# LANGUAGE RankNTypes #-}
-module Utils where
-
-import XMonad.StackSet hiding (filter)
-import Graphics.X11.Xlib.Types (Rectangle(..))
-import Data.List (sortBy)
-
--- Useful operation, the non-local workspaces
-hidden_spaces x = map workspace (visible x) ++ hidden x
-
-
--- normalise workspace list
-normal s = s { hidden = sortBy g (hidden s), visible = sortBy f (visible s) }
-    where
-        f = \a b -> tag (workspace a) `compare` tag (workspace b)
-        g = \a b -> tag a `compare` tag b
-
-
-noOverlaps []  = True
-noOverlaps [_] = True
-noOverlaps xs  = and [ verts a `notOverlap` verts b
-                     | a <- xs
-                     , b <- filter (a /=) xs
-                     ]
-    where
-      verts (Rectangle a b w h) = (a,b,a + fromIntegral w - 1, b + fromIntegral h - 1)
-
-      notOverlap (left1,bottom1,right1,top1)
-                 (left2,bottom2,right2,top2)
-        =  (top1 < bottom2 || top2 < bottom1)
-        || (right1 < left2 || right2 < left1)
-
-
-applyN :: (Integral n) => Maybe n -> (a -> a) -> a -> a
-applyN Nothing f v = v
-applyN (Just 0) f v = v
-applyN (Just n) f v = applyN (Just $ n-1) f (f v)
-
-tags x = map tag $ workspaces x
-
-
--- | noOverflows op a b is True if @a `op` fromIntegral b@ overflows (or
--- otherwise gives the same answer when done using Integer
-noOverflows :: (Integral b, Integral c) =>
-  (forall a. Integral a => a -> a -> a) -> b -> c -> Bool
-noOverflows op a b = toInteger (a `op` fromIntegral b) == toInteger a `op` toInteger b
-
diff --git a/source/tests/loc.hs b/source/tests/loc.hs
deleted file mode 100644
index 238204a..0000000
--- a/source/tests/loc.hs
+++ /dev/null
@@ -1,14 +0,0 @@
-import Control.Monad
-import System.Exit
-
-main = do foo <- getContents
-          let actual_loc = filter (not.null) $ filter isntcomment $
-                           map (dropWhile (==' ')) $ lines foo
-              loc = length actual_loc
-          print loc
-          -- uncomment the following to check for mistakes in isntcomment
-          -- print actual_loc
-
-isntcomment ('-':'-':_) = False
-isntcomment ('{':'-':_) = False -- pragmas
-isntcomment _ = True
diff --git a/source/util/GenerateManpage.hs b/source/util/GenerateManpage.hs
deleted file mode 100644
index 3235757..0000000
--- a/source/util/GenerateManpage.hs
+++ /dev/null
@@ -1,92 +0,0 @@
-{-# LANGUAGE FlexibleContexts #-}
-
--- Generates a in-memory version of "man/xmonad.1.markdown" that has the list
--- of known key-bindings is inserted automatically from "Config.hs". That
--- document is then rendered with Pandoc as "man/xmonad.1" and
--- "man/xmonad.1.html".
---
--- Unlike the rest of xmonad, this file is released under the GNU General
--- Public License version 2 or later.
-
-import Control.Monad.IO.Class (liftIO)
-import Data.Char
-import Data.List
-import qualified Data.Text as T
-import qualified Data.Text.IO as TIO
-import Text.Pandoc
-import Text.Regex.Posix
-
-main :: IO ()
-main = do
-    keybindings <- guessBindings
-
-    markdownSource <- readFile "./man/xmonad.1.markdown"
-
-    runIOorExplode $ do
-        parsed <- readMarkdown (def { readerStandalone = True, readerExtensions = pandocExtensions })
-            . T.pack
-            . unlines
-            . replace "___KEYBINDINGS___" keybindings
-            . lines
-            $ markdownSource
-
-        manTemplate <- compileDefaultTemplate (T.pack "man")
-        manBody <- writeMan def { writerTemplate = Just manTemplate } parsed
-        liftIO $ TIO.writeFile "./man/xmonad.1" $ manBody
-        liftIO $ putStrLn "Documentation created: man/xmonad.1"
-
-        htmltemplate <- compileDefaultTemplate (T.pack "html")
-        htmlBody <- writeHtml5String def
-                                     { writerTemplate = Just htmltemplate
-                                     , writerTableOfContents = True }
-                                     parsed
-        liftIO $ TIO.writeFile "./man/xmonad.1.html" htmlBody
-        liftIO $ putStrLn "Documentation created: man/xmonad.1.html"
-
--- | The format for the docstrings in "Config.hs" takes the following form:
---
--- @
---   -- mod-x %! Frob the whatsit
--- @
---
--- "Frob the whatsit" will be used as the description for keybinding "mod-x".--
--- If the name of the key binding is omitted, the function tries to guess it
--- from the rest of the line. For example:
---
--- @
---   [ ((modMask .|. shiftMask, xK_Return), spawn "xterm") -- %! Launch an xterm
--- @
---
--- Here, "mod-shift-return" will be used as the key binding name.
-
-guessBindings :: IO String
-guessBindings = do
-  buf <- readFile "./src/XMonad/Config.hs"
-  return (intercalate "\n\n" (map markdownDefn (allBindings buf)))
-
-allBindings :: String -> [(String, String)]
-allBindings xs = map (binding . map trim) (xs =~ "(.*)--(.*)%!(.*)")
-
-binding :: [String] -> (String, String)
-binding [ _, bindingLine, "", desc ] = (guessKeys bindingLine, desc)
-binding [ _, _, keyCombo, desc ] = (keyCombo, desc)
-binding x = error ("binding: called with unexpected argument " ++ show x)
-
-guessKeys :: String -> String
-guessKeys line =
-  case keys of
-    [key] -> concat $ intersperse "-" (modifiers ++ [map toLower key])
-    _     -> error ("guessKeys: unexpected number of keys " ++ show keys)
-  where
-    modifiers = map (!!1) (line =~ "(mod|shift|control)Mask")
-    (_, _, _, keys) = line =~ "xK_([_[:alnum:]]+)" :: (String, String, String, [String])
-
--- FIXME: What escaping should we be doing on these strings?
-markdownDefn :: (String, String) -> String
-markdownDefn (key, desc) = key ++ "\n:     " ++ desc
-
-replace :: Eq a => a -> a -> [a] -> [a]
-replace x y = map (\a -> if a == x then y else a)
-
-trim :: String -> String
-trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace
diff --git a/source/util/hpcReport.sh b/source/util/hpcReport.sh
deleted file mode 100644
index ab934b3..0000000
--- a/source/util/hpcReport.sh
+++ /dev/null
@@ -1,33 +0,0 @@
-#!/bin/bash
-
-set -e
-
-if [[ ! ( -e xmonad.cabal && -e dist/hpc/tix/properties/properties.tix ) ]]; then
-  echo "run in the same dir as xmonad.cabal after having run
-
-      cabal configure --enable-tests --enable-library-coverage; cabal test
-
-        "
-  exit 1
-fi
-
-
-propsExclude=$(find tests/Properties -name '*.hs' \
-        | sed -e 's_/_._g' -e 's_.hs$__' -e 's_^tests._--exclude=_' )
-
-hpcFlags="
-  --hpcdir=dist/hpc/mix/
-  dist/hpc/tix/properties/properties.tix
-  "
-
-
-if [[ ! (-e dist/hpc/mix/Main.mix) ]]; then
-  mv dist/hpc/mix/properties/* dist/hpc/mix/
-  mv dist/hpc/mix/xmonad-*/xmonad-*/* dist/hpc/mix/xmonad-*/
-fi
-
-
-hpc markup --destdir=dist/hpc $hpcFlags > /dev/null
-echo "see dist/hpc/hpc_index.html
-"
-hpc report $hpcFlags
